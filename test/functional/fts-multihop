#!/usr/bin/env python
# meta: proxy=true
# meta: preconfig=../FTS3-config
import itertools
import logging
from lib import base, storage 


class TestMultihop(base.TestBase):

    def setUp(self):
        # Need to create one source, one hop and one destination
        self.transfers = []
        for (srcSa, dstSa) in storage.getStoragePairs():
            src = self.surl.generate(srcSa)
            hop = self.surl.generate(dstSa)
            dst = self.surl.generate(srcSa)
            self.transfers.append((src, hop, dst))


    def test_multihop(self):
        """
        Transfer multihop
        """
        for (src, hop, dst) in self.transfers:
            logging.info("Multihop transfer")
            logging.info("%s => %s => %s" % (src, hop, dst))

            self.surl.create(src)
            files = []
            files.append({'sources': [src], 'destinations': [hop]})
            files.append({'sources': [hop], 'destinations': [dst]})
            jobId = self.client.submit(files, ['--multi-hop'])

            logging.info("Got job id %s" % jobId)
            state = self.client.poll(jobId)
            logging.info("Job %s finished with %s" % (jobId, state))
            self.assertEqual('FINISHED', state, 'job.state')


    def test_multihop_hop_fails(self):
        """
        Transfer multihop, but the intermediate hop exists, overwrite is
        not passed, so the transfer must fail.
        """
        for (src, hop, dst) in self.transfers:
            logging.info("Multihop transfer with existing hop (no overwrite)")
            logging.info("%s => %s => %s" % (src, hop, dst))

            self.surl.create(src)
            self.surl.create(hop)
            files = []
            files.append({'sources': [src], 'destinations': [hop]})
            files.append({'sources': [hop], 'destinations': [dst]})
            jobId = self.client.submit(files, ['--multi-hop'])

            logging.info("Got job id %s" % jobId)
            state = self.client.poll(jobId)
            logging.info("Job %s finished with %s" % (jobId, state))

            # Job must be failed
            self.assertEqual('FAILED', state, 'job.state')

            # Both hops must be failed
            files = self.client.getFileInfo(jobId)
            self.assertEqual('FAILED', files[(src, hop)]['state'], 'job.file[0].state')
            self.assertEqual('FAILED', files[(hop, dst)]['state'], 'job.file[1].state')
            self.assertEqual('Not executed because a previous hop failed',
                             files[(hop, dst)]['reason'],
                             'job.file[1].reason')


    def test_multihop_final_fail(self):
        """
        Transfer multihop. First hop must pass, but the final destination
        exists, so the last hop will fail, and, therefore, the full job.
        """
        for (src, hop, dst) in self.transfers:
            logging.info("Multihop transfer with existing final destination (no overwrite)")
            logging.info("%s => %s => %s" % (src, hop, dst))

            self.surl.create(src)
            self.surl.create(dst)
            files = []
            files.append({'sources': [src], 'destinations': [hop]})
            files.append({'sources': [hop], 'destinations': [dst]})
            jobId = self.client.submit(files, ['--multi-hop'])

            logging.info("Got job id %s" % jobId)
            state = self.client.poll(jobId)
            logging.info("Job %s finished with %s" % (jobId, state))

            # Job must be failed
            self.assertEqual('FAILED', state, 'job.state')

            # First hop must have passed, second failed
            files = self.client.getFileInfo(jobId)
            self.assertEqual('FINISHED', files[(src, hop)]['state'], 'job.file[0].state')
            self.assertEqual('FAILED', files[(hop, dst)]['state'], 'job.file[1].state')


if __name__ == '__main__':
    import sys
    sys.exit(TestMultihop().run())

