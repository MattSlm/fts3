#!/usr/bin/env python
# meta: proxy=true
# meta: preconfig=../FTS3-config
import itertools
import logging
import time
from lib import base, fts3, storage


class TestCfgStandAlone(base.TestBase):
    
    def setUp(self):
        self.transfers = {}
        self.configuration = {}
        
        for (srcBaseSurl, dstBaseSurl) in storage.getStoragePairs():
            srcSE = storage.getStorageElement(srcBaseSurl)
            dstSE = storage.getStorageElement(dstBaseSurl)
            nestedTransfers = []
            for i in range(3):
                srcSurl = self.surl.generate(srcBaseSurl)
                dstSurl = self.surl.generate(dstBaseSurl)
                nestedTransfers.append((srcSurl, dstSurl))
            self.transfers[(srcSE, dstSE)] = nestedTransfers
            
            logging.info("Recovering current configuration for %s and %s" % (srcSE, dstSE))
            self.configuration[srcSE] = {'before': self.client.getConfig(srcSE)}
            self.configuration[dstSE] = {'before': self.client.getConfig(dstSE)}


    def resetConfig(self, se):
        config = self.configuration[se]
        before = config.get('before', None)
        after  = config.get('after', None)
        if before:
            logging.info("Restoring configuration for " + se)
            self.client.setConfig(before)
        elif after:
            logging.info("Removing configuration for " + se)
            self.client.delConfig(after)

        config['after'] = config['before']


    def tearDown(self):
        for (srcSE, dstSE) in self.transfers.keys():
            self._removeFiles(self.transfers[(srcSE, dstSE)])

        for se in self.configuration.keys():
            self.resetConfig(se)


    def transfer_and_poll(self, transfers):
        # Create the sources
        logging.info("Creating source files")
        for (src, dst) in transfers:
            self.surl.create(src)
        # Trigger three transfers
        logging.info("Spawning transfers")
        jobIds = []
        for (src, dst) in transfers:
            jobIds.append(self.client.submit([{'sources': [src], 'destinations': [dst]}]))
        logging.info("Jobs ids: %s" % (', '.join(jobIds)))
        # Query state and count actives
        logging.info("Entering polling...")
        submittedCount = len(transfers)
        activeCount = 0
        while (submittedCount + activeCount) > 0:
            states = map(lambda id: self.client.getJobState(id), jobIds)
            terminalCount = sum([1 for state in states if state in fts3.JobTerminalStates])
            activeCount = states.count('ACTIVE') + states.count('READY')
            submittedCount = states.count('SUBMITTED')
            
            totalCount = terminalCount + activeCount + submittedCount
            self.assertEqual(len(transfers), totalCount, 'jobs.count()')
            # Saldy, this can not be really asserted, since limits are soft
            #self.assertLessEqualThan(activeCount, 1)
            logging.debug("%d submitted, %d active, %d terminal" % (submittedCount, activeCount, terminalCount))

            time.sleep(1)
        return states


    def test_inbound(self):
        """
        Limit the inbound of the destination to 1, submit three.
        All must pass.
        """
        for (srcSE, dstSE) in self.transfers:
            # Set up config
            logging.info("Limiting inbound for %s (%s) to 1" % (dstSE, self.voName))
            newConfig = {
                'se': dstSE,
                'active': True,
                'in': {
                   'share': [{self.voName: 1}],
                   'protocol': 'auto'
                },
                'out': {
                   'share': [],
                   'protocol': 'auto'
                }
            }
            
            # Config
            self.configuration[srcSE]['after'] = newConfig
            self.client.setConfig(newConfig)
            
            # Transfer
            transfers = self.transfers[(srcSE, dstSE)]
            states = self.transfer_and_poll(transfers)
            
            # They should have passed
            self.assertEqual(len(transfers), states.count('FINISHED'), 'jobs.count("FINISHED")')

            # Reset config
            self.resetConfig(srcSE)


    def test_outbound(self):
        """
        Limit the outbout of the source to 1, submit three.
        All must pass.
        """
        for (srcSE, dstSE) in self.transfers:
            # Set up config
            logging.info("Limiting outbound for %s (%s) to 1" % (srcSE, self.voName))
            newConfig = {
                'se': srcSE,
                'active': True,
                'out': {
                   'share': [{self.voName: 1}],
                   'protocol': 'auto'
                },
                'in': {
                   'share': [],
                   'protocol': 'auto'
                }
            }
            
            # Config
            self.configuration[srcSE]['after'] = newConfig
            self.client.setConfig(newConfig)
            
            # Transfer
            transfers = self.transfers[(srcSE, dstSE)]
            states = self.transfer_and_poll(transfers)
            
            # They should have passed
            self.assertEqual(len(transfers), states.count('FINISHED'), 'jobs.count("FINISHED")')

            # Reset config
            self.resetConfig(srcSE)


    def test_inbound_zero(self):
        """
        Limit the inbound of the destination to 0, submit three.
        All must fail.
        """
        for (srcSE, dstSE) in self.transfers:
            # Set up config
            logging.info("Limiting inbound for %s (%s) to 0" % (dstSE, self.voName))
            newConfig = {
                'se': dstSE,
                'active': True,
                'in': {
                   'share': [{self.voName: 0}],
                   'protocol': 'auto'
                },
                'out': {
                   'share': [],
                   'protocol': 'auto'
                }
            }
            
            # Config
            self.configuration[srcSE]['after'] = newConfig
            self.client.setConfig(newConfig)
            
            # Transfer
            transfers = self.transfers[(srcSE, dstSE)]
            states = self.transfer_and_poll(transfers)
            
            # They should have passed
            self.assertEqual(len(transfers), states.count('FAILED'), 'jobs.count("FAILED")')

            # Reset config
            self.resetConfig(srcSE)

    def test_outbound_zero(self):
        """
        Limit the outbound of the source to 0, submit three.
        All must fail.
        """
        for (srcSE, dstSE) in self.transfers:
            # Set up config
            logging.info("Limiting outbound for %s (%s) to 0" % (srcSE, self.voName))
            newConfig = {
                'se': srcSE,
                'active': True,
                'out': {
                   'share': [{self.voName: 0}],
                   'protocol': 'auto'
                },
                'in': {
                   'share': [],
                   'protocol': 'auto'
                }
            }
            
            # Config
            self.configuration[srcSE]['after'] = newConfig
            self.client.setConfig(newConfig)
            
            # Transfer
            transfers = self.transfers[(srcSE, dstSE)]
            states = self.transfer_and_poll(transfers)
            
            # They should have passed
            self.assertEqual(len(transfers), states.count('FAILED'), 'jobs.count("FAILED")')

            # Reset config
            self.resetConfig(srcSE)


if __name__ == '__main__':
    import sys
    sys.exit(TestCfgStandAlone().run())
