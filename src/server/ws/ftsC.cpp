/* ftsC.cpp
   Generated by gSOAP 2.7.13 from fts3-transfer-submit.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

//#include "ftsH.h"
#include "ftsH.h"

SOAP_SOURCE_STAMP("@(#) ftsC.cpp ver 2.7.13 2012-01-27 13:17:22 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, "fts:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, "fts:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_in_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, "fts:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_in_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, "fts:ArrayOf_soapenc_string");
	case SOAP_TYPE_transfer__Roles:
		return soap_in_transfer__Roles(soap, NULL, NULL, "transfer:Roles");
	case SOAP_TYPE_transfer__StringPair:
		return soap_in_transfer__StringPair(soap, NULL, NULL, "transfer:StringPair");
	case SOAP_TYPE_transfer__ExistsException:
		return soap_in_transfer__ExistsException(soap, NULL, NULL, "transfer:ExistsException");
	case SOAP_TYPE_transfer__CannotCancelException:
		return soap_in_transfer__CannotCancelException(soap, NULL, NULL, "transfer:CannotCancelException");
	case SOAP_TYPE_transfer__TransferJobSummary2:
		return soap_in_transfer__TransferJobSummary2(soap, NULL, NULL, "transfer:TransferJobSummary2");
	case SOAP_TYPE_transfer__TransferJobSummary:
		return soap_in_transfer__TransferJobSummary(soap, NULL, NULL, "transfer:TransferJobSummary");
	case SOAP_TYPE_transfer__FileTransferStatus2:
		return soap_in_transfer__FileTransferStatus2(soap, NULL, NULL, "transfer:FileTransferStatus2");
	case SOAP_TYPE_transfer__NotExistsException:
		return soap_in_transfer__NotExistsException(soap, NULL, NULL, "transfer:NotExistsException");
	case SOAP_TYPE_transfer__FileTransferStatus:
		return soap_in_transfer__FileTransferStatus(soap, NULL, NULL, "transfer:FileTransferStatus");
	case SOAP_TYPE_transfer__JobStatus:
		return soap_in_transfer__JobStatus(soap, NULL, NULL, "transfer:JobStatus");
	case SOAP_TYPE_transfer__TransferJob2:
		return soap_in_transfer__TransferJob2(soap, NULL, NULL, "transfer:TransferJob2");
	case SOAP_TYPE_transfer__TransferJobElement2:
		return soap_in_transfer__TransferJobElement2(soap, NULL, NULL, "transfer:TransferJobElement2");
	case SOAP_TYPE_transfer__TransferJob:
		return soap_in_transfer__TransferJob(soap, NULL, NULL, "transfer:TransferJob");
	case SOAP_TYPE_transfer__TransferJobElement:
		return soap_in_transfer__TransferJobElement(soap, NULL, NULL, "transfer:TransferJobElement");
	case SOAP_TYPE_transfer__InternalException:
		return soap_in_transfer__InternalException(soap, NULL, NULL, "transfer:InternalException");
	case SOAP_TYPE_transfer__ServiceBusyException:
		return soap_in_transfer__ServiceBusyException(soap, NULL, NULL, "transfer:ServiceBusyException");
	case SOAP_TYPE_transfer__AuthorizationException:
		return soap_in_transfer__AuthorizationException(soap, NULL, NULL, "transfer:AuthorizationException");
	case SOAP_TYPE_transfer__InvalidArgumentException:
		return soap_in_transfer__InvalidArgumentException(soap, NULL, NULL, "transfer:InvalidArgumentException");
	case SOAP_TYPE_transfer__TransferException:
		return soap_in_transfer__TransferException(soap, NULL, NULL, "transfer:TransferException");
	case SOAP_TYPE_transfer__PlacementJob:
		return soap_in_transfer__PlacementJob(soap, NULL, NULL, "transfer:PlacementJob");
	case SOAP_TYPE_transfer__TransferParams:
		return soap_in_transfer__TransferParams(soap, NULL, NULL, "transfer:TransferParams");
	case SOAP_TYPE_fts__getServiceMetadata:
		return soap_in_fts__getServiceMetadata(soap, NULL, NULL, "fts:getServiceMetadata");
	case SOAP_TYPE_fts__getServiceMetadataResponse:
		return soap_in_fts__getServiceMetadataResponse(soap, NULL, NULL, "fts:getServiceMetadataResponse");
	case SOAP_TYPE_fts__getInterfaceVersion:
		return soap_in_fts__getInterfaceVersion(soap, NULL, NULL, "fts:getInterfaceVersion");
	case SOAP_TYPE_fts__getInterfaceVersionResponse:
		return soap_in_fts__getInterfaceVersionResponse(soap, NULL, NULL, "fts:getInterfaceVersionResponse");
	case SOAP_TYPE_fts__getSchemaVersion:
		return soap_in_fts__getSchemaVersion(soap, NULL, NULL, "fts:getSchemaVersion");
	case SOAP_TYPE_fts__getSchemaVersionResponse:
		return soap_in_fts__getSchemaVersionResponse(soap, NULL, NULL, "fts:getSchemaVersionResponse");
	case SOAP_TYPE_fts__getVersion:
		return soap_in_fts__getVersion(soap, NULL, NULL, "fts:getVersion");
	case SOAP_TYPE_fts__getVersionResponse:
		return soap_in_fts__getVersionResponse(soap, NULL, NULL, "fts:getVersionResponse");
	case SOAP_TYPE_fts__getRolesOf:
		return soap_in_fts__getRolesOf(soap, NULL, NULL, "fts:getRolesOf");
	case SOAP_TYPE_fts__getRolesOfResponse:
		return soap_in_fts__getRolesOfResponse(soap, NULL, NULL, "fts:getRolesOfResponse");
	case SOAP_TYPE_fts__getRoles:
		return soap_in_fts__getRoles(soap, NULL, NULL, "fts:getRoles");
	case SOAP_TYPE_fts__getRolesResponse:
		return soap_in_fts__getRolesResponse(soap, NULL, NULL, "fts:getRolesResponse");
	case SOAP_TYPE_fts__listVOManagers:
		return soap_in_fts__listVOManagers(soap, NULL, NULL, "fts:listVOManagers");
	case SOAP_TYPE_fts__listVOManagersResponse:
		return soap_in_fts__listVOManagersResponse(soap, NULL, NULL, "fts:listVOManagersResponse");
	case SOAP_TYPE_fts__removeVOManager:
		return soap_in_fts__removeVOManager(soap, NULL, NULL, "fts:removeVOManager");
	case SOAP_TYPE_fts__removeVOManagerResponse:
		return soap_in_fts__removeVOManagerResponse(soap, NULL, NULL, "fts:removeVOManagerResponse");
	case SOAP_TYPE_fts__addVOManager:
		return soap_in_fts__addVOManager(soap, NULL, NULL, "fts:addVOManager");
	case SOAP_TYPE_fts__addVOManagerResponse:
		return soap_in_fts__addVOManagerResponse(soap, NULL, NULL, "fts:addVOManagerResponse");
	case SOAP_TYPE_fts__setJobPriority:
		return soap_in_fts__setJobPriority(soap, NULL, NULL, "fts:setJobPriority");
	case SOAP_TYPE_fts__setJobPriorityResponse:
		return soap_in_fts__setJobPriorityResponse(soap, NULL, NULL, "fts:setJobPriorityResponse");
	case SOAP_TYPE_fts__cancel:
		return soap_in_fts__cancel(soap, NULL, NULL, "fts:cancel");
	case SOAP_TYPE_fts__cancelResponse:
		return soap_in_fts__cancelResponse(soap, NULL, NULL, "fts:cancelResponse");
	case SOAP_TYPE_fts__getTransferJobSummary2:
		return soap_in_fts__getTransferJobSummary2(soap, NULL, NULL, "fts:getTransferJobSummary2");
	case SOAP_TYPE_fts__getTransferJobSummary2Response:
		return soap_in_fts__getTransferJobSummary2Response(soap, NULL, NULL, "fts:getTransferJobSummary2Response");
	case SOAP_TYPE_fts__getTransferJobSummary:
		return soap_in_fts__getTransferJobSummary(soap, NULL, NULL, "fts:getTransferJobSummary");
	case SOAP_TYPE_fts__getTransferJobSummaryResponse:
		return soap_in_fts__getTransferJobSummaryResponse(soap, NULL, NULL, "fts:getTransferJobSummaryResponse");
	case SOAP_TYPE_fts__getTransferJobStatus:
		return soap_in_fts__getTransferJobStatus(soap, NULL, NULL, "fts:getTransferJobStatus");
	case SOAP_TYPE_fts__getTransferJobStatusResponse:
		return soap_in_fts__getTransferJobStatusResponse(soap, NULL, NULL, "fts:getTransferJobStatusResponse");
	case SOAP_TYPE_fts__getFileStatus2:
		return soap_in_fts__getFileStatus2(soap, NULL, NULL, "fts:getFileStatus2");
	case SOAP_TYPE_fts__getFileStatus2Response:
		return soap_in_fts__getFileStatus2Response(soap, NULL, NULL, "fts:getFileStatus2Response");
	case SOAP_TYPE_fts__getFileStatus:
		return soap_in_fts__getFileStatus(soap, NULL, NULL, "fts:getFileStatus");
	case SOAP_TYPE_fts__getFileStatusResponse:
		return soap_in_fts__getFileStatusResponse(soap, NULL, NULL, "fts:getFileStatusResponse");
	case SOAP_TYPE_fts__listRequests2:
		return soap_in_fts__listRequests2(soap, NULL, NULL, "fts:listRequests2");
	case SOAP_TYPE_fts__listRequests2Response:
		return soap_in_fts__listRequests2Response(soap, NULL, NULL, "fts:listRequests2Response");
	case SOAP_TYPE_fts__listRequests:
		return soap_in_fts__listRequests(soap, NULL, NULL, "fts:listRequests");
	case SOAP_TYPE_fts__listRequestsResponse:
		return soap_in_fts__listRequestsResponse(soap, NULL, NULL, "fts:listRequestsResponse");
	case SOAP_TYPE_fts__submit:
		return soap_in_fts__submit(soap, NULL, NULL, "fts:submit");
	case SOAP_TYPE_fts__submitResponse:
		return soap_in_fts__submitResponse(soap, NULL, NULL, "fts:submitResponse");
	case SOAP_TYPE_fts__transferSubmit3:
		return soap_in_fts__transferSubmit3(soap, NULL, NULL, "fts:transferSubmit3");
	case SOAP_TYPE_fts__transferSubmit3Response:
		return soap_in_fts__transferSubmit3Response(soap, NULL, NULL, "fts:transferSubmit3Response");
	case SOAP_TYPE_fts__transferSubmit2:
		return soap_in_fts__transferSubmit2(soap, NULL, NULL, "fts:transferSubmit2");
	case SOAP_TYPE_fts__transferSubmit2Response:
		return soap_in_fts__transferSubmit2Response(soap, NULL, NULL, "fts:transferSubmit2Response");
	case SOAP_TYPE_fts__transferSubmit:
		return soap_in_fts__transferSubmit(soap, NULL, NULL, "fts:transferSubmit");
	case SOAP_TYPE_fts__transferSubmitResponse:
		return soap_in_fts__transferSubmitResponse(soap, NULL, NULL, "fts:transferSubmitResponse");
	case SOAP_TYPE_fts__placementSubmit2:
		return soap_in_fts__placementSubmit2(soap, NULL, NULL, "fts:placementSubmit2");
	case SOAP_TYPE_fts__placementSubmit2Response:
		return soap_in_fts__placementSubmit2Response(soap, NULL, NULL, "fts:placementSubmit2Response");
	case SOAP_TYPE_fts__placementSubmit:
		return soap_in_fts__placementSubmit(soap, NULL, NULL, "fts:placementSubmit");
	case SOAP_TYPE_fts__placementSubmitResponse:
		return soap_in_fts__placementSubmitResponse(soap, NULL, NULL, "fts:placementSubmitResponse");
	case SOAP_TYPE_PointerTotransfer__Roles:
		return soap_in_PointerTotransfer__Roles(soap, NULL, NULL, "transfer:Roles");
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary2:
		return soap_in_PointerTotransfer__TransferJobSummary2(soap, NULL, NULL, "transfer:TransferJobSummary2");
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary:
		return soap_in_PointerTotransfer__TransferJobSummary(soap, NULL, NULL, "transfer:TransferJobSummary");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, "fts:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, "fts:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, "fts:ArrayOf_soapenc_string");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, "fts:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_PointerTotransfer__TransferJob2:
		return soap_in_PointerTotransfer__TransferJob2(soap, NULL, NULL, "transfer:TransferJob2");
	case SOAP_TYPE_PointerTotransfer__TransferJob:
		return soap_in_PointerTotransfer__TransferJob(soap, NULL, NULL, "transfer:TransferJob");
	case SOAP_TYPE_PointerTotransfer__PlacementJob:
		return soap_in_PointerTotransfer__PlacementJob(soap, NULL, NULL, "transfer:PlacementJob");
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus2:
		return soap_in_PointerTotransfer__FileTransferStatus2(soap, NULL, NULL, "transfer:FileTransferStatus2");
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus:
		return soap_in_PointerTotransfer__FileTransferStatus(soap, NULL, NULL, "transfer:FileTransferStatus");
	case SOAP_TYPE_PointerTotransfer__StringPair:
		return soap_in_PointerTotransfer__StringPair(soap, NULL, NULL, "transfer:StringPair");
	case SOAP_TYPE_PointerTotransfer__JobStatus:
		return soap_in_PointerTotransfer__JobStatus(soap, NULL, NULL, "transfer:JobStatus");
	case SOAP_TYPE_PointerTotransfer__TransferJobElement2:
		return soap_in_PointerTotransfer__TransferJobElement2(soap, NULL, NULL, "transfer:TransferJobElement2");
	case SOAP_TYPE_PointerTotransfer__TransferJobElement:
		return soap_in_PointerTotransfer__TransferJobElement(soap, NULL, NULL, "transfer:TransferJobElement");
	case SOAP_TYPE_PointerTotransfer__TransferParams:
		return soap_in_PointerTotransfer__TransferParams(soap, NULL, NULL, "transfer:TransferParams");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:ArrayOf_tns3_FileTransferStatus2"))
		{	*type = SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2;
			return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:ArrayOf_tns3_FileTransferStatus"))
		{	*type = SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus;
			return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:ArrayOf_tns3_JobStatus"))
		{	*type = SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus;
			return soap_in_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:ArrayOf_soapenc_string"))
		{	*type = SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring;
			return soap_in_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:Roles"))
		{	*type = SOAP_TYPE_transfer__Roles;
			return soap_in_transfer__Roles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:StringPair"))
		{	*type = SOAP_TYPE_transfer__StringPair;
			return soap_in_transfer__StringPair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:ExistsException"))
		{	*type = SOAP_TYPE_transfer__ExistsException;
			return soap_in_transfer__ExistsException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:CannotCancelException"))
		{	*type = SOAP_TYPE_transfer__CannotCancelException;
			return soap_in_transfer__CannotCancelException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJobSummary2"))
		{	*type = SOAP_TYPE_transfer__TransferJobSummary2;
			return soap_in_transfer__TransferJobSummary2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJobSummary"))
		{	*type = SOAP_TYPE_transfer__TransferJobSummary;
			return soap_in_transfer__TransferJobSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:FileTransferStatus2"))
		{	*type = SOAP_TYPE_transfer__FileTransferStatus2;
			return soap_in_transfer__FileTransferStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:NotExistsException"))
		{	*type = SOAP_TYPE_transfer__NotExistsException;
			return soap_in_transfer__NotExistsException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:FileTransferStatus"))
		{	*type = SOAP_TYPE_transfer__FileTransferStatus;
			return soap_in_transfer__FileTransferStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:JobStatus"))
		{	*type = SOAP_TYPE_transfer__JobStatus;
			return soap_in_transfer__JobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJob2"))
		{	*type = SOAP_TYPE_transfer__TransferJob2;
			return soap_in_transfer__TransferJob2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJobElement2"))
		{	*type = SOAP_TYPE_transfer__TransferJobElement2;
			return soap_in_transfer__TransferJobElement2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJob"))
		{	*type = SOAP_TYPE_transfer__TransferJob;
			return soap_in_transfer__TransferJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferJobElement"))
		{	*type = SOAP_TYPE_transfer__TransferJobElement;
			return soap_in_transfer__TransferJobElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:InternalException"))
		{	*type = SOAP_TYPE_transfer__InternalException;
			return soap_in_transfer__InternalException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:ServiceBusyException"))
		{	*type = SOAP_TYPE_transfer__ServiceBusyException;
			return soap_in_transfer__ServiceBusyException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:AuthorizationException"))
		{	*type = SOAP_TYPE_transfer__AuthorizationException;
			return soap_in_transfer__AuthorizationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:InvalidArgumentException"))
		{	*type = SOAP_TYPE_transfer__InvalidArgumentException;
			return soap_in_transfer__InvalidArgumentException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferException"))
		{	*type = SOAP_TYPE_transfer__TransferException;
			return soap_in_transfer__TransferException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:PlacementJob"))
		{	*type = SOAP_TYPE_transfer__PlacementJob;
			return soap_in_transfer__PlacementJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "transfer:TransferParams"))
		{	*type = SOAP_TYPE_transfer__TransferParams;
			return soap_in_transfer__TransferParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getServiceMetadata"))
		{	*type = SOAP_TYPE_fts__getServiceMetadata;
			return soap_in_fts__getServiceMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getServiceMetadataResponse"))
		{	*type = SOAP_TYPE_fts__getServiceMetadataResponse;
			return soap_in_fts__getServiceMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getInterfaceVersion"))
		{	*type = SOAP_TYPE_fts__getInterfaceVersion;
			return soap_in_fts__getInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_fts__getInterfaceVersionResponse;
			return soap_in_fts__getInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getSchemaVersion"))
		{	*type = SOAP_TYPE_fts__getSchemaVersion;
			return soap_in_fts__getSchemaVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getSchemaVersionResponse"))
		{	*type = SOAP_TYPE_fts__getSchemaVersionResponse;
			return soap_in_fts__getSchemaVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getVersion"))
		{	*type = SOAP_TYPE_fts__getVersion;
			return soap_in_fts__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getVersionResponse"))
		{	*type = SOAP_TYPE_fts__getVersionResponse;
			return soap_in_fts__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getRolesOf"))
		{	*type = SOAP_TYPE_fts__getRolesOf;
			return soap_in_fts__getRolesOf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getRolesOfResponse"))
		{	*type = SOAP_TYPE_fts__getRolesOfResponse;
			return soap_in_fts__getRolesOfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getRoles"))
		{	*type = SOAP_TYPE_fts__getRoles;
			return soap_in_fts__getRoles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getRolesResponse"))
		{	*type = SOAP_TYPE_fts__getRolesResponse;
			return soap_in_fts__getRolesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listVOManagers"))
		{	*type = SOAP_TYPE_fts__listVOManagers;
			return soap_in_fts__listVOManagers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listVOManagersResponse"))
		{	*type = SOAP_TYPE_fts__listVOManagersResponse;
			return soap_in_fts__listVOManagersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:removeVOManager"))
		{	*type = SOAP_TYPE_fts__removeVOManager;
			return soap_in_fts__removeVOManager(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:removeVOManagerResponse"))
		{	*type = SOAP_TYPE_fts__removeVOManagerResponse;
			return soap_in_fts__removeVOManagerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:addVOManager"))
		{	*type = SOAP_TYPE_fts__addVOManager;
			return soap_in_fts__addVOManager(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:addVOManagerResponse"))
		{	*type = SOAP_TYPE_fts__addVOManagerResponse;
			return soap_in_fts__addVOManagerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:setJobPriority"))
		{	*type = SOAP_TYPE_fts__setJobPriority;
			return soap_in_fts__setJobPriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:setJobPriorityResponse"))
		{	*type = SOAP_TYPE_fts__setJobPriorityResponse;
			return soap_in_fts__setJobPriorityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:cancel"))
		{	*type = SOAP_TYPE_fts__cancel;
			return soap_in_fts__cancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:cancelResponse"))
		{	*type = SOAP_TYPE_fts__cancelResponse;
			return soap_in_fts__cancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobSummary2"))
		{	*type = SOAP_TYPE_fts__getTransferJobSummary2;
			return soap_in_fts__getTransferJobSummary2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobSummary2Response"))
		{	*type = SOAP_TYPE_fts__getTransferJobSummary2Response;
			return soap_in_fts__getTransferJobSummary2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobSummary"))
		{	*type = SOAP_TYPE_fts__getTransferJobSummary;
			return soap_in_fts__getTransferJobSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobSummaryResponse"))
		{	*type = SOAP_TYPE_fts__getTransferJobSummaryResponse;
			return soap_in_fts__getTransferJobSummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobStatus"))
		{	*type = SOAP_TYPE_fts__getTransferJobStatus;
			return soap_in_fts__getTransferJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getTransferJobStatusResponse"))
		{	*type = SOAP_TYPE_fts__getTransferJobStatusResponse;
			return soap_in_fts__getTransferJobStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getFileStatus2"))
		{	*type = SOAP_TYPE_fts__getFileStatus2;
			return soap_in_fts__getFileStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getFileStatus2Response"))
		{	*type = SOAP_TYPE_fts__getFileStatus2Response;
			return soap_in_fts__getFileStatus2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getFileStatus"))
		{	*type = SOAP_TYPE_fts__getFileStatus;
			return soap_in_fts__getFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:getFileStatusResponse"))
		{	*type = SOAP_TYPE_fts__getFileStatusResponse;
			return soap_in_fts__getFileStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listRequests2"))
		{	*type = SOAP_TYPE_fts__listRequests2;
			return soap_in_fts__listRequests2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listRequests2Response"))
		{	*type = SOAP_TYPE_fts__listRequests2Response;
			return soap_in_fts__listRequests2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listRequests"))
		{	*type = SOAP_TYPE_fts__listRequests;
			return soap_in_fts__listRequests(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:listRequestsResponse"))
		{	*type = SOAP_TYPE_fts__listRequestsResponse;
			return soap_in_fts__listRequestsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:submit"))
		{	*type = SOAP_TYPE_fts__submit;
			return soap_in_fts__submit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:submitResponse"))
		{	*type = SOAP_TYPE_fts__submitResponse;
			return soap_in_fts__submitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmit3"))
		{	*type = SOAP_TYPE_fts__transferSubmit3;
			return soap_in_fts__transferSubmit3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmit3Response"))
		{	*type = SOAP_TYPE_fts__transferSubmit3Response;
			return soap_in_fts__transferSubmit3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmit2"))
		{	*type = SOAP_TYPE_fts__transferSubmit2;
			return soap_in_fts__transferSubmit2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmit2Response"))
		{	*type = SOAP_TYPE_fts__transferSubmit2Response;
			return soap_in_fts__transferSubmit2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmit"))
		{	*type = SOAP_TYPE_fts__transferSubmit;
			return soap_in_fts__transferSubmit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:transferSubmitResponse"))
		{	*type = SOAP_TYPE_fts__transferSubmitResponse;
			return soap_in_fts__transferSubmitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:placementSubmit2"))
		{	*type = SOAP_TYPE_fts__placementSubmit2;
			return soap_in_fts__placementSubmit2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:placementSubmit2Response"))
		{	*type = SOAP_TYPE_fts__placementSubmit2Response;
			return soap_in_fts__placementSubmit2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:placementSubmit"))
		{	*type = SOAP_TYPE_fts__placementSubmit;
			return soap_in_fts__placementSubmit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fts:placementSubmitResponse"))
		{	*type = SOAP_TYPE_fts__placementSubmitResponse;
			return soap_in_fts__placementSubmitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return ((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)ptr)->soap_out(soap, tag, id, "fts:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return ((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)ptr)->soap_out(soap, tag, id, "fts:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus:
		return ((fts__ArrayOf_USCOREtns3_USCOREJobStatus *)ptr)->soap_out(soap, tag, id, "fts:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring:
		return ((fts__ArrayOf_USCOREsoapenc_USCOREstring *)ptr)->soap_out(soap, tag, id, "fts:ArrayOf_soapenc_string");
	case SOAP_TYPE_transfer__Roles:
		return ((transfer__Roles *)ptr)->soap_out(soap, tag, id, "transfer:Roles");
	case SOAP_TYPE_transfer__StringPair:
		return ((transfer__StringPair *)ptr)->soap_out(soap, tag, id, "transfer:StringPair");
	case SOAP_TYPE_transfer__ExistsException:
		return ((transfer__ExistsException *)ptr)->soap_out(soap, tag, id, "transfer:ExistsException");
	case SOAP_TYPE_transfer__CannotCancelException:
		return ((transfer__CannotCancelException *)ptr)->soap_out(soap, tag, id, "transfer:CannotCancelException");
	case SOAP_TYPE_transfer__TransferJobSummary2:
		return ((transfer__TransferJobSummary2 *)ptr)->soap_out(soap, tag, id, "transfer:TransferJobSummary2");
	case SOAP_TYPE_transfer__TransferJobSummary:
		return ((transfer__TransferJobSummary *)ptr)->soap_out(soap, tag, id, "transfer:TransferJobSummary");
	case SOAP_TYPE_transfer__FileTransferStatus2:
		return ((transfer__FileTransferStatus2 *)ptr)->soap_out(soap, tag, id, "transfer:FileTransferStatus2");
	case SOAP_TYPE_transfer__NotExistsException:
		return ((transfer__NotExistsException *)ptr)->soap_out(soap, tag, id, "transfer:NotExistsException");
	case SOAP_TYPE_transfer__FileTransferStatus:
		return ((transfer__FileTransferStatus *)ptr)->soap_out(soap, tag, id, "transfer:FileTransferStatus");
	case SOAP_TYPE_transfer__JobStatus:
		return ((transfer__JobStatus *)ptr)->soap_out(soap, tag, id, "transfer:JobStatus");
	case SOAP_TYPE_transfer__TransferJob2:
		return ((transfer__TransferJob2 *)ptr)->soap_out(soap, tag, id, "transfer:TransferJob2");
	case SOAP_TYPE_transfer__TransferJobElement2:
		return ((transfer__TransferJobElement2 *)ptr)->soap_out(soap, tag, id, "transfer:TransferJobElement2");
	case SOAP_TYPE_transfer__TransferJob:
		return ((transfer__TransferJob *)ptr)->soap_out(soap, tag, id, "transfer:TransferJob");
	case SOAP_TYPE_transfer__TransferJobElement:
		return ((transfer__TransferJobElement *)ptr)->soap_out(soap, tag, id, "transfer:TransferJobElement");
	case SOAP_TYPE_transfer__InternalException:
		return ((transfer__InternalException *)ptr)->soap_out(soap, tag, id, "transfer:InternalException");
	case SOAP_TYPE_transfer__ServiceBusyException:
		return ((transfer__ServiceBusyException *)ptr)->soap_out(soap, tag, id, "transfer:ServiceBusyException");
	case SOAP_TYPE_transfer__AuthorizationException:
		return ((transfer__AuthorizationException *)ptr)->soap_out(soap, tag, id, "transfer:AuthorizationException");
	case SOAP_TYPE_transfer__InvalidArgumentException:
		return ((transfer__InvalidArgumentException *)ptr)->soap_out(soap, tag, id, "transfer:InvalidArgumentException");
	case SOAP_TYPE_transfer__TransferException:
		return ((transfer__TransferException *)ptr)->soap_out(soap, tag, id, "transfer:TransferException");
	case SOAP_TYPE_transfer__PlacementJob:
		return ((transfer__PlacementJob *)ptr)->soap_out(soap, tag, id, "transfer:PlacementJob");
	case SOAP_TYPE_transfer__TransferParams:
		return ((transfer__TransferParams *)ptr)->soap_out(soap, tag, id, "transfer:TransferParams");
	case SOAP_TYPE_fts__getServiceMetadata:
		return soap_out_fts__getServiceMetadata(soap, tag, id, (const struct fts__getServiceMetadata *)ptr, "fts:getServiceMetadata");
	case SOAP_TYPE_fts__getServiceMetadataResponse:
		return soap_out_fts__getServiceMetadataResponse(soap, tag, id, (const struct fts__getServiceMetadataResponse *)ptr, "fts:getServiceMetadataResponse");
	case SOAP_TYPE_fts__getInterfaceVersion:
		return soap_out_fts__getInterfaceVersion(soap, tag, id, (const struct fts__getInterfaceVersion *)ptr, "fts:getInterfaceVersion");
	case SOAP_TYPE_fts__getInterfaceVersionResponse:
		return soap_out_fts__getInterfaceVersionResponse(soap, tag, id, (const struct fts__getInterfaceVersionResponse *)ptr, "fts:getInterfaceVersionResponse");
	case SOAP_TYPE_fts__getSchemaVersion:
		return soap_out_fts__getSchemaVersion(soap, tag, id, (const struct fts__getSchemaVersion *)ptr, "fts:getSchemaVersion");
	case SOAP_TYPE_fts__getSchemaVersionResponse:
		return soap_out_fts__getSchemaVersionResponse(soap, tag, id, (const struct fts__getSchemaVersionResponse *)ptr, "fts:getSchemaVersionResponse");
	case SOAP_TYPE_fts__getVersion:
		return soap_out_fts__getVersion(soap, tag, id, (const struct fts__getVersion *)ptr, "fts:getVersion");
	case SOAP_TYPE_fts__getVersionResponse:
		return soap_out_fts__getVersionResponse(soap, tag, id, (const struct fts__getVersionResponse *)ptr, "fts:getVersionResponse");
	case SOAP_TYPE_fts__getRolesOf:
		return soap_out_fts__getRolesOf(soap, tag, id, (const struct fts__getRolesOf *)ptr, "fts:getRolesOf");
	case SOAP_TYPE_fts__getRolesOfResponse:
		return soap_out_fts__getRolesOfResponse(soap, tag, id, (const struct fts__getRolesOfResponse *)ptr, "fts:getRolesOfResponse");
	case SOAP_TYPE_fts__getRoles:
		return soap_out_fts__getRoles(soap, tag, id, (const struct fts__getRoles *)ptr, "fts:getRoles");
	case SOAP_TYPE_fts__getRolesResponse:
		return soap_out_fts__getRolesResponse(soap, tag, id, (const struct fts__getRolesResponse *)ptr, "fts:getRolesResponse");
	case SOAP_TYPE_fts__listVOManagers:
		return soap_out_fts__listVOManagers(soap, tag, id, (const struct fts__listVOManagers *)ptr, "fts:listVOManagers");
	case SOAP_TYPE_fts__listVOManagersResponse:
		return soap_out_fts__listVOManagersResponse(soap, tag, id, (const struct fts__listVOManagersResponse *)ptr, "fts:listVOManagersResponse");
	case SOAP_TYPE_fts__removeVOManager:
		return soap_out_fts__removeVOManager(soap, tag, id, (const struct fts__removeVOManager *)ptr, "fts:removeVOManager");
	case SOAP_TYPE_fts__removeVOManagerResponse:
		return soap_out_fts__removeVOManagerResponse(soap, tag, id, (const struct fts__removeVOManagerResponse *)ptr, "fts:removeVOManagerResponse");
	case SOAP_TYPE_fts__addVOManager:
		return soap_out_fts__addVOManager(soap, tag, id, (const struct fts__addVOManager *)ptr, "fts:addVOManager");
	case SOAP_TYPE_fts__addVOManagerResponse:
		return soap_out_fts__addVOManagerResponse(soap, tag, id, (const struct fts__addVOManagerResponse *)ptr, "fts:addVOManagerResponse");
	case SOAP_TYPE_fts__setJobPriority:
		return soap_out_fts__setJobPriority(soap, tag, id, (const struct fts__setJobPriority *)ptr, "fts:setJobPriority");
	case SOAP_TYPE_fts__setJobPriorityResponse:
		return soap_out_fts__setJobPriorityResponse(soap, tag, id, (const struct fts__setJobPriorityResponse *)ptr, "fts:setJobPriorityResponse");
	case SOAP_TYPE_fts__cancel:
		return soap_out_fts__cancel(soap, tag, id, (const struct fts__cancel *)ptr, "fts:cancel");
	case SOAP_TYPE_fts__cancelResponse:
		return soap_out_fts__cancelResponse(soap, tag, id, (const struct fts__cancelResponse *)ptr, "fts:cancelResponse");
	case SOAP_TYPE_fts__getTransferJobSummary2:
		return soap_out_fts__getTransferJobSummary2(soap, tag, id, (const struct fts__getTransferJobSummary2 *)ptr, "fts:getTransferJobSummary2");
	case SOAP_TYPE_fts__getTransferJobSummary2Response:
		return soap_out_fts__getTransferJobSummary2Response(soap, tag, id, (const struct fts__getTransferJobSummary2Response *)ptr, "fts:getTransferJobSummary2Response");
	case SOAP_TYPE_fts__getTransferJobSummary:
		return soap_out_fts__getTransferJobSummary(soap, tag, id, (const struct fts__getTransferJobSummary *)ptr, "fts:getTransferJobSummary");
	case SOAP_TYPE_fts__getTransferJobSummaryResponse:
		return soap_out_fts__getTransferJobSummaryResponse(soap, tag, id, (const struct fts__getTransferJobSummaryResponse *)ptr, "fts:getTransferJobSummaryResponse");
	case SOAP_TYPE_fts__getTransferJobStatus:
		return soap_out_fts__getTransferJobStatus(soap, tag, id, (const struct fts__getTransferJobStatus *)ptr, "fts:getTransferJobStatus");
	case SOAP_TYPE_fts__getTransferJobStatusResponse:
		return soap_out_fts__getTransferJobStatusResponse(soap, tag, id, (const struct fts__getTransferJobStatusResponse *)ptr, "fts:getTransferJobStatusResponse");
	case SOAP_TYPE_fts__getFileStatus2:
		return soap_out_fts__getFileStatus2(soap, tag, id, (const struct fts__getFileStatus2 *)ptr, "fts:getFileStatus2");
	case SOAP_TYPE_fts__getFileStatus2Response:
		return soap_out_fts__getFileStatus2Response(soap, tag, id, (const struct fts__getFileStatus2Response *)ptr, "fts:getFileStatus2Response");
	case SOAP_TYPE_fts__getFileStatus:
		return soap_out_fts__getFileStatus(soap, tag, id, (const struct fts__getFileStatus *)ptr, "fts:getFileStatus");
	case SOAP_TYPE_fts__getFileStatusResponse:
		return soap_out_fts__getFileStatusResponse(soap, tag, id, (const struct fts__getFileStatusResponse *)ptr, "fts:getFileStatusResponse");
	case SOAP_TYPE_fts__listRequests2:
		return soap_out_fts__listRequests2(soap, tag, id, (const struct fts__listRequests2 *)ptr, "fts:listRequests2");
	case SOAP_TYPE_fts__listRequests2Response:
		return soap_out_fts__listRequests2Response(soap, tag, id, (const struct fts__listRequests2Response *)ptr, "fts:listRequests2Response");
	case SOAP_TYPE_fts__listRequests:
		return soap_out_fts__listRequests(soap, tag, id, (const struct fts__listRequests *)ptr, "fts:listRequests");
	case SOAP_TYPE_fts__listRequestsResponse:
		return soap_out_fts__listRequestsResponse(soap, tag, id, (const struct fts__listRequestsResponse *)ptr, "fts:listRequestsResponse");
	case SOAP_TYPE_fts__submit:
		return soap_out_fts__submit(soap, tag, id, (const struct fts__submit *)ptr, "fts:submit");
	case SOAP_TYPE_fts__submitResponse:
		return soap_out_fts__submitResponse(soap, tag, id, (const struct fts__submitResponse *)ptr, "fts:submitResponse");
	case SOAP_TYPE_fts__transferSubmit3:
		return soap_out_fts__transferSubmit3(soap, tag, id, (const struct fts__transferSubmit3 *)ptr, "fts:transferSubmit3");
	case SOAP_TYPE_fts__transferSubmit3Response:
		return soap_out_fts__transferSubmit3Response(soap, tag, id, (const struct fts__transferSubmit3Response *)ptr, "fts:transferSubmit3Response");
	case SOAP_TYPE_fts__transferSubmit2:
		return soap_out_fts__transferSubmit2(soap, tag, id, (const struct fts__transferSubmit2 *)ptr, "fts:transferSubmit2");
	case SOAP_TYPE_fts__transferSubmit2Response:
		return soap_out_fts__transferSubmit2Response(soap, tag, id, (const struct fts__transferSubmit2Response *)ptr, "fts:transferSubmit2Response");
	case SOAP_TYPE_fts__transferSubmit:
		return soap_out_fts__transferSubmit(soap, tag, id, (const struct fts__transferSubmit *)ptr, "fts:transferSubmit");
	case SOAP_TYPE_fts__transferSubmitResponse:
		return soap_out_fts__transferSubmitResponse(soap, tag, id, (const struct fts__transferSubmitResponse *)ptr, "fts:transferSubmitResponse");
	case SOAP_TYPE_fts__placementSubmit2:
		return soap_out_fts__placementSubmit2(soap, tag, id, (const struct fts__placementSubmit2 *)ptr, "fts:placementSubmit2");
	case SOAP_TYPE_fts__placementSubmit2Response:
		return soap_out_fts__placementSubmit2Response(soap, tag, id, (const struct fts__placementSubmit2Response *)ptr, "fts:placementSubmit2Response");
	case SOAP_TYPE_fts__placementSubmit:
		return soap_out_fts__placementSubmit(soap, tag, id, (const struct fts__placementSubmit *)ptr, "fts:placementSubmit");
	case SOAP_TYPE_fts__placementSubmitResponse:
		return soap_out_fts__placementSubmitResponse(soap, tag, id, (const struct fts__placementSubmitResponse *)ptr, "fts:placementSubmitResponse");
	case SOAP_TYPE_PointerTotransfer__Roles:
		return soap_out_PointerTotransfer__Roles(soap, tag, id, (transfer__Roles *const*)ptr, "transfer:Roles");
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary2:
		return soap_out_PointerTotransfer__TransferJobSummary2(soap, tag, id, (transfer__TransferJobSummary2 *const*)ptr, "transfer:TransferJobSummary2");
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary:
		return soap_out_PointerTotransfer__TransferJobSummary(soap, tag, id, (transfer__TransferJobSummary *const*)ptr, "transfer:TransferJobSummary");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, id, (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*)ptr, "fts:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, id, (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*)ptr, "fts:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, id, (fts__ArrayOf_USCOREsoapenc_USCOREstring *const*)ptr, "fts:ArrayOf_soapenc_string");
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, id, (fts__ArrayOf_USCOREtns3_USCOREJobStatus *const*)ptr, "fts:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_PointerTotransfer__TransferJob2:
		return soap_out_PointerTotransfer__TransferJob2(soap, tag, id, (transfer__TransferJob2 *const*)ptr, "transfer:TransferJob2");
	case SOAP_TYPE_PointerTotransfer__TransferJob:
		return soap_out_PointerTotransfer__TransferJob(soap, tag, id, (transfer__TransferJob *const*)ptr, "transfer:TransferJob");
	case SOAP_TYPE_PointerTotransfer__PlacementJob:
		return soap_out_PointerTotransfer__PlacementJob(soap, tag, id, (transfer__PlacementJob *const*)ptr, "transfer:PlacementJob");
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus2:
		return soap_out_PointerTotransfer__FileTransferStatus2(soap, tag, id, (transfer__FileTransferStatus2 *const*)ptr, "transfer:FileTransferStatus2");
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus:
		return soap_out_PointerTotransfer__FileTransferStatus(soap, tag, id, (transfer__FileTransferStatus *const*)ptr, "transfer:FileTransferStatus");
	case SOAP_TYPE_PointerTotransfer__StringPair:
		return soap_out_PointerTotransfer__StringPair(soap, tag, id, (transfer__StringPair *const*)ptr, "transfer:StringPair");
	case SOAP_TYPE_PointerTotransfer__JobStatus:
		return soap_out_PointerTotransfer__JobStatus(soap, tag, id, (transfer__JobStatus *const*)ptr, "transfer:JobStatus");
	case SOAP_TYPE_PointerTotransfer__TransferJobElement2:
		return soap_out_PointerTotransfer__TransferJobElement2(soap, tag, id, (transfer__TransferJobElement2 *const*)ptr, "transfer:TransferJobElement2");
	case SOAP_TYPE_PointerTotransfer__TransferJobElement:
		return soap_out_PointerTotransfer__TransferJobElement(soap, tag, id, (transfer__TransferJobElement *const*)ptr, "transfer:TransferJobElement");
	case SOAP_TYPE_PointerTotransfer__TransferParams:
		return soap_out_PointerTotransfer__TransferParams(soap, tag, id, (transfer__TransferParams *const*)ptr, "transfer:TransferParams");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus:
		((fts__ArrayOf_USCOREtns3_USCOREJobStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring:
		((fts__ArrayOf_USCOREsoapenc_USCOREstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__Roles:
		((transfer__Roles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__StringPair:
		((transfer__StringPair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__ExistsException:
		((transfer__ExistsException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__CannotCancelException:
		((transfer__CannotCancelException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJobSummary2:
		((transfer__TransferJobSummary2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJobSummary:
		((transfer__TransferJobSummary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__FileTransferStatus2:
		((transfer__FileTransferStatus2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__NotExistsException:
		((transfer__NotExistsException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__FileTransferStatus:
		((transfer__FileTransferStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__JobStatus:
		((transfer__JobStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJob2:
		((transfer__TransferJob2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJobElement2:
		((transfer__TransferJobElement2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJob:
		((transfer__TransferJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferJobElement:
		((transfer__TransferJobElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__InternalException:
		((transfer__InternalException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__ServiceBusyException:
		((transfer__ServiceBusyException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__AuthorizationException:
		((transfer__AuthorizationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__InvalidArgumentException:
		((transfer__InvalidArgumentException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferException:
		((transfer__TransferException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__PlacementJob:
		((transfer__PlacementJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_transfer__TransferParams:
		((transfer__TransferParams *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts__getServiceMetadata:
		soap_serialize_fts__getServiceMetadata(soap, (const struct fts__getServiceMetadata *)ptr);
		break;
	case SOAP_TYPE_fts__getServiceMetadataResponse:
		soap_serialize_fts__getServiceMetadataResponse(soap, (const struct fts__getServiceMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getInterfaceVersion:
		soap_serialize_fts__getInterfaceVersion(soap, (const struct fts__getInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_fts__getInterfaceVersionResponse:
		soap_serialize_fts__getInterfaceVersionResponse(soap, (const struct fts__getInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getSchemaVersion:
		soap_serialize_fts__getSchemaVersion(soap, (const struct fts__getSchemaVersion *)ptr);
		break;
	case SOAP_TYPE_fts__getSchemaVersionResponse:
		soap_serialize_fts__getSchemaVersionResponse(soap, (const struct fts__getSchemaVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getVersion:
		soap_serialize_fts__getVersion(soap, (const struct fts__getVersion *)ptr);
		break;
	case SOAP_TYPE_fts__getVersionResponse:
		soap_serialize_fts__getVersionResponse(soap, (const struct fts__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getRolesOf:
		soap_serialize_fts__getRolesOf(soap, (const struct fts__getRolesOf *)ptr);
		break;
	case SOAP_TYPE_fts__getRolesOfResponse:
		soap_serialize_fts__getRolesOfResponse(soap, (const struct fts__getRolesOfResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getRoles:
		soap_serialize_fts__getRoles(soap, (const struct fts__getRoles *)ptr);
		break;
	case SOAP_TYPE_fts__getRolesResponse:
		soap_serialize_fts__getRolesResponse(soap, (const struct fts__getRolesResponse *)ptr);
		break;
	case SOAP_TYPE_fts__listVOManagers:
		soap_serialize_fts__listVOManagers(soap, (const struct fts__listVOManagers *)ptr);
		break;
	case SOAP_TYPE_fts__listVOManagersResponse:
		soap_serialize_fts__listVOManagersResponse(soap, (const struct fts__listVOManagersResponse *)ptr);
		break;
	case SOAP_TYPE_fts__removeVOManager:
		soap_serialize_fts__removeVOManager(soap, (const struct fts__removeVOManager *)ptr);
		break;
	case SOAP_TYPE_fts__removeVOManagerResponse:
		soap_serialize_fts__removeVOManagerResponse(soap, (const struct fts__removeVOManagerResponse *)ptr);
		break;
	case SOAP_TYPE_fts__addVOManager:
		soap_serialize_fts__addVOManager(soap, (const struct fts__addVOManager *)ptr);
		break;
	case SOAP_TYPE_fts__addVOManagerResponse:
		soap_serialize_fts__addVOManagerResponse(soap, (const struct fts__addVOManagerResponse *)ptr);
		break;
	case SOAP_TYPE_fts__setJobPriority:
		soap_serialize_fts__setJobPriority(soap, (const struct fts__setJobPriority *)ptr);
		break;
	case SOAP_TYPE_fts__setJobPriorityResponse:
		soap_serialize_fts__setJobPriorityResponse(soap, (const struct fts__setJobPriorityResponse *)ptr);
		break;
	case SOAP_TYPE_fts__cancel:
		soap_serialize_fts__cancel(soap, (const struct fts__cancel *)ptr);
		break;
	case SOAP_TYPE_fts__cancelResponse:
		soap_serialize_fts__cancelResponse(soap, (const struct fts__cancelResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobSummary2:
		soap_serialize_fts__getTransferJobSummary2(soap, (const struct fts__getTransferJobSummary2 *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobSummary2Response:
		soap_serialize_fts__getTransferJobSummary2Response(soap, (const struct fts__getTransferJobSummary2Response *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobSummary:
		soap_serialize_fts__getTransferJobSummary(soap, (const struct fts__getTransferJobSummary *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobSummaryResponse:
		soap_serialize_fts__getTransferJobSummaryResponse(soap, (const struct fts__getTransferJobSummaryResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobStatus:
		soap_serialize_fts__getTransferJobStatus(soap, (const struct fts__getTransferJobStatus *)ptr);
		break;
	case SOAP_TYPE_fts__getTransferJobStatusResponse:
		soap_serialize_fts__getTransferJobStatusResponse(soap, (const struct fts__getTransferJobStatusResponse *)ptr);
		break;
	case SOAP_TYPE_fts__getFileStatus2:
		soap_serialize_fts__getFileStatus2(soap, (const struct fts__getFileStatus2 *)ptr);
		break;
	case SOAP_TYPE_fts__getFileStatus2Response:
		soap_serialize_fts__getFileStatus2Response(soap, (const struct fts__getFileStatus2Response *)ptr);
		break;
	case SOAP_TYPE_fts__getFileStatus:
		soap_serialize_fts__getFileStatus(soap, (const struct fts__getFileStatus *)ptr);
		break;
	case SOAP_TYPE_fts__getFileStatusResponse:
		soap_serialize_fts__getFileStatusResponse(soap, (const struct fts__getFileStatusResponse *)ptr);
		break;
	case SOAP_TYPE_fts__listRequests2:
		soap_serialize_fts__listRequests2(soap, (const struct fts__listRequests2 *)ptr);
		break;
	case SOAP_TYPE_fts__listRequests2Response:
		soap_serialize_fts__listRequests2Response(soap, (const struct fts__listRequests2Response *)ptr);
		break;
	case SOAP_TYPE_fts__listRequests:
		soap_serialize_fts__listRequests(soap, (const struct fts__listRequests *)ptr);
		break;
	case SOAP_TYPE_fts__listRequestsResponse:
		soap_serialize_fts__listRequestsResponse(soap, (const struct fts__listRequestsResponse *)ptr);
		break;
	case SOAP_TYPE_fts__submit:
		soap_serialize_fts__submit(soap, (const struct fts__submit *)ptr);
		break;
	case SOAP_TYPE_fts__submitResponse:
		soap_serialize_fts__submitResponse(soap, (const struct fts__submitResponse *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmit3:
		soap_serialize_fts__transferSubmit3(soap, (const struct fts__transferSubmit3 *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmit3Response:
		soap_serialize_fts__transferSubmit3Response(soap, (const struct fts__transferSubmit3Response *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmit2:
		soap_serialize_fts__transferSubmit2(soap, (const struct fts__transferSubmit2 *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmit2Response:
		soap_serialize_fts__transferSubmit2Response(soap, (const struct fts__transferSubmit2Response *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmit:
		soap_serialize_fts__transferSubmit(soap, (const struct fts__transferSubmit *)ptr);
		break;
	case SOAP_TYPE_fts__transferSubmitResponse:
		soap_serialize_fts__transferSubmitResponse(soap, (const struct fts__transferSubmitResponse *)ptr);
		break;
	case SOAP_TYPE_fts__placementSubmit2:
		soap_serialize_fts__placementSubmit2(soap, (const struct fts__placementSubmit2 *)ptr);
		break;
	case SOAP_TYPE_fts__placementSubmit2Response:
		soap_serialize_fts__placementSubmit2Response(soap, (const struct fts__placementSubmit2Response *)ptr);
		break;
	case SOAP_TYPE_fts__placementSubmit:
		soap_serialize_fts__placementSubmit(soap, (const struct fts__placementSubmit *)ptr);
		break;
	case SOAP_TYPE_fts__placementSubmitResponse:
		soap_serialize_fts__placementSubmitResponse(soap, (const struct fts__placementSubmitResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__Roles:
		soap_serialize_PointerTotransfer__Roles(soap, (transfer__Roles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary2:
		soap_serialize_PointerTotransfer__TransferJobSummary2(soap, (transfer__TransferJobSummary2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJobSummary:
		soap_serialize_PointerTotransfer__TransferJobSummary(soap, (transfer__TransferJobSummary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring:
		soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, (fts__ArrayOf_USCOREsoapenc_USCOREstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus:
		soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, (fts__ArrayOf_USCOREtns3_USCOREJobStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJob2:
		soap_serialize_PointerTotransfer__TransferJob2(soap, (transfer__TransferJob2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJob:
		soap_serialize_PointerTotransfer__TransferJob(soap, (transfer__TransferJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__PlacementJob:
		soap_serialize_PointerTotransfer__PlacementJob(soap, (transfer__PlacementJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus2:
		soap_serialize_PointerTotransfer__FileTransferStatus2(soap, (transfer__FileTransferStatus2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__FileTransferStatus:
		soap_serialize_PointerTotransfer__FileTransferStatus(soap, (transfer__FileTransferStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__StringPair:
		soap_serialize_PointerTotransfer__StringPair(soap, (transfer__StringPair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__JobStatus:
		soap_serialize_PointerTotransfer__JobStatus(soap, (transfer__JobStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJobElement2:
		soap_serialize_PointerTotransfer__TransferJobElement2(soap, (transfer__TransferJobElement2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferJobElement:
		soap_serialize_PointerTotransfer__TransferJobElement(soap, (transfer__TransferJobElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotransfer__TransferParams:
		soap_serialize_PointerTotransfer__TransferParams(soap, (transfer__TransferParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferParams:
		return (void*)soap_instantiate_transfer__TransferParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__PlacementJob:
		return (void*)soap_instantiate_transfer__PlacementJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferException:
		return (void*)soap_instantiate_transfer__TransferException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJobElement:
		return (void*)soap_instantiate_transfer__TransferJobElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJob:
		return (void*)soap_instantiate_transfer__TransferJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJobElement2:
		return (void*)soap_instantiate_transfer__TransferJobElement2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJob2:
		return (void*)soap_instantiate_transfer__TransferJob2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__JobStatus:
		return (void*)soap_instantiate_transfer__JobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__FileTransferStatus:
		return (void*)soap_instantiate_transfer__FileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJobSummary:
		return (void*)soap_instantiate_transfer__TransferJobSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__StringPair:
		return (void*)soap_instantiate_transfer__StringPair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__Roles:
		return (void*)soap_instantiate_transfer__Roles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring:
		return (void*)soap_instantiate_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus:
		return (void*)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return (void*)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return (void*)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__InvalidArgumentException:
		return (void*)soap_instantiate_transfer__InvalidArgumentException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__AuthorizationException:
		return (void*)soap_instantiate_transfer__AuthorizationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__ServiceBusyException:
		return (void*)soap_instantiate_transfer__ServiceBusyException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__InternalException:
		return (void*)soap_instantiate_transfer__InternalException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__NotExistsException:
		return (void*)soap_instantiate_transfer__NotExistsException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__FileTransferStatus2:
		return (void*)soap_instantiate_transfer__FileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__TransferJobSummary2:
		return (void*)soap_instantiate_transfer__TransferJobSummary2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__CannotCancelException:
		return (void*)soap_instantiate_transfer__CannotCancelException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_transfer__ExistsException:
		return (void*)soap_instantiate_transfer__ExistsException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__placementSubmitResponse:
		return (void*)soap_instantiate_fts__placementSubmitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__placementSubmit:
		return (void*)soap_instantiate_fts__placementSubmit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__placementSubmit2Response:
		return (void*)soap_instantiate_fts__placementSubmit2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__placementSubmit2:
		return (void*)soap_instantiate_fts__placementSubmit2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmitResponse:
		return (void*)soap_instantiate_fts__transferSubmitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmit:
		return (void*)soap_instantiate_fts__transferSubmit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmit2Response:
		return (void*)soap_instantiate_fts__transferSubmit2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmit2:
		return (void*)soap_instantiate_fts__transferSubmit2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmit3Response:
		return (void*)soap_instantiate_fts__transferSubmit3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__transferSubmit3:
		return (void*)soap_instantiate_fts__transferSubmit3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__submitResponse:
		return (void*)soap_instantiate_fts__submitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__submit:
		return (void*)soap_instantiate_fts__submit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listRequestsResponse:
		return (void*)soap_instantiate_fts__listRequestsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listRequests:
		return (void*)soap_instantiate_fts__listRequests(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listRequests2Response:
		return (void*)soap_instantiate_fts__listRequests2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listRequests2:
		return (void*)soap_instantiate_fts__listRequests2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getFileStatusResponse:
		return (void*)soap_instantiate_fts__getFileStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getFileStatus:
		return (void*)soap_instantiate_fts__getFileStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getFileStatus2Response:
		return (void*)soap_instantiate_fts__getFileStatus2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getFileStatus2:
		return (void*)soap_instantiate_fts__getFileStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobStatusResponse:
		return (void*)soap_instantiate_fts__getTransferJobStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobStatus:
		return (void*)soap_instantiate_fts__getTransferJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobSummaryResponse:
		return (void*)soap_instantiate_fts__getTransferJobSummaryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobSummary:
		return (void*)soap_instantiate_fts__getTransferJobSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobSummary2Response:
		return (void*)soap_instantiate_fts__getTransferJobSummary2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getTransferJobSummary2:
		return (void*)soap_instantiate_fts__getTransferJobSummary2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__cancelResponse:
		return (void*)soap_instantiate_fts__cancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__cancel:
		return (void*)soap_instantiate_fts__cancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__setJobPriorityResponse:
		return (void*)soap_instantiate_fts__setJobPriorityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__setJobPriority:
		return (void*)soap_instantiate_fts__setJobPriority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__addVOManagerResponse:
		return (void*)soap_instantiate_fts__addVOManagerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__addVOManager:
		return (void*)soap_instantiate_fts__addVOManager(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__removeVOManagerResponse:
		return (void*)soap_instantiate_fts__removeVOManagerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__removeVOManager:
		return (void*)soap_instantiate_fts__removeVOManager(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listVOManagersResponse:
		return (void*)soap_instantiate_fts__listVOManagersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__listVOManagers:
		return (void*)soap_instantiate_fts__listVOManagers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getRolesResponse:
		return (void*)soap_instantiate_fts__getRolesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getRoles:
		return (void*)soap_instantiate_fts__getRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getRolesOfResponse:
		return (void*)soap_instantiate_fts__getRolesOfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getRolesOf:
		return (void*)soap_instantiate_fts__getRolesOf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getVersionResponse:
		return (void*)soap_instantiate_fts__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getVersion:
		return (void*)soap_instantiate_fts__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getSchemaVersionResponse:
		return (void*)soap_instantiate_fts__getSchemaVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getSchemaVersion:
		return (void*)soap_instantiate_fts__getSchemaVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getInterfaceVersionResponse:
		return (void*)soap_instantiate_fts__getInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getInterfaceVersion:
		return (void*)soap_instantiate_fts__getInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getServiceMetadataResponse:
		return (void*)soap_instantiate_fts__getServiceMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts__getServiceMetadata:
		return (void*)soap_instantiate_fts__getServiceMetadata(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__JobStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__StringPair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__StringPair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferParams:
		if (p->size < 0)
			delete (transfer__TransferParams*)p->ptr;
		else
			delete[] (transfer__TransferParams*)p->ptr;
		break;
	case SOAP_TYPE_transfer__PlacementJob:
		if (p->size < 0)
			delete (transfer__PlacementJob*)p->ptr;
		else
			delete[] (transfer__PlacementJob*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferException:
		if (p->size < 0)
			delete (transfer__TransferException*)p->ptr;
		else
			delete[] (transfer__TransferException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJobElement:
		if (p->size < 0)
			delete (transfer__TransferJobElement*)p->ptr;
		else
			delete[] (transfer__TransferJobElement*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJob:
		if (p->size < 0)
			delete (transfer__TransferJob*)p->ptr;
		else
			delete[] (transfer__TransferJob*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJobElement2:
		if (p->size < 0)
			delete (transfer__TransferJobElement2*)p->ptr;
		else
			delete[] (transfer__TransferJobElement2*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJob2:
		if (p->size < 0)
			delete (transfer__TransferJob2*)p->ptr;
		else
			delete[] (transfer__TransferJob2*)p->ptr;
		break;
	case SOAP_TYPE_transfer__JobStatus:
		if (p->size < 0)
			delete (transfer__JobStatus*)p->ptr;
		else
			delete[] (transfer__JobStatus*)p->ptr;
		break;
	case SOAP_TYPE_transfer__FileTransferStatus:
		if (p->size < 0)
			delete (transfer__FileTransferStatus*)p->ptr;
		else
			delete[] (transfer__FileTransferStatus*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJobSummary:
		if (p->size < 0)
			delete (transfer__TransferJobSummary*)p->ptr;
		else
			delete[] (transfer__TransferJobSummary*)p->ptr;
		break;
	case SOAP_TYPE_transfer__StringPair:
		if (p->size < 0)
			delete (transfer__StringPair*)p->ptr;
		else
			delete[] (transfer__StringPair*)p->ptr;
		break;
	case SOAP_TYPE_transfer__Roles:
		if (p->size < 0)
			delete (transfer__Roles*)p->ptr;
		else
			delete[] (transfer__Roles*)p->ptr;
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring:
		if (p->size < 0)
			delete (fts__ArrayOf_USCOREsoapenc_USCOREstring*)p->ptr;
		else
			delete[] (fts__ArrayOf_USCOREsoapenc_USCOREstring*)p->ptr;
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus:
		if (p->size < 0)
			delete (fts__ArrayOf_USCOREtns3_USCOREJobStatus*)p->ptr;
		else
			delete[] (fts__ArrayOf_USCOREtns3_USCOREJobStatus*)p->ptr;
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		if (p->size < 0)
			delete (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p->ptr;
		else
			delete[] (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p->ptr;
		break;
	case SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		if (p->size < 0)
			delete (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p->ptr;
		else
			delete[] (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p->ptr;
		break;
	case SOAP_TYPE_transfer__InvalidArgumentException:
		if (p->size < 0)
			delete (transfer__InvalidArgumentException*)p->ptr;
		else
			delete[] (transfer__InvalidArgumentException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__AuthorizationException:
		if (p->size < 0)
			delete (transfer__AuthorizationException*)p->ptr;
		else
			delete[] (transfer__AuthorizationException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__ServiceBusyException:
		if (p->size < 0)
			delete (transfer__ServiceBusyException*)p->ptr;
		else
			delete[] (transfer__ServiceBusyException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__InternalException:
		if (p->size < 0)
			delete (transfer__InternalException*)p->ptr;
		else
			delete[] (transfer__InternalException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__NotExistsException:
		if (p->size < 0)
			delete (transfer__NotExistsException*)p->ptr;
		else
			delete[] (transfer__NotExistsException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__FileTransferStatus2:
		if (p->size < 0)
			delete (transfer__FileTransferStatus2*)p->ptr;
		else
			delete[] (transfer__FileTransferStatus2*)p->ptr;
		break;
	case SOAP_TYPE_transfer__TransferJobSummary2:
		if (p->size < 0)
			delete (transfer__TransferJobSummary2*)p->ptr;
		else
			delete[] (transfer__TransferJobSummary2*)p->ptr;
		break;
	case SOAP_TYPE_transfer__CannotCancelException:
		if (p->size < 0)
			delete (transfer__CannotCancelException*)p->ptr;
		else
			delete[] (transfer__CannotCancelException*)p->ptr;
		break;
	case SOAP_TYPE_transfer__ExistsException:
		if (p->size < 0)
			delete (transfer__ExistsException*)p->ptr;
		else
			delete[] (transfer__ExistsException*)p->ptr;
		break;
	case SOAP_TYPE_fts__placementSubmitResponse:
		if (p->size < 0)
			delete (struct fts__placementSubmitResponse*)p->ptr;
		else
			delete[] (struct fts__placementSubmitResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__placementSubmit:
		if (p->size < 0)
			delete (struct fts__placementSubmit*)p->ptr;
		else
			delete[] (struct fts__placementSubmit*)p->ptr;
		break;
	case SOAP_TYPE_fts__placementSubmit2Response:
		if (p->size < 0)
			delete (struct fts__placementSubmit2Response*)p->ptr;
		else
			delete[] (struct fts__placementSubmit2Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__placementSubmit2:
		if (p->size < 0)
			delete (struct fts__placementSubmit2*)p->ptr;
		else
			delete[] (struct fts__placementSubmit2*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmitResponse:
		if (p->size < 0)
			delete (struct fts__transferSubmitResponse*)p->ptr;
		else
			delete[] (struct fts__transferSubmitResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmit:
		if (p->size < 0)
			delete (struct fts__transferSubmit*)p->ptr;
		else
			delete[] (struct fts__transferSubmit*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmit2Response:
		if (p->size < 0)
			delete (struct fts__transferSubmit2Response*)p->ptr;
		else
			delete[] (struct fts__transferSubmit2Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmit2:
		if (p->size < 0)
			delete (struct fts__transferSubmit2*)p->ptr;
		else
			delete[] (struct fts__transferSubmit2*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmit3Response:
		if (p->size < 0)
			delete (struct fts__transferSubmit3Response*)p->ptr;
		else
			delete[] (struct fts__transferSubmit3Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__transferSubmit3:
		if (p->size < 0)
			delete (struct fts__transferSubmit3*)p->ptr;
		else
			delete[] (struct fts__transferSubmit3*)p->ptr;
		break;
	case SOAP_TYPE_fts__submitResponse:
		if (p->size < 0)
			delete (struct fts__submitResponse*)p->ptr;
		else
			delete[] (struct fts__submitResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__submit:
		if (p->size < 0)
			delete (struct fts__submit*)p->ptr;
		else
			delete[] (struct fts__submit*)p->ptr;
		break;
	case SOAP_TYPE_fts__listRequestsResponse:
		if (p->size < 0)
			delete (struct fts__listRequestsResponse*)p->ptr;
		else
			delete[] (struct fts__listRequestsResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__listRequests:
		if (p->size < 0)
			delete (struct fts__listRequests*)p->ptr;
		else
			delete[] (struct fts__listRequests*)p->ptr;
		break;
	case SOAP_TYPE_fts__listRequests2Response:
		if (p->size < 0)
			delete (struct fts__listRequests2Response*)p->ptr;
		else
			delete[] (struct fts__listRequests2Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__listRequests2:
		if (p->size < 0)
			delete (struct fts__listRequests2*)p->ptr;
		else
			delete[] (struct fts__listRequests2*)p->ptr;
		break;
	case SOAP_TYPE_fts__getFileStatusResponse:
		if (p->size < 0)
			delete (struct fts__getFileStatusResponse*)p->ptr;
		else
			delete[] (struct fts__getFileStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getFileStatus:
		if (p->size < 0)
			delete (struct fts__getFileStatus*)p->ptr;
		else
			delete[] (struct fts__getFileStatus*)p->ptr;
		break;
	case SOAP_TYPE_fts__getFileStatus2Response:
		if (p->size < 0)
			delete (struct fts__getFileStatus2Response*)p->ptr;
		else
			delete[] (struct fts__getFileStatus2Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__getFileStatus2:
		if (p->size < 0)
			delete (struct fts__getFileStatus2*)p->ptr;
		else
			delete[] (struct fts__getFileStatus2*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobStatusResponse:
		if (p->size < 0)
			delete (struct fts__getTransferJobStatusResponse*)p->ptr;
		else
			delete[] (struct fts__getTransferJobStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobStatus:
		if (p->size < 0)
			delete (struct fts__getTransferJobStatus*)p->ptr;
		else
			delete[] (struct fts__getTransferJobStatus*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobSummaryResponse:
		if (p->size < 0)
			delete (struct fts__getTransferJobSummaryResponse*)p->ptr;
		else
			delete[] (struct fts__getTransferJobSummaryResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobSummary:
		if (p->size < 0)
			delete (struct fts__getTransferJobSummary*)p->ptr;
		else
			delete[] (struct fts__getTransferJobSummary*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobSummary2Response:
		if (p->size < 0)
			delete (struct fts__getTransferJobSummary2Response*)p->ptr;
		else
			delete[] (struct fts__getTransferJobSummary2Response*)p->ptr;
		break;
	case SOAP_TYPE_fts__getTransferJobSummary2:
		if (p->size < 0)
			delete (struct fts__getTransferJobSummary2*)p->ptr;
		else
			delete[] (struct fts__getTransferJobSummary2*)p->ptr;
		break;
	case SOAP_TYPE_fts__cancelResponse:
		if (p->size < 0)
			delete (struct fts__cancelResponse*)p->ptr;
		else
			delete[] (struct fts__cancelResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__cancel:
		if (p->size < 0)
			delete (struct fts__cancel*)p->ptr;
		else
			delete[] (struct fts__cancel*)p->ptr;
		break;
	case SOAP_TYPE_fts__setJobPriorityResponse:
		if (p->size < 0)
			delete (struct fts__setJobPriorityResponse*)p->ptr;
		else
			delete[] (struct fts__setJobPriorityResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__setJobPriority:
		if (p->size < 0)
			delete (struct fts__setJobPriority*)p->ptr;
		else
			delete[] (struct fts__setJobPriority*)p->ptr;
		break;
	case SOAP_TYPE_fts__addVOManagerResponse:
		if (p->size < 0)
			delete (struct fts__addVOManagerResponse*)p->ptr;
		else
			delete[] (struct fts__addVOManagerResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__addVOManager:
		if (p->size < 0)
			delete (struct fts__addVOManager*)p->ptr;
		else
			delete[] (struct fts__addVOManager*)p->ptr;
		break;
	case SOAP_TYPE_fts__removeVOManagerResponse:
		if (p->size < 0)
			delete (struct fts__removeVOManagerResponse*)p->ptr;
		else
			delete[] (struct fts__removeVOManagerResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__removeVOManager:
		if (p->size < 0)
			delete (struct fts__removeVOManager*)p->ptr;
		else
			delete[] (struct fts__removeVOManager*)p->ptr;
		break;
	case SOAP_TYPE_fts__listVOManagersResponse:
		if (p->size < 0)
			delete (struct fts__listVOManagersResponse*)p->ptr;
		else
			delete[] (struct fts__listVOManagersResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__listVOManagers:
		if (p->size < 0)
			delete (struct fts__listVOManagers*)p->ptr;
		else
			delete[] (struct fts__listVOManagers*)p->ptr;
		break;
	case SOAP_TYPE_fts__getRolesResponse:
		if (p->size < 0)
			delete (struct fts__getRolesResponse*)p->ptr;
		else
			delete[] (struct fts__getRolesResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getRoles:
		if (p->size < 0)
			delete (struct fts__getRoles*)p->ptr;
		else
			delete[] (struct fts__getRoles*)p->ptr;
		break;
	case SOAP_TYPE_fts__getRolesOfResponse:
		if (p->size < 0)
			delete (struct fts__getRolesOfResponse*)p->ptr;
		else
			delete[] (struct fts__getRolesOfResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getRolesOf:
		if (p->size < 0)
			delete (struct fts__getRolesOf*)p->ptr;
		else
			delete[] (struct fts__getRolesOf*)p->ptr;
		break;
	case SOAP_TYPE_fts__getVersionResponse:
		if (p->size < 0)
			delete (struct fts__getVersionResponse*)p->ptr;
		else
			delete[] (struct fts__getVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getVersion:
		if (p->size < 0)
			delete (struct fts__getVersion*)p->ptr;
		else
			delete[] (struct fts__getVersion*)p->ptr;
		break;
	case SOAP_TYPE_fts__getSchemaVersionResponse:
		if (p->size < 0)
			delete (struct fts__getSchemaVersionResponse*)p->ptr;
		else
			delete[] (struct fts__getSchemaVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getSchemaVersion:
		if (p->size < 0)
			delete (struct fts__getSchemaVersion*)p->ptr;
		else
			delete[] (struct fts__getSchemaVersion*)p->ptr;
		break;
	case SOAP_TYPE_fts__getInterfaceVersionResponse:
		if (p->size < 0)
			delete (struct fts__getInterfaceVersionResponse*)p->ptr;
		else
			delete[] (struct fts__getInterfaceVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getInterfaceVersion:
		if (p->size < 0)
			delete (struct fts__getInterfaceVersion*)p->ptr;
		else
			delete[] (struct fts__getInterfaceVersion*)p->ptr;
		break;
	case SOAP_TYPE_fts__getServiceMetadataResponse:
		if (p->size < 0)
			delete (struct fts__getServiceMetadataResponse*)p->ptr;
		else
			delete[] (struct fts__getServiceMetadataResponse*)p->ptr;
		break;
	case SOAP_TYPE_fts__getServiceMetadata:
		if (p->size < 0)
			delete (struct fts__getServiceMetadata*)p->ptr;
		else
			delete[] (struct fts__getServiceMetadata*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2:
		if (p->size < 0)
			delete (std::vector<transfer__FileTransferStatus2 * >*)p->ptr;
		else
			delete[] (std::vector<transfer__FileTransferStatus2 * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus:
		if (p->size < 0)
			delete (std::vector<transfer__FileTransferStatus * >*)p->ptr;
		else
			delete[] (std::vector<transfer__FileTransferStatus * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__JobStatus:
		if (p->size < 0)
			delete (std::vector<transfer__JobStatus * >*)p->ptr;
		else
			delete[] (std::vector<transfer__JobStatus * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__StringPair:
		if (p->size < 0)
			delete (std::vector<transfer__StringPair * >*)p->ptr;
		else
			delete[] (std::vector<transfer__StringPair * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement2:
		if (p->size < 0)
			delete (std::vector<transfer__TransferJobElement2 * >*)p->ptr;
		else
			delete[] (std::vector<transfer__TransferJobElement2 * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement:
		if (p->size < 0)
			delete (std::vector<transfer__TransferJobElement * >*)p->ptr;
		else
			delete[] (std::vector<transfer__TransferJobElement * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__FileTransferStatus2 * >*)p)[len] = *(transfer__FileTransferStatus2 **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__FileTransferStatus * >*)p)[len] = *(transfer__FileTransferStatus **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__JobStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__JobStatus * >*)p)[len] = *(transfer__JobStatus **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__StringPair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__StringPair * >*)p)[len] = *(transfer__StringPair **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__TransferJobElement2 * >*)p)[len] = *(transfer__TransferJobElement2 **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<transfer__TransferJobElement * >*)p)[len] = *(transfer__TransferJobElement **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, &this->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item);
	/* transient soap skipped */
}

void fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, &this->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item);
	/* transient soap skipped */
}

int fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, int id, const fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, "item", -1, &(a->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, this, tag, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC4 soap_get_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, this, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC4 soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, "item", &(a->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item), "transfer:FileTransferStatus2"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, 0, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), 0, soap_copy_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC4 soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2;
		if (size)
			*size = sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		for (int i = 0; i < n; i++)
			((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 %p -> %p\n", q, p));
	*(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p = *(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)q;
}

void fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, &this->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item);
	/* transient soap skipped */
}

void fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, &this->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item);
	/* transient soap skipped */
}

int fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, int id, const fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, "item", -1, &(a->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, this, tag, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC4 soap_get_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, this, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC4 soap_in_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, "item", &(a->fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item), "transfer:FileTransferStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus, 0, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus), 0, soap_copy_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC4 soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus;
		if (size)
			*size = sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		for (int i = 0; i < n; i++)
			((fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus %p -> %p\n", q, p));
	*(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p = *(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)q;
}

void fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, &this->fts__ArrayOf_USCOREtns3_USCOREJobStatus::item);
	/* transient soap skipped */
}

void fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, &this->fts__ArrayOf_USCOREtns3_USCOREJobStatus::item);
	/* transient soap skipped */
}

int fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, int id, const fts__ArrayOf_USCOREtns3_USCOREJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, "item", -1, &(a->fts__ArrayOf_USCOREtns3_USCOREJobStatus::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, this, tag, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC4 soap_get_fts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *fts__ArrayOf_USCOREtns3_USCOREJobStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, this, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC4 soap_in_fts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREJobStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fts__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus, sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fts__ArrayOf_USCOREtns3_USCOREJobStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, "item", &(a->fts__ArrayOf_USCOREtns3_USCOREJobStatus::item), "transfer:JobStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fts__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus, 0, sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus), 0, soap_copy_fts__ArrayOf_USCOREtns3_USCOREJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC4 soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREJobStatus;
		if (size)
			*size = sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus);
		((fts__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREtns3_USCOREJobStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus);
		for (int i = 0; i < n; i++)
			((fts__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (fts__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fts__ArrayOf_USCOREtns3_USCOREJobStatus %p -> %p\n", q, p));
	*(fts__ArrayOf_USCOREtns3_USCOREJobStatus*)p = *(fts__ArrayOf_USCOREtns3_USCOREJobStatus*)q;
}

void fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->fts__ArrayOf_USCOREsoapenc_USCOREstring::item);
	/* transient soap skipped */
}

void fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->fts__ArrayOf_USCOREsoapenc_USCOREstring::item);
	/* transient soap skipped */
}

int fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, int id, const fts__ArrayOf_USCOREsoapenc_USCOREstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "item", -1, &(a->fts__ArrayOf_USCOREsoapenc_USCOREstring::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC4 soap_get_fts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, fts__ArrayOf_USCOREsoapenc_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *fts__ArrayOf_USCOREsoapenc_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC4 soap_in_fts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, fts__ArrayOf_USCOREsoapenc_USCOREstring *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fts__ArrayOf_USCOREsoapenc_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring, sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fts__ArrayOf_USCOREsoapenc_USCOREstring *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "item", &(a->fts__ArrayOf_USCOREsoapenc_USCOREstring::item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fts__ArrayOf_USCOREsoapenc_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring, 0, sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring), 0, soap_copy_fts__ArrayOf_USCOREsoapenc_USCOREstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 fts__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC4 soap_instantiate_fts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__ArrayOf_USCOREsoapenc_USCOREstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREsoapenc_USCOREstring;
		if (size)
			*size = sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring);
		((fts__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new fts__ArrayOf_USCOREsoapenc_USCOREstring[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring);
		for (int i = 0; i < n; i++)
			((fts__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (fts__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fts__ArrayOf_USCOREsoapenc_USCOREstring %p -> %p\n", q, p));
	*(fts__ArrayOf_USCOREsoapenc_USCOREstring*)p = *(fts__ArrayOf_USCOREsoapenc_USCOREstring*)q;
}

void transfer__Roles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__Roles::clientDN = NULL;
	this->transfer__Roles::serviceAdmin = NULL;
	this->transfer__Roles::submitter = NULL;
	soap_default_std__vectorTemplateOfPointerTotransfer__StringPair(soap, &this->transfer__Roles::VOManager);
	/* transient soap skipped */
}

void transfer__Roles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__Roles::clientDN);
	soap_serialize_PointerTostd__string(soap, &this->transfer__Roles::serviceAdmin);
	soap_serialize_PointerTostd__string(soap, &this->transfer__Roles::submitter);
	soap_serialize_std__vectorTemplateOfPointerTotransfer__StringPair(soap, &this->transfer__Roles::VOManager);
	/* transient soap skipped */
}

int transfer__Roles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__Roles);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__Roles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__Roles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__Roles(struct soap *soap, const char *tag, int id, const transfer__Roles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__Roles), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientDN", -1, &(a->transfer__Roles::clientDN), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "serviceAdmin", -1, &(a->transfer__Roles::serviceAdmin), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "submitter", -1, &(a->transfer__Roles::submitter), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__StringPair(soap, "VOManager", -1, &(a->transfer__Roles::VOManager), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__Roles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__Roles(soap, this, tag, type);
}

SOAP_FMAC3 transfer__Roles * SOAP_FMAC4 soap_get_transfer__Roles(struct soap *soap, transfer__Roles *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__Roles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__Roles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__Roles(soap, tag, this, type);
}

SOAP_FMAC3 transfer__Roles * SOAP_FMAC4 soap_in_transfer__Roles(struct soap *soap, const char *tag, transfer__Roles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__Roles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__Roles, sizeof(transfer__Roles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__Roles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__Roles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_clientDN1 = 1;
	size_t soap_flag_serviceAdmin1 = 1;
	size_t soap_flag_submitter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "clientDN", &(a->transfer__Roles::clientDN), "xsd:string"))
				{	soap_flag_clientDN1--;
					continue;
				}
			if (soap_flag_serviceAdmin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "serviceAdmin", &(a->transfer__Roles::serviceAdmin), "xsd:string"))
				{	soap_flag_serviceAdmin1--;
					continue;
				}
			if (soap_flag_submitter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "submitter", &(a->transfer__Roles::submitter), "xsd:string"))
				{	soap_flag_submitter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__StringPair(soap, "VOManager", &(a->transfer__Roles::VOManager), "transfer:StringPair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__Roles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__Roles, 0, sizeof(transfer__Roles), 0, soap_copy_transfer__Roles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__Roles * SOAP_FMAC4 soap_instantiate_transfer__Roles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__Roles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__Roles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__Roles;
		if (size)
			*size = sizeof(transfer__Roles);
		((transfer__Roles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__Roles[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__Roles);
		for (int i = 0; i < n; i++)
			((transfer__Roles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__Roles*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__Roles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__Roles %p -> %p\n", q, p));
	*(transfer__Roles*)p = *(transfer__Roles*)q;
}

void transfer__StringPair::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__StringPair::string1 = NULL;
	this->transfer__StringPair::string2 = NULL;
	/* transient soap skipped */
}

void transfer__StringPair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__StringPair::string1);
	soap_serialize_PointerTostd__string(soap, &this->transfer__StringPair::string2);
	/* transient soap skipped */
}

int transfer__StringPair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__StringPair);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__StringPair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__StringPair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__StringPair(struct soap *soap, const char *tag, int id, const transfer__StringPair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__StringPair), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "string1", -1, &(a->transfer__StringPair::string1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "string2", -1, &(a->transfer__StringPair::string2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__StringPair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__StringPair(soap, this, tag, type);
}

SOAP_FMAC3 transfer__StringPair * SOAP_FMAC4 soap_get_transfer__StringPair(struct soap *soap, transfer__StringPair *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__StringPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__StringPair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__StringPair(soap, tag, this, type);
}

SOAP_FMAC3 transfer__StringPair * SOAP_FMAC4 soap_in_transfer__StringPair(struct soap *soap, const char *tag, transfer__StringPair *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__StringPair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__StringPair, sizeof(transfer__StringPair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__StringPair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__StringPair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_string11 = 1;
	size_t soap_flag_string21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "string1", &(a->transfer__StringPair::string1), "xsd:string"))
				{	soap_flag_string11--;
					continue;
				}
			if (soap_flag_string21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "string2", &(a->transfer__StringPair::string2), "xsd:string"))
				{	soap_flag_string21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__StringPair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__StringPair, 0, sizeof(transfer__StringPair), 0, soap_copy_transfer__StringPair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__StringPair * SOAP_FMAC4 soap_instantiate_transfer__StringPair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__StringPair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__StringPair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__StringPair;
		if (size)
			*size = sizeof(transfer__StringPair);
		((transfer__StringPair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__StringPair[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__StringPair);
		for (int i = 0; i < n; i++)
			((transfer__StringPair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__StringPair*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__StringPair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__StringPair %p -> %p\n", q, p));
	*(transfer__StringPair*)p = *(transfer__StringPair*)q;
}

void transfer__ExistsException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__ExistsException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__ExistsException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__ExistsException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__ExistsException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__ExistsException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__ExistsException(struct soap *soap, const char *tag, int id, const transfer__ExistsException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__ExistsException), "transfer:ExistsException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__ExistsException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__ExistsException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__ExistsException * SOAP_FMAC4 soap_get_transfer__ExistsException(struct soap *soap, transfer__ExistsException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__ExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__ExistsException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__ExistsException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__ExistsException * SOAP_FMAC4 soap_in_transfer__ExistsException(struct soap *soap, const char *tag, transfer__ExistsException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__ExistsException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__ExistsException, sizeof(transfer__ExistsException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__ExistsException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__ExistsException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__ExistsException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__ExistsException, 0, sizeof(transfer__ExistsException), 0, soap_copy_transfer__ExistsException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__ExistsException * SOAP_FMAC4 soap_instantiate_transfer__ExistsException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__ExistsException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__ExistsException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__ExistsException;
		if (size)
			*size = sizeof(transfer__ExistsException);
		((transfer__ExistsException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__ExistsException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__ExistsException);
		for (int i = 0; i < n; i++)
			((transfer__ExistsException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__ExistsException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__ExistsException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__ExistsException %p -> %p\n", q, p));
	*(transfer__ExistsException*)p = *(transfer__ExistsException*)q;
}

void transfer__CannotCancelException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__CannotCancelException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__CannotCancelException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__CannotCancelException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__CannotCancelException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__CannotCancelException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__CannotCancelException(struct soap *soap, const char *tag, int id, const transfer__CannotCancelException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__CannotCancelException), "transfer:CannotCancelException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__CannotCancelException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__CannotCancelException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__CannotCancelException * SOAP_FMAC4 soap_get_transfer__CannotCancelException(struct soap *soap, transfer__CannotCancelException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__CannotCancelException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__CannotCancelException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__CannotCancelException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__CannotCancelException * SOAP_FMAC4 soap_in_transfer__CannotCancelException(struct soap *soap, const char *tag, transfer__CannotCancelException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__CannotCancelException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__CannotCancelException, sizeof(transfer__CannotCancelException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__CannotCancelException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__CannotCancelException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__CannotCancelException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__CannotCancelException, 0, sizeof(transfer__CannotCancelException), 0, soap_copy_transfer__CannotCancelException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__CannotCancelException * SOAP_FMAC4 soap_instantiate_transfer__CannotCancelException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__CannotCancelException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__CannotCancelException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__CannotCancelException;
		if (size)
			*size = sizeof(transfer__CannotCancelException);
		((transfer__CannotCancelException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__CannotCancelException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__CannotCancelException);
		for (int i = 0; i < n; i++)
			((transfer__CannotCancelException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__CannotCancelException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__CannotCancelException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__CannotCancelException %p -> %p\n", q, p));
	*(transfer__CannotCancelException*)p = *(transfer__CannotCancelException*)q;
}

void transfer__TransferJobSummary2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numReady);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numFinishing);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numAwaitingPrestage);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numPrestaging);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numWaitingCatalogRegistration);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numWaitingCatalogResolution);
	soap_default_int(soap, &this->transfer__TransferJobSummary2::numWaitingPrestage);
	this->transfer__TransferJobSummary::jobStatus = NULL;
	soap_default_int(soap, &this->transfer__TransferJobSummary::numDone);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numActive);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numPending);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCanceled);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCanceling);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numFailed);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numFinished);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numSubmitted);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numHold);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numWaiting);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCatalogFailed);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numRestarted);
	/* transient soap skipped */
}

void transfer__TransferJobSummary2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__JobStatus(soap, &this->transfer__TransferJobSummary::jobStatus);
	/* transient soap skipped */
}

int transfer__TransferJobSummary2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJobSummary2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJobSummary2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJobSummary2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJobSummary2(struct soap *soap, const char *tag, int id, const transfer__TransferJobSummary2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJobSummary2), "transfer:TransferJobSummary2"))
		return soap->error;
	if (soap_out_PointerTotransfer__JobStatus(soap, "jobStatus", -1, &(a->transfer__TransferJobSummary::jobStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "numDone", -1, &(a->transfer__TransferJobSummary::numDone), ""))
		return soap->error;
	if (soap_out_int(soap, "numActive", -1, &(a->transfer__TransferJobSummary::numActive), ""))
		return soap->error;
	if (soap_out_int(soap, "numPending", -1, &(a->transfer__TransferJobSummary::numPending), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceled", -1, &(a->transfer__TransferJobSummary::numCanceled), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceling", -1, &(a->transfer__TransferJobSummary::numCanceling), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailed", -1, &(a->transfer__TransferJobSummary::numFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinished", -1, &(a->transfer__TransferJobSummary::numFinished), ""))
		return soap->error;
	if (soap_out_int(soap, "numSubmitted", -1, &(a->transfer__TransferJobSummary::numSubmitted), ""))
		return soap->error;
	if (soap_out_int(soap, "numHold", -1, &(a->transfer__TransferJobSummary::numHold), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaiting", -1, &(a->transfer__TransferJobSummary::numWaiting), ""))
		return soap->error;
	if (soap_out_int(soap, "numCatalogFailed", -1, &(a->transfer__TransferJobSummary::numCatalogFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numRestarted", -1, &(a->transfer__TransferJobSummary::numRestarted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "numReady", -1, &(a->transfer__TransferJobSummary2::numReady), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinishing", -1, &(a->transfer__TransferJobSummary2::numFinishing), ""))
		return soap->error;
	if (soap_out_int(soap, "numAwaitingPrestage", -1, &(a->transfer__TransferJobSummary2::numAwaitingPrestage), ""))
		return soap->error;
	if (soap_out_int(soap, "numPrestaging", -1, &(a->transfer__TransferJobSummary2::numPrestaging), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingCatalogRegistration", -1, &(a->transfer__TransferJobSummary2::numWaitingCatalogRegistration), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingCatalogResolution", -1, &(a->transfer__TransferJobSummary2::numWaitingCatalogResolution), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingPrestage", -1, &(a->transfer__TransferJobSummary2::numWaitingPrestage), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJobSummary2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJobSummary2(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJobSummary2 * SOAP_FMAC4 soap_get_transfer__TransferJobSummary2(struct soap *soap, transfer__TransferJobSummary2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJobSummary2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJobSummary2(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJobSummary2 * SOAP_FMAC4 soap_in_transfer__TransferJobSummary2(struct soap *soap, const char *tag, transfer__TransferJobSummary2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJobSummary2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJobSummary2, sizeof(transfer__TransferJobSummary2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJobSummary2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJobSummary2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobStatus2 = 1;
	size_t soap_flag_numDone2 = 1;
	size_t soap_flag_numActive2 = 1;
	size_t soap_flag_numPending2 = 1;
	size_t soap_flag_numCanceled2 = 1;
	size_t soap_flag_numCanceling2 = 1;
	size_t soap_flag_numFailed2 = 1;
	size_t soap_flag_numFinished2 = 1;
	size_t soap_flag_numSubmitted2 = 1;
	size_t soap_flag_numHold2 = 1;
	size_t soap_flag_numWaiting2 = 1;
	size_t soap_flag_numCatalogFailed2 = 1;
	size_t soap_flag_numRestarted2 = 1;
	size_t soap_flag_numReady1 = 1;
	size_t soap_flag_numFinishing1 = 1;
	size_t soap_flag_numAwaitingPrestage1 = 1;
	size_t soap_flag_numPrestaging1 = 1;
	size_t soap_flag_numWaitingCatalogRegistration1 = 1;
	size_t soap_flag_numWaitingCatalogResolution1 = 1;
	size_t soap_flag_numWaitingPrestage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobStatus2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__JobStatus(soap, "jobStatus", &(a->transfer__TransferJobSummary::jobStatus), "transfer:JobStatus"))
				{	soap_flag_jobStatus2--;
					continue;
				}
			if (soap_flag_numDone2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numDone", &(a->transfer__TransferJobSummary::numDone), "xsd:int"))
				{	soap_flag_numDone2--;
					continue;
				}
			if (soap_flag_numActive2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numActive", &(a->transfer__TransferJobSummary::numActive), "xsd:int"))
				{	soap_flag_numActive2--;
					continue;
				}
			if (soap_flag_numPending2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPending", &(a->transfer__TransferJobSummary::numPending), "xsd:int"))
				{	soap_flag_numPending2--;
					continue;
				}
			if (soap_flag_numCanceled2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceled", &(a->transfer__TransferJobSummary::numCanceled), "xsd:int"))
				{	soap_flag_numCanceled2--;
					continue;
				}
			if (soap_flag_numCanceling2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceling", &(a->transfer__TransferJobSummary::numCanceling), "xsd:int"))
				{	soap_flag_numCanceling2--;
					continue;
				}
			if (soap_flag_numFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailed", &(a->transfer__TransferJobSummary::numFailed), "xsd:int"))
				{	soap_flag_numFailed2--;
					continue;
				}
			if (soap_flag_numFinished2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinished", &(a->transfer__TransferJobSummary::numFinished), "xsd:int"))
				{	soap_flag_numFinished2--;
					continue;
				}
			if (soap_flag_numSubmitted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numSubmitted", &(a->transfer__TransferJobSummary::numSubmitted), "xsd:int"))
				{	soap_flag_numSubmitted2--;
					continue;
				}
			if (soap_flag_numHold2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numHold", &(a->transfer__TransferJobSummary::numHold), "xsd:int"))
				{	soap_flag_numHold2--;
					continue;
				}
			if (soap_flag_numWaiting2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaiting", &(a->transfer__TransferJobSummary::numWaiting), "xsd:int"))
				{	soap_flag_numWaiting2--;
					continue;
				}
			if (soap_flag_numCatalogFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCatalogFailed", &(a->transfer__TransferJobSummary::numCatalogFailed), "xsd:int"))
				{	soap_flag_numCatalogFailed2--;
					continue;
				}
			if (soap_flag_numRestarted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numRestarted", &(a->transfer__TransferJobSummary::numRestarted), "xsd:int"))
				{	soap_flag_numRestarted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_numReady1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numReady", &(a->transfer__TransferJobSummary2::numReady), "xsd:int"))
				{	soap_flag_numReady1--;
					continue;
				}
			if (soap_flag_numFinishing1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinishing", &(a->transfer__TransferJobSummary2::numFinishing), "xsd:int"))
				{	soap_flag_numFinishing1--;
					continue;
				}
			if (soap_flag_numAwaitingPrestage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numAwaitingPrestage", &(a->transfer__TransferJobSummary2::numAwaitingPrestage), "xsd:int"))
				{	soap_flag_numAwaitingPrestage1--;
					continue;
				}
			if (soap_flag_numPrestaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPrestaging", &(a->transfer__TransferJobSummary2::numPrestaging), "xsd:int"))
				{	soap_flag_numPrestaging1--;
					continue;
				}
			if (soap_flag_numWaitingCatalogRegistration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingCatalogRegistration", &(a->transfer__TransferJobSummary2::numWaitingCatalogRegistration), "xsd:int"))
				{	soap_flag_numWaitingCatalogRegistration1--;
					continue;
				}
			if (soap_flag_numWaitingCatalogResolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingCatalogResolution", &(a->transfer__TransferJobSummary2::numWaitingCatalogResolution), "xsd:int"))
				{	soap_flag_numWaitingCatalogResolution1--;
					continue;
				}
			if (soap_flag_numWaitingPrestage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingPrestage", &(a->transfer__TransferJobSummary2::numWaitingPrestage), "xsd:int"))
				{	soap_flag_numWaitingPrestage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJobSummary2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJobSummary2, 0, sizeof(transfer__TransferJobSummary2), 0, soap_copy_transfer__TransferJobSummary2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numDone2 > 0 || soap_flag_numActive2 > 0 || soap_flag_numPending2 > 0 || soap_flag_numCanceled2 > 0 || soap_flag_numCanceling2 > 0 || soap_flag_numFailed2 > 0 || soap_flag_numFinished2 > 0 || soap_flag_numSubmitted2 > 0 || soap_flag_numHold2 > 0 || soap_flag_numWaiting2 > 0 || soap_flag_numCatalogFailed2 > 0 || soap_flag_numRestarted2 > 0 || soap_flag_numReady1 > 0 || soap_flag_numFinishing1 > 0 || soap_flag_numAwaitingPrestage1 > 0 || soap_flag_numPrestaging1 > 0 || soap_flag_numWaitingCatalogRegistration1 > 0 || soap_flag_numWaitingCatalogResolution1 > 0 || soap_flag_numWaitingPrestage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJobSummary2 * SOAP_FMAC4 soap_instantiate_transfer__TransferJobSummary2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJobSummary2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJobSummary2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJobSummary2;
		if (size)
			*size = sizeof(transfer__TransferJobSummary2);
		((transfer__TransferJobSummary2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJobSummary2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJobSummary2);
		for (int i = 0; i < n; i++)
			((transfer__TransferJobSummary2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJobSummary2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJobSummary2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJobSummary2 %p -> %p\n", q, p));
	*(transfer__TransferJobSummary2*)p = *(transfer__TransferJobSummary2*)q;
}

void transfer__TransferJobSummary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferJobSummary::jobStatus = NULL;
	soap_default_int(soap, &this->transfer__TransferJobSummary::numDone);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numActive);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numPending);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCanceled);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCanceling);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numFailed);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numFinished);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numSubmitted);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numHold);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numWaiting);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numCatalogFailed);
	soap_default_int(soap, &this->transfer__TransferJobSummary::numRestarted);
	/* transient soap skipped */
}

void transfer__TransferJobSummary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__JobStatus(soap, &this->transfer__TransferJobSummary::jobStatus);
	/* transient soap skipped */
}

int transfer__TransferJobSummary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJobSummary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJobSummary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJobSummary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJobSummary(struct soap *soap, const char *tag, int id, const transfer__TransferJobSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJobSummary), type))
		return soap->error;
	if (soap_out_PointerTotransfer__JobStatus(soap, "jobStatus", -1, &(a->transfer__TransferJobSummary::jobStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "numDone", -1, &(a->transfer__TransferJobSummary::numDone), ""))
		return soap->error;
	if (soap_out_int(soap, "numActive", -1, &(a->transfer__TransferJobSummary::numActive), ""))
		return soap->error;
	if (soap_out_int(soap, "numPending", -1, &(a->transfer__TransferJobSummary::numPending), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceled", -1, &(a->transfer__TransferJobSummary::numCanceled), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceling", -1, &(a->transfer__TransferJobSummary::numCanceling), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailed", -1, &(a->transfer__TransferJobSummary::numFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinished", -1, &(a->transfer__TransferJobSummary::numFinished), ""))
		return soap->error;
	if (soap_out_int(soap, "numSubmitted", -1, &(a->transfer__TransferJobSummary::numSubmitted), ""))
		return soap->error;
	if (soap_out_int(soap, "numHold", -1, &(a->transfer__TransferJobSummary::numHold), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaiting", -1, &(a->transfer__TransferJobSummary::numWaiting), ""))
		return soap->error;
	if (soap_out_int(soap, "numCatalogFailed", -1, &(a->transfer__TransferJobSummary::numCatalogFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numRestarted", -1, &(a->transfer__TransferJobSummary::numRestarted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJobSummary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJobSummary(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJobSummary * SOAP_FMAC4 soap_get_transfer__TransferJobSummary(struct soap *soap, transfer__TransferJobSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJobSummary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJobSummary(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJobSummary * SOAP_FMAC4 soap_in_transfer__TransferJobSummary(struct soap *soap, const char *tag, transfer__TransferJobSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJobSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJobSummary, sizeof(transfer__TransferJobSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJobSummary)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJobSummary *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobStatus1 = 1;
	size_t soap_flag_numDone1 = 1;
	size_t soap_flag_numActive1 = 1;
	size_t soap_flag_numPending1 = 1;
	size_t soap_flag_numCanceled1 = 1;
	size_t soap_flag_numCanceling1 = 1;
	size_t soap_flag_numFailed1 = 1;
	size_t soap_flag_numFinished1 = 1;
	size_t soap_flag_numSubmitted1 = 1;
	size_t soap_flag_numHold1 = 1;
	size_t soap_flag_numWaiting1 = 1;
	size_t soap_flag_numCatalogFailed1 = 1;
	size_t soap_flag_numRestarted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__JobStatus(soap, "jobStatus", &(a->transfer__TransferJobSummary::jobStatus), "transfer:JobStatus"))
				{	soap_flag_jobStatus1--;
					continue;
				}
			if (soap_flag_numDone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numDone", &(a->transfer__TransferJobSummary::numDone), "xsd:int"))
				{	soap_flag_numDone1--;
					continue;
				}
			if (soap_flag_numActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numActive", &(a->transfer__TransferJobSummary::numActive), "xsd:int"))
				{	soap_flag_numActive1--;
					continue;
				}
			if (soap_flag_numPending1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPending", &(a->transfer__TransferJobSummary::numPending), "xsd:int"))
				{	soap_flag_numPending1--;
					continue;
				}
			if (soap_flag_numCanceled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceled", &(a->transfer__TransferJobSummary::numCanceled), "xsd:int"))
				{	soap_flag_numCanceled1--;
					continue;
				}
			if (soap_flag_numCanceling1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceling", &(a->transfer__TransferJobSummary::numCanceling), "xsd:int"))
				{	soap_flag_numCanceling1--;
					continue;
				}
			if (soap_flag_numFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailed", &(a->transfer__TransferJobSummary::numFailed), "xsd:int"))
				{	soap_flag_numFailed1--;
					continue;
				}
			if (soap_flag_numFinished1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinished", &(a->transfer__TransferJobSummary::numFinished), "xsd:int"))
				{	soap_flag_numFinished1--;
					continue;
				}
			if (soap_flag_numSubmitted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numSubmitted", &(a->transfer__TransferJobSummary::numSubmitted), "xsd:int"))
				{	soap_flag_numSubmitted1--;
					continue;
				}
			if (soap_flag_numHold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numHold", &(a->transfer__TransferJobSummary::numHold), "xsd:int"))
				{	soap_flag_numHold1--;
					continue;
				}
			if (soap_flag_numWaiting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaiting", &(a->transfer__TransferJobSummary::numWaiting), "xsd:int"))
				{	soap_flag_numWaiting1--;
					continue;
				}
			if (soap_flag_numCatalogFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCatalogFailed", &(a->transfer__TransferJobSummary::numCatalogFailed), "xsd:int"))
				{	soap_flag_numCatalogFailed1--;
					continue;
				}
			if (soap_flag_numRestarted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numRestarted", &(a->transfer__TransferJobSummary::numRestarted), "xsd:int"))
				{	soap_flag_numRestarted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJobSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJobSummary, 0, sizeof(transfer__TransferJobSummary), 0, soap_copy_transfer__TransferJobSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numDone1 > 0 || soap_flag_numActive1 > 0 || soap_flag_numPending1 > 0 || soap_flag_numCanceled1 > 0 || soap_flag_numCanceling1 > 0 || soap_flag_numFailed1 > 0 || soap_flag_numFinished1 > 0 || soap_flag_numSubmitted1 > 0 || soap_flag_numHold1 > 0 || soap_flag_numWaiting1 > 0 || soap_flag_numCatalogFailed1 > 0 || soap_flag_numRestarted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJobSummary * SOAP_FMAC4 soap_instantiate_transfer__TransferJobSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJobSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJobSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "transfer:TransferJobSummary2"))
	{	cp->type = SOAP_TYPE_transfer__TransferJobSummary2;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__TransferJobSummary2;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__TransferJobSummary2);
			((transfer__TransferJobSummary2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__TransferJobSummary2[n];
			if (size)
				*size = n * sizeof(transfer__TransferJobSummary2);
			for (int i = 0; i < n; i++)
				((transfer__TransferJobSummary2*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__TransferJobSummary2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJobSummary;
		if (size)
			*size = sizeof(transfer__TransferJobSummary);
		((transfer__TransferJobSummary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJobSummary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJobSummary);
		for (int i = 0; i < n; i++)
			((transfer__TransferJobSummary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJobSummary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJobSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJobSummary %p -> %p\n", q, p));
	*(transfer__TransferJobSummary*)p = *(transfer__TransferJobSummary*)q;
}

void transfer__FileTransferStatus2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__FileTransferStatus2::error_USCOREscope = NULL;
	this->transfer__FileTransferStatus2::error_USCOREphase = NULL;
	this->transfer__FileTransferStatus::logicalName = NULL;
	this->transfer__FileTransferStatus::sourceSURL = NULL;
	this->transfer__FileTransferStatus::destSURL = NULL;
	this->transfer__FileTransferStatus::transferFileState = NULL;
	soap_default_int(soap, &this->transfer__FileTransferStatus::numFailures);
	this->transfer__FileTransferStatus::reason = NULL;
	this->transfer__FileTransferStatus::reason_USCOREclass = NULL;
	soap_default_LONG64(soap, &this->transfer__FileTransferStatus::duration);
	/* transient soap skipped */
}

void transfer__FileTransferStatus2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus2::error_USCOREscope);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus2::error_USCOREphase);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::logicalName);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::sourceSURL);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::destSURL);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::transferFileState);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::reason_USCOREclass);
	/* transient soap skipped */
}

int transfer__FileTransferStatus2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__FileTransferStatus2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__FileTransferStatus2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__FileTransferStatus2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__FileTransferStatus2(struct soap *soap, const char *tag, int id, const transfer__FileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__FileTransferStatus2), "transfer:FileTransferStatus2"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "logicalName", -1, &(a->transfer__FileTransferStatus::logicalName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSURL", -1, &(a->transfer__FileTransferStatus::sourceSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSURL", -1, &(a->transfer__FileTransferStatus::destSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "transferFileState", -1, &(a->transfer__FileTransferStatus::transferFileState), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailures", -1, &(a->transfer__FileTransferStatus::numFailures), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->transfer__FileTransferStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason_class", -1, &(a->transfer__FileTransferStatus::reason_USCOREclass), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "duration", -1, &(a->transfer__FileTransferStatus::duration), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "error_scope", -1, &(a->transfer__FileTransferStatus2::error_USCOREscope), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "error_phase", -1, &(a->transfer__FileTransferStatus2::error_USCOREphase), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *transfer__FileTransferStatus2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__FileTransferStatus2(soap, this, tag, type);
}

SOAP_FMAC3 transfer__FileTransferStatus2 * SOAP_FMAC4 soap_get_transfer__FileTransferStatus2(struct soap *soap, transfer__FileTransferStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__FileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__FileTransferStatus2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__FileTransferStatus2(soap, tag, this, type);
}

SOAP_FMAC3 transfer__FileTransferStatus2 * SOAP_FMAC4 soap_in_transfer__FileTransferStatus2(struct soap *soap, const char *tag, transfer__FileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__FileTransferStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__FileTransferStatus2, sizeof(transfer__FileTransferStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__FileTransferStatus2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__FileTransferStatus2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_logicalName2 = 1;
	size_t soap_flag_sourceSURL2 = 1;
	size_t soap_flag_destSURL2 = 1;
	size_t soap_flag_transferFileState2 = 1;
	size_t soap_flag_numFailures2 = 1;
	size_t soap_flag_reason2 = 1;
	size_t soap_flag_reason_USCOREclass2 = 1;
	size_t soap_flag_duration2 = 1;
	size_t soap_flag_error_USCOREscope1 = 1;
	size_t soap_flag_error_USCOREphase1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logicalName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "logicalName", &(a->transfer__FileTransferStatus::logicalName), "xsd:string"))
				{	soap_flag_logicalName2--;
					continue;
				}
			if (soap_flag_sourceSURL2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSURL", &(a->transfer__FileTransferStatus::sourceSURL), "xsd:string"))
				{	soap_flag_sourceSURL2--;
					continue;
				}
			if (soap_flag_destSURL2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSURL", &(a->transfer__FileTransferStatus::destSURL), "xsd:string"))
				{	soap_flag_destSURL2--;
					continue;
				}
			if (soap_flag_transferFileState2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "transferFileState", &(a->transfer__FileTransferStatus::transferFileState), "xsd:string"))
				{	soap_flag_transferFileState2--;
					continue;
				}
			if (soap_flag_numFailures2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailures", &(a->transfer__FileTransferStatus::numFailures), "xsd:int"))
				{	soap_flag_numFailures2--;
					continue;
				}
			if (soap_flag_reason2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->transfer__FileTransferStatus::reason), "xsd:string"))
				{	soap_flag_reason2--;
					continue;
				}
			if (soap_flag_reason_USCOREclass2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason_class", &(a->transfer__FileTransferStatus::reason_USCOREclass), "xsd:string"))
				{	soap_flag_reason_USCOREclass2--;
					continue;
				}
			if (soap_flag_duration2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "duration", &(a->transfer__FileTransferStatus::duration), "xsd:long"))
				{	soap_flag_duration2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_error_USCOREscope1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error_scope", &(a->transfer__FileTransferStatus2::error_USCOREscope), "xsd:string"))
				{	soap_flag_error_USCOREscope1--;
					continue;
				}
			if (soap_flag_error_USCOREphase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error_phase", &(a->transfer__FileTransferStatus2::error_USCOREphase), "xsd:string"))
				{	soap_flag_error_USCOREphase1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__FileTransferStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__FileTransferStatus2, 0, sizeof(transfer__FileTransferStatus2), 0, soap_copy_transfer__FileTransferStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numFailures2 > 0 || soap_flag_duration2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__FileTransferStatus2 * SOAP_FMAC4 soap_instantiate_transfer__FileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__FileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__FileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__FileTransferStatus2;
		if (size)
			*size = sizeof(transfer__FileTransferStatus2);
		((transfer__FileTransferStatus2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__FileTransferStatus2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__FileTransferStatus2);
		for (int i = 0; i < n; i++)
			((transfer__FileTransferStatus2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__FileTransferStatus2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__FileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__FileTransferStatus2 %p -> %p\n", q, p));
	*(transfer__FileTransferStatus2*)p = *(transfer__FileTransferStatus2*)q;
}

void transfer__NotExistsException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__NotExistsException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__NotExistsException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__NotExistsException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__NotExistsException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__NotExistsException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__NotExistsException(struct soap *soap, const char *tag, int id, const transfer__NotExistsException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__NotExistsException), "transfer:NotExistsException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__NotExistsException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__NotExistsException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__NotExistsException * SOAP_FMAC4 soap_get_transfer__NotExistsException(struct soap *soap, transfer__NotExistsException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__NotExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__NotExistsException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__NotExistsException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__NotExistsException * SOAP_FMAC4 soap_in_transfer__NotExistsException(struct soap *soap, const char *tag, transfer__NotExistsException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__NotExistsException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__NotExistsException, sizeof(transfer__NotExistsException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__NotExistsException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__NotExistsException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__NotExistsException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__NotExistsException, 0, sizeof(transfer__NotExistsException), 0, soap_copy_transfer__NotExistsException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__NotExistsException * SOAP_FMAC4 soap_instantiate_transfer__NotExistsException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__NotExistsException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__NotExistsException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__NotExistsException;
		if (size)
			*size = sizeof(transfer__NotExistsException);
		((transfer__NotExistsException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__NotExistsException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__NotExistsException);
		for (int i = 0; i < n; i++)
			((transfer__NotExistsException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__NotExistsException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__NotExistsException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__NotExistsException %p -> %p\n", q, p));
	*(transfer__NotExistsException*)p = *(transfer__NotExistsException*)q;
}

void transfer__FileTransferStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__FileTransferStatus::logicalName = NULL;
	this->transfer__FileTransferStatus::sourceSURL = NULL;
	this->transfer__FileTransferStatus::destSURL = NULL;
	this->transfer__FileTransferStatus::transferFileState = NULL;
	soap_default_int(soap, &this->transfer__FileTransferStatus::numFailures);
	this->transfer__FileTransferStatus::reason = NULL;
	this->transfer__FileTransferStatus::reason_USCOREclass = NULL;
	soap_default_LONG64(soap, &this->transfer__FileTransferStatus::duration);
	/* transient soap skipped */
}

void transfer__FileTransferStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::logicalName);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::sourceSURL);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::destSURL);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::transferFileState);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->transfer__FileTransferStatus::reason_USCOREclass);
	/* transient soap skipped */
}

int transfer__FileTransferStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__FileTransferStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__FileTransferStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__FileTransferStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__FileTransferStatus(struct soap *soap, const char *tag, int id, const transfer__FileTransferStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__FileTransferStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "logicalName", -1, &(a->transfer__FileTransferStatus::logicalName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSURL", -1, &(a->transfer__FileTransferStatus::sourceSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSURL", -1, &(a->transfer__FileTransferStatus::destSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "transferFileState", -1, &(a->transfer__FileTransferStatus::transferFileState), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailures", -1, &(a->transfer__FileTransferStatus::numFailures), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->transfer__FileTransferStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason_class", -1, &(a->transfer__FileTransferStatus::reason_USCOREclass), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "duration", -1, &(a->transfer__FileTransferStatus::duration), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__FileTransferStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__FileTransferStatus(soap, this, tag, type);
}

SOAP_FMAC3 transfer__FileTransferStatus * SOAP_FMAC4 soap_get_transfer__FileTransferStatus(struct soap *soap, transfer__FileTransferStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__FileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__FileTransferStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__FileTransferStatus(soap, tag, this, type);
}

SOAP_FMAC3 transfer__FileTransferStatus * SOAP_FMAC4 soap_in_transfer__FileTransferStatus(struct soap *soap, const char *tag, transfer__FileTransferStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__FileTransferStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__FileTransferStatus, sizeof(transfer__FileTransferStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__FileTransferStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__FileTransferStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_logicalName1 = 1;
	size_t soap_flag_sourceSURL1 = 1;
	size_t soap_flag_destSURL1 = 1;
	size_t soap_flag_transferFileState1 = 1;
	size_t soap_flag_numFailures1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_reason_USCOREclass1 = 1;
	size_t soap_flag_duration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logicalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "logicalName", &(a->transfer__FileTransferStatus::logicalName), "xsd:string"))
				{	soap_flag_logicalName1--;
					continue;
				}
			if (soap_flag_sourceSURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSURL", &(a->transfer__FileTransferStatus::sourceSURL), "xsd:string"))
				{	soap_flag_sourceSURL1--;
					continue;
				}
			if (soap_flag_destSURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSURL", &(a->transfer__FileTransferStatus::destSURL), "xsd:string"))
				{	soap_flag_destSURL1--;
					continue;
				}
			if (soap_flag_transferFileState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "transferFileState", &(a->transfer__FileTransferStatus::transferFileState), "xsd:string"))
				{	soap_flag_transferFileState1--;
					continue;
				}
			if (soap_flag_numFailures1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailures", &(a->transfer__FileTransferStatus::numFailures), "xsd:int"))
				{	soap_flag_numFailures1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->transfer__FileTransferStatus::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_reason_USCOREclass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason_class", &(a->transfer__FileTransferStatus::reason_USCOREclass), "xsd:string"))
				{	soap_flag_reason_USCOREclass1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "duration", &(a->transfer__FileTransferStatus::duration), "xsd:long"))
				{	soap_flag_duration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__FileTransferStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__FileTransferStatus, 0, sizeof(transfer__FileTransferStatus), 0, soap_copy_transfer__FileTransferStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numFailures1 > 0 || soap_flag_duration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__FileTransferStatus * SOAP_FMAC4 soap_instantiate_transfer__FileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__FileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__FileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "transfer:FileTransferStatus2"))
	{	cp->type = SOAP_TYPE_transfer__FileTransferStatus2;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__FileTransferStatus2;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__FileTransferStatus2);
			((transfer__FileTransferStatus2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__FileTransferStatus2[n];
			if (size)
				*size = n * sizeof(transfer__FileTransferStatus2);
			for (int i = 0; i < n; i++)
				((transfer__FileTransferStatus2*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__FileTransferStatus2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new transfer__FileTransferStatus;
		if (size)
			*size = sizeof(transfer__FileTransferStatus);
		((transfer__FileTransferStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__FileTransferStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__FileTransferStatus);
		for (int i = 0; i < n; i++)
			((transfer__FileTransferStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__FileTransferStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__FileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__FileTransferStatus %p -> %p\n", q, p));
	*(transfer__FileTransferStatus*)p = *(transfer__FileTransferStatus*)q;
}

void transfer__JobStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__JobStatus::jobID = NULL;
	this->transfer__JobStatus::jobStatus = NULL;
	this->transfer__JobStatus::clientDN = NULL;
	this->transfer__JobStatus::reason = NULL;
	this->transfer__JobStatus::voName = NULL;
	soap_default_LONG64(soap, &this->transfer__JobStatus::submitTime);
	soap_default_int(soap, &this->transfer__JobStatus::numFiles);
	soap_default_int(soap, &this->transfer__JobStatus::priority);
	/* transient soap skipped */
}

void transfer__JobStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__JobStatus::jobID);
	soap_serialize_PointerTostd__string(soap, &this->transfer__JobStatus::jobStatus);
	soap_serialize_PointerTostd__string(soap, &this->transfer__JobStatus::clientDN);
	soap_serialize_PointerTostd__string(soap, &this->transfer__JobStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->transfer__JobStatus::voName);
	/* transient soap skipped */
}

int transfer__JobStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__JobStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__JobStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__JobStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__JobStatus(struct soap *soap, const char *tag, int id, const transfer__JobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__JobStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jobID", -1, &(a->transfer__JobStatus::jobID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jobStatus", -1, &(a->transfer__JobStatus::jobStatus), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientDN", -1, &(a->transfer__JobStatus::clientDN), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->transfer__JobStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "voName", -1, &(a->transfer__JobStatus::voName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "submitTime", -1, &(a->transfer__JobStatus::submitTime), ""))
		return soap->error;
	if (soap_out_int(soap, "numFiles", -1, &(a->transfer__JobStatus::numFiles), ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &(a->transfer__JobStatus::priority), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__JobStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__JobStatus(soap, this, tag, type);
}

SOAP_FMAC3 transfer__JobStatus * SOAP_FMAC4 soap_get_transfer__JobStatus(struct soap *soap, transfer__JobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__JobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__JobStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__JobStatus(soap, tag, this, type);
}

SOAP_FMAC3 transfer__JobStatus * SOAP_FMAC4 soap_in_transfer__JobStatus(struct soap *soap, const char *tag, transfer__JobStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__JobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__JobStatus, sizeof(transfer__JobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__JobStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__JobStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_jobStatus1 = 1;
	size_t soap_flag_clientDN1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_voName1 = 1;
	size_t soap_flag_submitTime1 = 1;
	size_t soap_flag_numFiles1 = 1;
	size_t soap_flag_priority1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jobID", &(a->transfer__JobStatus::jobID), "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_jobStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jobStatus", &(a->transfer__JobStatus::jobStatus), "xsd:string"))
				{	soap_flag_jobStatus1--;
					continue;
				}
			if (soap_flag_clientDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "clientDN", &(a->transfer__JobStatus::clientDN), "xsd:string"))
				{	soap_flag_clientDN1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->transfer__JobStatus::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_voName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "voName", &(a->transfer__JobStatus::voName), "xsd:string"))
				{	soap_flag_voName1--;
					continue;
				}
			if (soap_flag_submitTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "submitTime", &(a->transfer__JobStatus::submitTime), "xsd:long"))
				{	soap_flag_submitTime1--;
					continue;
				}
			if (soap_flag_numFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFiles", &(a->transfer__JobStatus::numFiles), "xsd:int"))
				{	soap_flag_numFiles1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "priority", &(a->transfer__JobStatus::priority), "xsd:int"))
				{	soap_flag_priority1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__JobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__JobStatus, 0, sizeof(transfer__JobStatus), 0, soap_copy_transfer__JobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_submitTime1 > 0 || soap_flag_numFiles1 > 0 || soap_flag_priority1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__JobStatus * SOAP_FMAC4 soap_instantiate_transfer__JobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__JobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__JobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__JobStatus;
		if (size)
			*size = sizeof(transfer__JobStatus);
		((transfer__JobStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__JobStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__JobStatus);
		for (int i = 0; i < n; i++)
			((transfer__JobStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__JobStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__JobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__JobStatus %p -> %p\n", q, p));
	*(transfer__JobStatus*)p = *(transfer__JobStatus*)q;
}

void transfer__TransferJob2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, &this->transfer__TransferJob2::transferJobElements);
	this->transfer__TransferJob2::jobParams = NULL;
	this->transfer__TransferJob2::credential = NULL;
	/* transient soap skipped */
}

void transfer__TransferJob2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, &this->transfer__TransferJob2::transferJobElements);
	soap_serialize_PointerTotransfer__TransferParams(soap, &this->transfer__TransferJob2::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJob2::credential);
	/* transient soap skipped */
}

int transfer__TransferJob2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJob2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJob2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJob2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJob2(struct soap *soap, const char *tag, int id, const transfer__TransferJob2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJob2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, "transferJobElements", -1, &(a->transfer__TransferJob2::transferJobElements), ""))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferParams(soap, "jobParams", -1, &(a->transfer__TransferJob2::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->transfer__TransferJob2::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJob2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJob2(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJob2 * SOAP_FMAC4 soap_get_transfer__TransferJob2(struct soap *soap, transfer__TransferJob2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJob2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJob2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJob2(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJob2 * SOAP_FMAC4 soap_in_transfer__TransferJob2(struct soap *soap, const char *tag, transfer__TransferJob2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJob2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJob2, sizeof(transfer__TransferJob2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJob2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJob2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, "transferJobElements", &(a->transfer__TransferJob2::transferJobElements), "transfer:TransferJobElement2"))
					continue;
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferParams(soap, "jobParams", &(a->transfer__TransferJob2::jobParams), "transfer:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->transfer__TransferJob2::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJob2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJob2, 0, sizeof(transfer__TransferJob2), 0, soap_copy_transfer__TransferJob2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJob2 * SOAP_FMAC4 soap_instantiate_transfer__TransferJob2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJob2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJob2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJob2;
		if (size)
			*size = sizeof(transfer__TransferJob2);
		((transfer__TransferJob2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJob2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJob2);
		for (int i = 0; i < n; i++)
			((transfer__TransferJob2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJob2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJob2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJob2 %p -> %p\n", q, p));
	*(transfer__TransferJob2*)p = *(transfer__TransferJob2*)q;
}

void transfer__TransferJobElement2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferJobElement2::source = NULL;
	this->transfer__TransferJobElement2::dest = NULL;
	this->transfer__TransferJobElement2::checksum = NULL;
	/* transient soap skipped */
}

void transfer__TransferJobElement2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJobElement2::source);
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJobElement2::dest);
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJobElement2::checksum);
	/* transient soap skipped */
}

int transfer__TransferJobElement2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJobElement2);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJobElement2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJobElement2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJobElement2(struct soap *soap, const char *tag, int id, const transfer__TransferJobElement2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJobElement2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "source", -1, &(a->transfer__TransferJobElement2::source), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dest", -1, &(a->transfer__TransferJobElement2::dest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "checksum", -1, &(a->transfer__TransferJobElement2::checksum), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJobElement2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJobElement2(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJobElement2 * SOAP_FMAC4 soap_get_transfer__TransferJobElement2(struct soap *soap, transfer__TransferJobElement2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJobElement2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJobElement2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJobElement2(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJobElement2 * SOAP_FMAC4 soap_in_transfer__TransferJobElement2(struct soap *soap, const char *tag, transfer__TransferJobElement2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJobElement2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJobElement2, sizeof(transfer__TransferJobElement2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJobElement2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJobElement2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_dest1 = 1;
	size_t soap_flag_checksum1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "source", &(a->transfer__TransferJobElement2::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_dest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "dest", &(a->transfer__TransferJobElement2::dest), "xsd:string"))
				{	soap_flag_dest1--;
					continue;
				}
			if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "checksum", &(a->transfer__TransferJobElement2::checksum), "xsd:string"))
				{	soap_flag_checksum1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJobElement2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJobElement2, 0, sizeof(transfer__TransferJobElement2), 0, soap_copy_transfer__TransferJobElement2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJobElement2 * SOAP_FMAC4 soap_instantiate_transfer__TransferJobElement2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJobElement2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJobElement2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJobElement2;
		if (size)
			*size = sizeof(transfer__TransferJobElement2);
		((transfer__TransferJobElement2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJobElement2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJobElement2);
		for (int i = 0; i < n; i++)
			((transfer__TransferJobElement2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJobElement2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJobElement2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJobElement2 %p -> %p\n", q, p));
	*(transfer__TransferJobElement2*)p = *(transfer__TransferJobElement2*)q;
}

void transfer__TransferJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, &this->transfer__TransferJob::transferJobElements);
	this->transfer__TransferJob::jobParams = NULL;
	this->transfer__TransferJob::credential = NULL;
	/* transient soap skipped */
}

void transfer__TransferJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, &this->transfer__TransferJob::transferJobElements);
	soap_serialize_PointerTotransfer__TransferParams(soap, &this->transfer__TransferJob::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJob::credential);
	/* transient soap skipped */
}

int transfer__TransferJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJob);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJob(struct soap *soap, const char *tag, int id, const transfer__TransferJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, "transferJobElements", -1, &(a->transfer__TransferJob::transferJobElements), ""))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferParams(soap, "jobParams", -1, &(a->transfer__TransferJob::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->transfer__TransferJob::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJob(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJob * SOAP_FMAC4 soap_get_transfer__TransferJob(struct soap *soap, transfer__TransferJob *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJob(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJob * SOAP_FMAC4 soap_in_transfer__TransferJob(struct soap *soap, const char *tag, transfer__TransferJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJob, sizeof(transfer__TransferJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, "transferJobElements", &(a->transfer__TransferJob::transferJobElements), "transfer:TransferJobElement"))
					continue;
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferParams(soap, "jobParams", &(a->transfer__TransferJob::jobParams), "transfer:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->transfer__TransferJob::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJob, 0, sizeof(transfer__TransferJob), 0, soap_copy_transfer__TransferJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJob * SOAP_FMAC4 soap_instantiate_transfer__TransferJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJob;
		if (size)
			*size = sizeof(transfer__TransferJob);
		((transfer__TransferJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJob);
		for (int i = 0; i < n; i++)
			((transfer__TransferJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJob %p -> %p\n", q, p));
	*(transfer__TransferJob*)p = *(transfer__TransferJob*)q;
}

void transfer__TransferJobElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferJobElement::source = NULL;
	this->transfer__TransferJobElement::dest = NULL;
	/* transient soap skipped */
}

void transfer__TransferJobElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJobElement::source);
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferJobElement::dest);
	/* transient soap skipped */
}

int transfer__TransferJobElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferJobElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferJobElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferJobElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferJobElement(struct soap *soap, const char *tag, int id, const transfer__TransferJobElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferJobElement), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "source", -1, &(a->transfer__TransferJobElement::source), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dest", -1, &(a->transfer__TransferJobElement::dest), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferJobElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferJobElement(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferJobElement * SOAP_FMAC4 soap_get_transfer__TransferJobElement(struct soap *soap, transfer__TransferJobElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferJobElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferJobElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferJobElement(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferJobElement * SOAP_FMAC4 soap_in_transfer__TransferJobElement(struct soap *soap, const char *tag, transfer__TransferJobElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferJobElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferJobElement, sizeof(transfer__TransferJobElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferJobElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferJobElement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_dest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "source", &(a->transfer__TransferJobElement::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_dest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "dest", &(a->transfer__TransferJobElement::dest), "xsd:string"))
				{	soap_flag_dest1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferJobElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferJobElement, 0, sizeof(transfer__TransferJobElement), 0, soap_copy_transfer__TransferJobElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferJobElement * SOAP_FMAC4 soap_instantiate_transfer__TransferJobElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferJobElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferJobElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferJobElement;
		if (size)
			*size = sizeof(transfer__TransferJobElement);
		((transfer__TransferJobElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferJobElement[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferJobElement);
		for (int i = 0; i < n; i++)
			((transfer__TransferJobElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferJobElement*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferJobElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferJobElement %p -> %p\n", q, p));
	*(transfer__TransferJobElement*)p = *(transfer__TransferJobElement*)q;
}

void transfer__InternalException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__InternalException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__InternalException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__InternalException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__InternalException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__InternalException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__InternalException(struct soap *soap, const char *tag, int id, const transfer__InternalException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__InternalException), "transfer:InternalException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__InternalException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__InternalException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__InternalException * SOAP_FMAC4 soap_get_transfer__InternalException(struct soap *soap, transfer__InternalException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__InternalException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__InternalException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__InternalException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__InternalException * SOAP_FMAC4 soap_in_transfer__InternalException(struct soap *soap, const char *tag, transfer__InternalException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__InternalException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__InternalException, sizeof(transfer__InternalException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__InternalException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__InternalException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__InternalException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__InternalException, 0, sizeof(transfer__InternalException), 0, soap_copy_transfer__InternalException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__InternalException * SOAP_FMAC4 soap_instantiate_transfer__InternalException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__InternalException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__InternalException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__InternalException;
		if (size)
			*size = sizeof(transfer__InternalException);
		((transfer__InternalException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__InternalException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__InternalException);
		for (int i = 0; i < n; i++)
			((transfer__InternalException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__InternalException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__InternalException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__InternalException %p -> %p\n", q, p));
	*(transfer__InternalException*)p = *(transfer__InternalException*)q;
}

void transfer__ServiceBusyException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__ServiceBusyException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__ServiceBusyException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__ServiceBusyException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__ServiceBusyException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__ServiceBusyException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__ServiceBusyException(struct soap *soap, const char *tag, int id, const transfer__ServiceBusyException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__ServiceBusyException), "transfer:ServiceBusyException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__ServiceBusyException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__ServiceBusyException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__ServiceBusyException * SOAP_FMAC4 soap_get_transfer__ServiceBusyException(struct soap *soap, transfer__ServiceBusyException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__ServiceBusyException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__ServiceBusyException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__ServiceBusyException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__ServiceBusyException * SOAP_FMAC4 soap_in_transfer__ServiceBusyException(struct soap *soap, const char *tag, transfer__ServiceBusyException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__ServiceBusyException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__ServiceBusyException, sizeof(transfer__ServiceBusyException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__ServiceBusyException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__ServiceBusyException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__ServiceBusyException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__ServiceBusyException, 0, sizeof(transfer__ServiceBusyException), 0, soap_copy_transfer__ServiceBusyException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__ServiceBusyException * SOAP_FMAC4 soap_instantiate_transfer__ServiceBusyException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__ServiceBusyException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__ServiceBusyException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__ServiceBusyException;
		if (size)
			*size = sizeof(transfer__ServiceBusyException);
		((transfer__ServiceBusyException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__ServiceBusyException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__ServiceBusyException);
		for (int i = 0; i < n; i++)
			((transfer__ServiceBusyException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__ServiceBusyException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__ServiceBusyException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__ServiceBusyException %p -> %p\n", q, p));
	*(transfer__ServiceBusyException*)p = *(transfer__ServiceBusyException*)q;
}

void transfer__AuthorizationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__AuthorizationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__AuthorizationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__AuthorizationException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__AuthorizationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__AuthorizationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__AuthorizationException(struct soap *soap, const char *tag, int id, const transfer__AuthorizationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__AuthorizationException), "transfer:AuthorizationException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__AuthorizationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__AuthorizationException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__AuthorizationException * SOAP_FMAC4 soap_get_transfer__AuthorizationException(struct soap *soap, transfer__AuthorizationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__AuthorizationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__AuthorizationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__AuthorizationException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__AuthorizationException * SOAP_FMAC4 soap_in_transfer__AuthorizationException(struct soap *soap, const char *tag, transfer__AuthorizationException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__AuthorizationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__AuthorizationException, sizeof(transfer__AuthorizationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__AuthorizationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__AuthorizationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__AuthorizationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__AuthorizationException, 0, sizeof(transfer__AuthorizationException), 0, soap_copy_transfer__AuthorizationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__AuthorizationException * SOAP_FMAC4 soap_instantiate_transfer__AuthorizationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__AuthorizationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__AuthorizationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__AuthorizationException;
		if (size)
			*size = sizeof(transfer__AuthorizationException);
		((transfer__AuthorizationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__AuthorizationException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__AuthorizationException);
		for (int i = 0; i < n; i++)
			((transfer__AuthorizationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__AuthorizationException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__AuthorizationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__AuthorizationException %p -> %p\n", q, p));
	*(transfer__AuthorizationException*)p = *(transfer__AuthorizationException*)q;
}

void transfer__InvalidArgumentException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__InvalidArgumentException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__InvalidArgumentException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__InvalidArgumentException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__InvalidArgumentException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__InvalidArgumentException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__InvalidArgumentException(struct soap *soap, const char *tag, int id, const transfer__InvalidArgumentException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__InvalidArgumentException), "transfer:InvalidArgumentException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__InvalidArgumentException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__InvalidArgumentException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__InvalidArgumentException * SOAP_FMAC4 soap_get_transfer__InvalidArgumentException(struct soap *soap, transfer__InvalidArgumentException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__InvalidArgumentException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__InvalidArgumentException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__InvalidArgumentException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__InvalidArgumentException * SOAP_FMAC4 soap_in_transfer__InvalidArgumentException(struct soap *soap, const char *tag, transfer__InvalidArgumentException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__InvalidArgumentException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__InvalidArgumentException, sizeof(transfer__InvalidArgumentException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__InvalidArgumentException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__InvalidArgumentException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__InvalidArgumentException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__InvalidArgumentException, 0, sizeof(transfer__InvalidArgumentException), 0, soap_copy_transfer__InvalidArgumentException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__InvalidArgumentException * SOAP_FMAC4 soap_instantiate_transfer__InvalidArgumentException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__InvalidArgumentException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__InvalidArgumentException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__InvalidArgumentException;
		if (size)
			*size = sizeof(transfer__InvalidArgumentException);
		((transfer__InvalidArgumentException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__InvalidArgumentException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__InvalidArgumentException);
		for (int i = 0; i < n; i++)
			((transfer__InvalidArgumentException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__InvalidArgumentException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__InvalidArgumentException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__InvalidArgumentException %p -> %p\n", q, p));
	*(transfer__InvalidArgumentException*)p = *(transfer__InvalidArgumentException*)q;
}

void transfer__TransferException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->transfer__TransferException::message = NULL;
	/* transient soap skipped */
}

void transfer__TransferException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->transfer__TransferException::message);
	/* transient soap skipped */
}

int transfer__TransferException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferException(struct soap *soap, const char *tag, int id, const transfer__TransferException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->transfer__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferException(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferException * SOAP_FMAC4 soap_get_transfer__TransferException(struct soap *soap, transfer__TransferException *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferException(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferException * SOAP_FMAC4 soap_in_transfer__TransferException(struct soap *soap, const char *tag, transfer__TransferException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferException, sizeof(transfer__TransferException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->transfer__TransferException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferException, 0, sizeof(transfer__TransferException), 0, soap_copy_transfer__TransferException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferException * SOAP_FMAC4 soap_instantiate_transfer__TransferException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "transfer:InvalidArgumentException"))
	{	cp->type = SOAP_TYPE_transfer__InvalidArgumentException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__InvalidArgumentException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__InvalidArgumentException);
			((transfer__InvalidArgumentException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__InvalidArgumentException[n];
			if (size)
				*size = n * sizeof(transfer__InvalidArgumentException);
			for (int i = 0; i < n; i++)
				((transfer__InvalidArgumentException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__InvalidArgumentException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:AuthorizationException"))
	{	cp->type = SOAP_TYPE_transfer__AuthorizationException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__AuthorizationException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__AuthorizationException);
			((transfer__AuthorizationException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__AuthorizationException[n];
			if (size)
				*size = n * sizeof(transfer__AuthorizationException);
			for (int i = 0; i < n; i++)
				((transfer__AuthorizationException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__AuthorizationException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:ServiceBusyException"))
	{	cp->type = SOAP_TYPE_transfer__ServiceBusyException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__ServiceBusyException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__ServiceBusyException);
			((transfer__ServiceBusyException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__ServiceBusyException[n];
			if (size)
				*size = n * sizeof(transfer__ServiceBusyException);
			for (int i = 0; i < n; i++)
				((transfer__ServiceBusyException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__ServiceBusyException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:InternalException"))
	{	cp->type = SOAP_TYPE_transfer__InternalException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__InternalException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__InternalException);
			((transfer__InternalException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__InternalException[n];
			if (size)
				*size = n * sizeof(transfer__InternalException);
			for (int i = 0; i < n; i++)
				((transfer__InternalException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__InternalException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:NotExistsException"))
	{	cp->type = SOAP_TYPE_transfer__NotExistsException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__NotExistsException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__NotExistsException);
			((transfer__NotExistsException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__NotExistsException[n];
			if (size)
				*size = n * sizeof(transfer__NotExistsException);
			for (int i = 0; i < n; i++)
				((transfer__NotExistsException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__NotExistsException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:CannotCancelException"))
	{	cp->type = SOAP_TYPE_transfer__CannotCancelException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__CannotCancelException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__CannotCancelException);
			((transfer__CannotCancelException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__CannotCancelException[n];
			if (size)
				*size = n * sizeof(transfer__CannotCancelException);
			for (int i = 0; i < n; i++)
				((transfer__CannotCancelException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__CannotCancelException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "transfer:ExistsException"))
	{	cp->type = SOAP_TYPE_transfer__ExistsException;
		if (n < 0)
		{	cp->ptr = (void*)new transfer__ExistsException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(transfer__ExistsException);
			((transfer__ExistsException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new transfer__ExistsException[n];
			if (size)
				*size = n * sizeof(transfer__ExistsException);
			for (int i = 0; i < n; i++)
				((transfer__ExistsException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (transfer__ExistsException*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferException;
		if (size)
			*size = sizeof(transfer__TransferException);
		((transfer__TransferException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferException);
		for (int i = 0; i < n; i++)
			((transfer__TransferException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferException %p -> %p\n", q, p));
	*(transfer__TransferException*)p = *(transfer__TransferException*)q;
}

void transfer__PlacementJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->transfer__PlacementJob::logicalFiles);
	this->transfer__PlacementJob::sourceSE = NULL;
	this->transfer__PlacementJob::destSE = NULL;
	this->transfer__PlacementJob::jobParams = NULL;
	this->transfer__PlacementJob::credential = NULL;
	/* transient soap skipped */
}

void transfer__PlacementJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->transfer__PlacementJob::logicalFiles);
	soap_serialize_PointerTostd__string(soap, &this->transfer__PlacementJob::sourceSE);
	soap_serialize_PointerTostd__string(soap, &this->transfer__PlacementJob::destSE);
	soap_serialize_PointerTotransfer__TransferParams(soap, &this->transfer__PlacementJob::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->transfer__PlacementJob::credential);
	/* transient soap skipped */
}

int transfer__PlacementJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__PlacementJob);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__PlacementJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__PlacementJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__PlacementJob(struct soap *soap, const char *tag, int id, const transfer__PlacementJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__PlacementJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "logicalFiles", -1, &(a->transfer__PlacementJob::logicalFiles), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSE", -1, &(a->transfer__PlacementJob::sourceSE), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSE", -1, &(a->transfer__PlacementJob::destSE), ""))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferParams(soap, "jobParams", -1, &(a->transfer__PlacementJob::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->transfer__PlacementJob::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__PlacementJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__PlacementJob(soap, this, tag, type);
}

SOAP_FMAC3 transfer__PlacementJob * SOAP_FMAC4 soap_get_transfer__PlacementJob(struct soap *soap, transfer__PlacementJob *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__PlacementJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__PlacementJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__PlacementJob(soap, tag, this, type);
}

SOAP_FMAC3 transfer__PlacementJob * SOAP_FMAC4 soap_in_transfer__PlacementJob(struct soap *soap, const char *tag, transfer__PlacementJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__PlacementJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__PlacementJob, sizeof(transfer__PlacementJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__PlacementJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__PlacementJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sourceSE1 = 1;
	size_t soap_flag_destSE1 = 1;
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "logicalFiles", &(a->transfer__PlacementJob::logicalFiles), "xsd:string"))
					continue;
			if (soap_flag_sourceSE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSE", &(a->transfer__PlacementJob::sourceSE), "xsd:string"))
				{	soap_flag_sourceSE1--;
					continue;
				}
			if (soap_flag_destSE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSE", &(a->transfer__PlacementJob::destSE), "xsd:string"))
				{	soap_flag_destSE1--;
					continue;
				}
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferParams(soap, "jobParams", &(a->transfer__PlacementJob::jobParams), "transfer:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->transfer__PlacementJob::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__PlacementJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__PlacementJob, 0, sizeof(transfer__PlacementJob), 0, soap_copy_transfer__PlacementJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__PlacementJob * SOAP_FMAC4 soap_instantiate_transfer__PlacementJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__PlacementJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__PlacementJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__PlacementJob;
		if (size)
			*size = sizeof(transfer__PlacementJob);
		((transfer__PlacementJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__PlacementJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__PlacementJob);
		for (int i = 0; i < n; i++)
			((transfer__PlacementJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__PlacementJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__PlacementJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__PlacementJob %p -> %p\n", q, p));
	*(transfer__PlacementJob*)p = *(transfer__PlacementJob*)q;
}

void transfer__TransferParams::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->transfer__TransferParams::keys);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->transfer__TransferParams::values);
	/* transient soap skipped */
}

void transfer__TransferParams::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->transfer__TransferParams::keys);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->transfer__TransferParams::values);
	/* transient soap skipped */
}

int transfer__TransferParams::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_transfer__TransferParams);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int transfer__TransferParams::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_transfer__TransferParams(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_transfer__TransferParams(struct soap *soap, const char *tag, int id, const transfer__TransferParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_transfer__TransferParams), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "keys", -1, &(a->transfer__TransferParams::keys), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "values", -1, &(a->transfer__TransferParams::values), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *transfer__TransferParams::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_transfer__TransferParams(soap, this, tag, type);
}

SOAP_FMAC3 transfer__TransferParams * SOAP_FMAC4 soap_get_transfer__TransferParams(struct soap *soap, transfer__TransferParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_transfer__TransferParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *transfer__TransferParams::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_transfer__TransferParams(soap, tag, this, type);
}

SOAP_FMAC3 transfer__TransferParams * SOAP_FMAC4 soap_in_transfer__TransferParams(struct soap *soap, const char *tag, transfer__TransferParams *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (transfer__TransferParams *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_transfer__TransferParams, sizeof(transfer__TransferParams), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_transfer__TransferParams)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (transfer__TransferParams *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "keys", &(a->transfer__TransferParams::keys), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "values", &(a->transfer__TransferParams::values), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (transfer__TransferParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_transfer__TransferParams, 0, sizeof(transfer__TransferParams), 0, soap_copy_transfer__TransferParams);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 transfer__TransferParams * SOAP_FMAC4 soap_instantiate_transfer__TransferParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_transfer__TransferParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_transfer__TransferParams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new transfer__TransferParams;
		if (size)
			*size = sizeof(transfer__TransferParams);
		((transfer__TransferParams*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new transfer__TransferParams[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(transfer__TransferParams);
		for (int i = 0; i < n; i++)
			((transfer__TransferParams*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (transfer__TransferParams*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_transfer__TransferParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying transfer__TransferParams %p -> %p\n", q, p));
	*(transfer__TransferParams*)p = *(transfer__TransferParams*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getServiceMetadata(struct soap *soap, struct fts__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getServiceMetadata(struct soap *soap, const struct fts__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getServiceMetadata(struct soap *soap, const struct fts__getServiceMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getServiceMetadata);
	if (soap_out_fts__getServiceMetadata(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getServiceMetadata(struct soap *soap, const char *tag, int id, const struct fts__getServiceMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getServiceMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getServiceMetadata * SOAP_FMAC4 soap_get_fts__getServiceMetadata(struct soap *soap, struct fts__getServiceMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getServiceMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getServiceMetadata * SOAP_FMAC4 soap_in_fts__getServiceMetadata(struct soap *soap, const char *tag, struct fts__getServiceMetadata *a, const char *type)
{
	size_t soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getServiceMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getServiceMetadata, sizeof(struct fts__getServiceMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getServiceMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getServiceMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getServiceMetadata, 0, sizeof(struct fts__getServiceMetadata), 0, soap_copy_fts__getServiceMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getServiceMetadata * SOAP_FMAC4 soap_instantiate_fts__getServiceMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getServiceMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getServiceMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getServiceMetadata;
		if (size)
			*size = sizeof(struct fts__getServiceMetadata);
	}
	else
	{	cp->ptr = (void*)new struct fts__getServiceMetadata[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getServiceMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getServiceMetadata*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getServiceMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getServiceMetadata %p -> %p\n", q, p));
	*(struct fts__getServiceMetadata*)p = *(struct fts__getServiceMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getServiceMetadataResponse(struct soap *soap, struct fts__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getServiceMetadataResponse(struct soap *soap, const struct fts__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getServiceMetadataReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getServiceMetadataResponse(struct soap *soap, const struct fts__getServiceMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getServiceMetadataResponse);
	if (soap_out_fts__getServiceMetadataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getServiceMetadataResponse(struct soap *soap, const char *tag, int id, const struct fts__getServiceMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getServiceMetadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getServiceMetadataReturn", -1, &a->_getServiceMetadataReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getServiceMetadataResponse * SOAP_FMAC4 soap_get_fts__getServiceMetadataResponse(struct soap *soap, struct fts__getServiceMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getServiceMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getServiceMetadataResponse * SOAP_FMAC4 soap_in_fts__getServiceMetadataResponse(struct soap *soap, const char *tag, struct fts__getServiceMetadataResponse *a, const char *type)
{
	size_t soap_flag__getServiceMetadataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getServiceMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getServiceMetadataResponse, sizeof(struct fts__getServiceMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getServiceMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getServiceMetadataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getServiceMetadataReturn, "xsd:string"))
				{	soap_flag__getServiceMetadataReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getServiceMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getServiceMetadataResponse, 0, sizeof(struct fts__getServiceMetadataResponse), 0, soap_copy_fts__getServiceMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getServiceMetadataReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getServiceMetadataResponse * SOAP_FMAC4 soap_instantiate_fts__getServiceMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getServiceMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getServiceMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getServiceMetadataResponse;
		if (size)
			*size = sizeof(struct fts__getServiceMetadataResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getServiceMetadataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getServiceMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getServiceMetadataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getServiceMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getServiceMetadataResponse %p -> %p\n", q, p));
	*(struct fts__getServiceMetadataResponse*)p = *(struct fts__getServiceMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getInterfaceVersion(struct soap *soap, struct fts__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getInterfaceVersion(struct soap *soap, const struct fts__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getInterfaceVersion(struct soap *soap, const struct fts__getInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getInterfaceVersion);
	if (soap_out_fts__getInterfaceVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getInterfaceVersion(struct soap *soap, const char *tag, int id, const struct fts__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getInterfaceVersion * SOAP_FMAC4 soap_get_fts__getInterfaceVersion(struct soap *soap, struct fts__getInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getInterfaceVersion * SOAP_FMAC4 soap_in_fts__getInterfaceVersion(struct soap *soap, const char *tag, struct fts__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getInterfaceVersion, sizeof(struct fts__getInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getInterfaceVersion, 0, sizeof(struct fts__getInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getInterfaceVersion * SOAP_FMAC4 soap_instantiate_fts__getInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getInterfaceVersion;
		if (size)
			*size = sizeof(struct fts__getInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)new struct fts__getInterfaceVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getInterfaceVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getInterfaceVersion %p -> %p\n", q, p));
	*(struct fts__getInterfaceVersion*)p = *(struct fts__getInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getInterfaceVersionResponse(struct soap *soap, struct fts__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getInterfaceVersionResponse(struct soap *soap, const struct fts__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getInterfaceVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getInterfaceVersionResponse(struct soap *soap, const struct fts__getInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getInterfaceVersionResponse);
	if (soap_out_fts__getInterfaceVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct fts__getInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getInterfaceVersionReturn", -1, &a->getInterfaceVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getInterfaceVersionResponse * SOAP_FMAC4 soap_get_fts__getInterfaceVersionResponse(struct soap *soap, struct fts__getInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getInterfaceVersionResponse * SOAP_FMAC4 soap_in_fts__getInterfaceVersionResponse(struct soap *soap, const char *tag, struct fts__getInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_getInterfaceVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getInterfaceVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getInterfaceVersionResponse, sizeof(struct fts__getInterfaceVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInterfaceVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getInterfaceVersionReturn", &a->getInterfaceVersionReturn, "xsd:string"))
				{	soap_flag_getInterfaceVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getInterfaceVersionResponse, 0, sizeof(struct fts__getInterfaceVersionResponse), 0, soap_copy_fts__getInterfaceVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getInterfaceVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getInterfaceVersionResponse * SOAP_FMAC4 soap_instantiate_fts__getInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getInterfaceVersionResponse;
		if (size)
			*size = sizeof(struct fts__getInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getInterfaceVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getInterfaceVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct fts__getInterfaceVersionResponse*)p = *(struct fts__getInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getSchemaVersion(struct soap *soap, struct fts__getSchemaVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getSchemaVersion(struct soap *soap, const struct fts__getSchemaVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getSchemaVersion(struct soap *soap, const struct fts__getSchemaVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getSchemaVersion);
	if (soap_out_fts__getSchemaVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getSchemaVersion(struct soap *soap, const char *tag, int id, const struct fts__getSchemaVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getSchemaVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getSchemaVersion * SOAP_FMAC4 soap_get_fts__getSchemaVersion(struct soap *soap, struct fts__getSchemaVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getSchemaVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getSchemaVersion * SOAP_FMAC4 soap_in_fts__getSchemaVersion(struct soap *soap, const char *tag, struct fts__getSchemaVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getSchemaVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getSchemaVersion, sizeof(struct fts__getSchemaVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getSchemaVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getSchemaVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getSchemaVersion, 0, sizeof(struct fts__getSchemaVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getSchemaVersion * SOAP_FMAC4 soap_instantiate_fts__getSchemaVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getSchemaVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getSchemaVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getSchemaVersion;
		if (size)
			*size = sizeof(struct fts__getSchemaVersion);
	}
	else
	{	cp->ptr = (void*)new struct fts__getSchemaVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getSchemaVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getSchemaVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getSchemaVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getSchemaVersion %p -> %p\n", q, p));
	*(struct fts__getSchemaVersion*)p = *(struct fts__getSchemaVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getSchemaVersionResponse(struct soap *soap, struct fts__getSchemaVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getSchemaVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getSchemaVersionResponse(struct soap *soap, const struct fts__getSchemaVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getSchemaVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getSchemaVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getSchemaVersionResponse(struct soap *soap, const struct fts__getSchemaVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getSchemaVersionResponse);
	if (soap_out_fts__getSchemaVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getSchemaVersionResponse(struct soap *soap, const char *tag, int id, const struct fts__getSchemaVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getSchemaVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getSchemaVersionReturn", -1, &a->getSchemaVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getSchemaVersionResponse * SOAP_FMAC4 soap_get_fts__getSchemaVersionResponse(struct soap *soap, struct fts__getSchemaVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getSchemaVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getSchemaVersionResponse * SOAP_FMAC4 soap_in_fts__getSchemaVersionResponse(struct soap *soap, const char *tag, struct fts__getSchemaVersionResponse *a, const char *type)
{
	size_t soap_flag_getSchemaVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getSchemaVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getSchemaVersionResponse, sizeof(struct fts__getSchemaVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getSchemaVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getSchemaVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getSchemaVersionReturn", &a->getSchemaVersionReturn, "xsd:string"))
				{	soap_flag_getSchemaVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getSchemaVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getSchemaVersionResponse, 0, sizeof(struct fts__getSchemaVersionResponse), 0, soap_copy_fts__getSchemaVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getSchemaVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getSchemaVersionResponse * SOAP_FMAC4 soap_instantiate_fts__getSchemaVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getSchemaVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getSchemaVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getSchemaVersionResponse;
		if (size)
			*size = sizeof(struct fts__getSchemaVersionResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getSchemaVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getSchemaVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getSchemaVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getSchemaVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getSchemaVersionResponse %p -> %p\n", q, p));
	*(struct fts__getSchemaVersionResponse*)p = *(struct fts__getSchemaVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getVersion(struct soap *soap, struct fts__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getVersion(struct soap *soap, const struct fts__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getVersion(struct soap *soap, const struct fts__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getVersion);
	if (soap_out_fts__getVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getVersion(struct soap *soap, const char *tag, int id, const struct fts__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getVersion * SOAP_FMAC4 soap_get_fts__getVersion(struct soap *soap, struct fts__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getVersion * SOAP_FMAC4 soap_in_fts__getVersion(struct soap *soap, const char *tag, struct fts__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getVersion, sizeof(struct fts__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getVersion, 0, sizeof(struct fts__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getVersion * SOAP_FMAC4 soap_instantiate_fts__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getVersion;
		if (size)
			*size = sizeof(struct fts__getVersion);
	}
	else
	{	cp->ptr = (void*)new struct fts__getVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getVersion %p -> %p\n", q, p));
	*(struct fts__getVersion*)p = *(struct fts__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getVersionResponse(struct soap *soap, struct fts__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getVersionResponse(struct soap *soap, const struct fts__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getVersionResponse(struct soap *soap, const struct fts__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getVersionResponse);
	if (soap_out_fts__getVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getVersionResponse(struct soap *soap, const char *tag, int id, const struct fts__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getVersionReturn", -1, &a->getVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getVersionResponse * SOAP_FMAC4 soap_get_fts__getVersionResponse(struct soap *soap, struct fts__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getVersionResponse * SOAP_FMAC4 soap_in_fts__getVersionResponse(struct soap *soap, const char *tag, struct fts__getVersionResponse *a, const char *type)
{
	size_t soap_flag_getVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getVersionResponse, sizeof(struct fts__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getVersionReturn", &a->getVersionReturn, "xsd:string"))
				{	soap_flag_getVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getVersionResponse, 0, sizeof(struct fts__getVersionResponse), 0, soap_copy_fts__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getVersionResponse * SOAP_FMAC4 soap_instantiate_fts__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getVersionResponse;
		if (size)
			*size = sizeof(struct fts__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getVersionResponse %p -> %p\n", q, p));
	*(struct fts__getVersionResponse*)p = *(struct fts__getVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getRolesOf(struct soap *soap, struct fts__getRolesOf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_otherDN);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getRolesOf(struct soap *soap, const struct fts__getRolesOf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_otherDN, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_otherDN);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getRolesOf(struct soap *soap, const struct fts__getRolesOf *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getRolesOf);
	if (soap_out_fts__getRolesOf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getRolesOf(struct soap *soap, const char *tag, int id, const struct fts__getRolesOf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getRolesOf), type))
		return soap->error;
	if (soap_out_std__string(soap, "otherDN", -1, &a->_otherDN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getRolesOf * SOAP_FMAC4 soap_get_fts__getRolesOf(struct soap *soap, struct fts__getRolesOf *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getRolesOf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getRolesOf * SOAP_FMAC4 soap_in_fts__getRolesOf(struct soap *soap, const char *tag, struct fts__getRolesOf *a, const char *type)
{
	size_t soap_flag__otherDN = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getRolesOf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getRolesOf, sizeof(struct fts__getRolesOf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getRolesOf(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__otherDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_otherDN, "xsd:string"))
				{	soap_flag__otherDN--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getRolesOf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getRolesOf, 0, sizeof(struct fts__getRolesOf), 0, soap_copy_fts__getRolesOf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__otherDN > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getRolesOf * SOAP_FMAC4 soap_instantiate_fts__getRolesOf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getRolesOf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getRolesOf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getRolesOf;
		if (size)
			*size = sizeof(struct fts__getRolesOf);
	}
	else
	{	cp->ptr = (void*)new struct fts__getRolesOf[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getRolesOf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getRolesOf*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getRolesOf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getRolesOf %p -> %p\n", q, p));
	*(struct fts__getRolesOf*)p = *(struct fts__getRolesOf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getRolesOfResponse(struct soap *soap, struct fts__getRolesOfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getRolesOfReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getRolesOfResponse(struct soap *soap, const struct fts__getRolesOfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__Roles(soap, &a->_getRolesOfReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getRolesOfResponse(struct soap *soap, const struct fts__getRolesOfResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getRolesOfResponse);
	if (soap_out_fts__getRolesOfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getRolesOfResponse(struct soap *soap, const char *tag, int id, const struct fts__getRolesOfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getRolesOfResponse), type))
		return soap->error;
	if (soap_out_PointerTotransfer__Roles(soap, "getRolesOfReturn", -1, &a->_getRolesOfReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getRolesOfResponse * SOAP_FMAC4 soap_get_fts__getRolesOfResponse(struct soap *soap, struct fts__getRolesOfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getRolesOfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getRolesOfResponse * SOAP_FMAC4 soap_in_fts__getRolesOfResponse(struct soap *soap, const char *tag, struct fts__getRolesOfResponse *a, const char *type)
{
	size_t soap_flag__getRolesOfReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getRolesOfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getRolesOfResponse, sizeof(struct fts__getRolesOfResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getRolesOfResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getRolesOfReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__Roles(soap, NULL, &a->_getRolesOfReturn, "transfer:Roles"))
				{	soap_flag__getRolesOfReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getRolesOfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getRolesOfResponse, 0, sizeof(struct fts__getRolesOfResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getRolesOfResponse * SOAP_FMAC4 soap_instantiate_fts__getRolesOfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getRolesOfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getRolesOfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getRolesOfResponse;
		if (size)
			*size = sizeof(struct fts__getRolesOfResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getRolesOfResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getRolesOfResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getRolesOfResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getRolesOfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getRolesOfResponse %p -> %p\n", q, p));
	*(struct fts__getRolesOfResponse*)p = *(struct fts__getRolesOfResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getRoles(struct soap *soap, struct fts__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getRoles(struct soap *soap, const struct fts__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getRoles(struct soap *soap, const struct fts__getRoles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getRoles);
	if (soap_out_fts__getRoles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getRoles(struct soap *soap, const char *tag, int id, const struct fts__getRoles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getRoles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getRoles * SOAP_FMAC4 soap_get_fts__getRoles(struct soap *soap, struct fts__getRoles *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getRoles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getRoles * SOAP_FMAC4 soap_in_fts__getRoles(struct soap *soap, const char *tag, struct fts__getRoles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getRoles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getRoles, sizeof(struct fts__getRoles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getRoles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getRoles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getRoles, 0, sizeof(struct fts__getRoles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getRoles * SOAP_FMAC4 soap_instantiate_fts__getRoles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getRoles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getRoles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getRoles;
		if (size)
			*size = sizeof(struct fts__getRoles);
	}
	else
	{	cp->ptr = (void*)new struct fts__getRoles[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getRoles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getRoles*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getRoles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getRoles %p -> %p\n", q, p));
	*(struct fts__getRoles*)p = *(struct fts__getRoles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getRolesResponse(struct soap *soap, struct fts__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getRolesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getRolesResponse(struct soap *soap, const struct fts__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__Roles(soap, &a->getRolesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getRolesResponse(struct soap *soap, const struct fts__getRolesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getRolesResponse);
	if (soap_out_fts__getRolesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getRolesResponse(struct soap *soap, const char *tag, int id, const struct fts__getRolesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getRolesResponse), type))
		return soap->error;
	if (soap_out_PointerTotransfer__Roles(soap, "getRolesReturn", -1, &a->getRolesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getRolesResponse * SOAP_FMAC4 soap_get_fts__getRolesResponse(struct soap *soap, struct fts__getRolesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getRolesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getRolesResponse * SOAP_FMAC4 soap_in_fts__getRolesResponse(struct soap *soap, const char *tag, struct fts__getRolesResponse *a, const char *type)
{
	size_t soap_flag_getRolesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getRolesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getRolesResponse, sizeof(struct fts__getRolesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getRolesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getRolesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__Roles(soap, "getRolesReturn", &a->getRolesReturn, "transfer:Roles"))
				{	soap_flag_getRolesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getRolesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getRolesResponse, 0, sizeof(struct fts__getRolesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getRolesResponse * SOAP_FMAC4 soap_instantiate_fts__getRolesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getRolesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getRolesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getRolesResponse;
		if (size)
			*size = sizeof(struct fts__getRolesResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getRolesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getRolesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getRolesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getRolesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getRolesResponse %p -> %p\n", q, p));
	*(struct fts__getRolesResponse*)p = *(struct fts__getRolesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listVOManagers(struct soap *soap, struct fts__listVOManagers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listVOManagers(struct soap *soap, const struct fts__listVOManagers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listVOManagers(struct soap *soap, const struct fts__listVOManagers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listVOManagers);
	if (soap_out_fts__listVOManagers(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listVOManagers(struct soap *soap, const char *tag, int id, const struct fts__listVOManagers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listVOManagers), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listVOManagers * SOAP_FMAC4 soap_get_fts__listVOManagers(struct soap *soap, struct fts__listVOManagers *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listVOManagers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listVOManagers * SOAP_FMAC4 soap_in_fts__listVOManagers(struct soap *soap, const char *tag, struct fts__listVOManagers *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listVOManagers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listVOManagers, sizeof(struct fts__listVOManagers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__listVOManagers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listVOManagers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listVOManagers, 0, sizeof(struct fts__listVOManagers), 0, soap_copy_fts__listVOManagers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listVOManagers * SOAP_FMAC4 soap_instantiate_fts__listVOManagers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listVOManagers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listVOManagers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listVOManagers;
		if (size)
			*size = sizeof(struct fts__listVOManagers);
	}
	else
	{	cp->ptr = (void*)new struct fts__listVOManagers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listVOManagers);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listVOManagers*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listVOManagers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listVOManagers %p -> %p\n", q, p));
	*(struct fts__listVOManagers*)p = *(struct fts__listVOManagers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listVOManagersResponse(struct soap *soap, struct fts__listVOManagersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listVOManagersReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listVOManagersResponse(struct soap *soap, const struct fts__listVOManagersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_listVOManagersReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listVOManagersResponse(struct soap *soap, const struct fts__listVOManagersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listVOManagersResponse);
	if (soap_out_fts__listVOManagersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listVOManagersResponse(struct soap *soap, const char *tag, int id, const struct fts__listVOManagersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listVOManagersResponse), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, "listVOManagersReturn", -1, &a->_listVOManagersReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listVOManagersResponse * SOAP_FMAC4 soap_get_fts__listVOManagersResponse(struct soap *soap, struct fts__listVOManagersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listVOManagersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listVOManagersResponse * SOAP_FMAC4 soap_in_fts__listVOManagersResponse(struct soap *soap, const char *tag, struct fts__listVOManagersResponse *a, const char *type)
{
	size_t soap_flag__listVOManagersReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listVOManagersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listVOManagersResponse, sizeof(struct fts__listVOManagersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__listVOManagersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listVOManagersReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_listVOManagersReturn, "fts:ArrayOf_soapenc_string"))
				{	soap_flag__listVOManagersReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listVOManagersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listVOManagersResponse, 0, sizeof(struct fts__listVOManagersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listVOManagersResponse * SOAP_FMAC4 soap_instantiate_fts__listVOManagersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listVOManagersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listVOManagersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listVOManagersResponse;
		if (size)
			*size = sizeof(struct fts__listVOManagersResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__listVOManagersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listVOManagersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listVOManagersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listVOManagersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listVOManagersResponse %p -> %p\n", q, p));
	*(struct fts__listVOManagersResponse*)p = *(struct fts__listVOManagersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__removeVOManager(struct soap *soap, struct fts__removeVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
	soap_default_std__string(soap, &a->_principal);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__removeVOManager(struct soap *soap, const struct fts__removeVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
	soap_embedded(soap, &a->_principal, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_principal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__removeVOManager(struct soap *soap, const struct fts__removeVOManager *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__removeVOManager);
	if (soap_out_fts__removeVOManager(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__removeVOManager(struct soap *soap, const char *tag, int id, const struct fts__removeVOManager *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__removeVOManager), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "principal", -1, &a->_principal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__removeVOManager * SOAP_FMAC4 soap_get_fts__removeVOManager(struct soap *soap, struct fts__removeVOManager *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__removeVOManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__removeVOManager * SOAP_FMAC4 soap_in_fts__removeVOManager(struct soap *soap, const char *tag, struct fts__removeVOManager *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	size_t soap_flag__principal = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__removeVOManager *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__removeVOManager, sizeof(struct fts__removeVOManager), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__removeVOManager(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap_flag__principal && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_principal, "xsd:string"))
				{	soap_flag__principal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__removeVOManager *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__removeVOManager, 0, sizeof(struct fts__removeVOManager), 0, soap_copy_fts__removeVOManager);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0 || soap_flag__principal > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__removeVOManager * SOAP_FMAC4 soap_instantiate_fts__removeVOManager(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__removeVOManager(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__removeVOManager, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__removeVOManager;
		if (size)
			*size = sizeof(struct fts__removeVOManager);
	}
	else
	{	cp->ptr = (void*)new struct fts__removeVOManager[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__removeVOManager);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__removeVOManager*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__removeVOManager(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__removeVOManager %p -> %p\n", q, p));
	*(struct fts__removeVOManager*)p = *(struct fts__removeVOManager*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__removeVOManagerResponse(struct soap *soap, struct fts__removeVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__removeVOManagerResponse(struct soap *soap, const struct fts__removeVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__removeVOManagerResponse(struct soap *soap, const struct fts__removeVOManagerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__removeVOManagerResponse);
	if (soap_out_fts__removeVOManagerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__removeVOManagerResponse(struct soap *soap, const char *tag, int id, const struct fts__removeVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__removeVOManagerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__removeVOManagerResponse * SOAP_FMAC4 soap_get_fts__removeVOManagerResponse(struct soap *soap, struct fts__removeVOManagerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__removeVOManagerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__removeVOManagerResponse * SOAP_FMAC4 soap_in_fts__removeVOManagerResponse(struct soap *soap, const char *tag, struct fts__removeVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__removeVOManagerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__removeVOManagerResponse, sizeof(struct fts__removeVOManagerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__removeVOManagerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__removeVOManagerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__removeVOManagerResponse, 0, sizeof(struct fts__removeVOManagerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__removeVOManagerResponse * SOAP_FMAC4 soap_instantiate_fts__removeVOManagerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__removeVOManagerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__removeVOManagerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__removeVOManagerResponse;
		if (size)
			*size = sizeof(struct fts__removeVOManagerResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__removeVOManagerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__removeVOManagerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__removeVOManagerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__removeVOManagerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__removeVOManagerResponse %p -> %p\n", q, p));
	*(struct fts__removeVOManagerResponse*)p = *(struct fts__removeVOManagerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__addVOManager(struct soap *soap, struct fts__addVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
	soap_default_std__string(soap, &a->_principal);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__addVOManager(struct soap *soap, const struct fts__addVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
	soap_embedded(soap, &a->_principal, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_principal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__addVOManager(struct soap *soap, const struct fts__addVOManager *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__addVOManager);
	if (soap_out_fts__addVOManager(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__addVOManager(struct soap *soap, const char *tag, int id, const struct fts__addVOManager *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__addVOManager), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "principal", -1, &a->_principal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__addVOManager * SOAP_FMAC4 soap_get_fts__addVOManager(struct soap *soap, struct fts__addVOManager *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__addVOManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__addVOManager * SOAP_FMAC4 soap_in_fts__addVOManager(struct soap *soap, const char *tag, struct fts__addVOManager *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	size_t soap_flag__principal = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__addVOManager *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__addVOManager, sizeof(struct fts__addVOManager), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__addVOManager(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap_flag__principal && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_principal, "xsd:string"))
				{	soap_flag__principal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__addVOManager *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__addVOManager, 0, sizeof(struct fts__addVOManager), 0, soap_copy_fts__addVOManager);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0 || soap_flag__principal > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__addVOManager * SOAP_FMAC4 soap_instantiate_fts__addVOManager(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__addVOManager(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__addVOManager, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__addVOManager;
		if (size)
			*size = sizeof(struct fts__addVOManager);
	}
	else
	{	cp->ptr = (void*)new struct fts__addVOManager[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__addVOManager);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__addVOManager*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__addVOManager(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__addVOManager %p -> %p\n", q, p));
	*(struct fts__addVOManager*)p = *(struct fts__addVOManager*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__addVOManagerResponse(struct soap *soap, struct fts__addVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__addVOManagerResponse(struct soap *soap, const struct fts__addVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__addVOManagerResponse(struct soap *soap, const struct fts__addVOManagerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__addVOManagerResponse);
	if (soap_out_fts__addVOManagerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__addVOManagerResponse(struct soap *soap, const char *tag, int id, const struct fts__addVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__addVOManagerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__addVOManagerResponse * SOAP_FMAC4 soap_get_fts__addVOManagerResponse(struct soap *soap, struct fts__addVOManagerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__addVOManagerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__addVOManagerResponse * SOAP_FMAC4 soap_in_fts__addVOManagerResponse(struct soap *soap, const char *tag, struct fts__addVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__addVOManagerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__addVOManagerResponse, sizeof(struct fts__addVOManagerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__addVOManagerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__addVOManagerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__addVOManagerResponse, 0, sizeof(struct fts__addVOManagerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__addVOManagerResponse * SOAP_FMAC4 soap_instantiate_fts__addVOManagerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__addVOManagerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__addVOManagerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__addVOManagerResponse;
		if (size)
			*size = sizeof(struct fts__addVOManagerResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__addVOManagerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__addVOManagerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__addVOManagerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__addVOManagerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__addVOManagerResponse %p -> %p\n", q, p));
	*(struct fts__addVOManagerResponse*)p = *(struct fts__addVOManagerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__setJobPriority(struct soap *soap, struct fts__setJobPriority *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_priority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__setJobPriority(struct soap *soap, const struct fts__setJobPriority *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__setJobPriority(struct soap *soap, const struct fts__setJobPriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__setJobPriority);
	if (soap_out_fts__setJobPriority(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__setJobPriority(struct soap *soap, const char *tag, int id, const struct fts__setJobPriority *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__setJobPriority), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &a->_priority, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__setJobPriority * SOAP_FMAC4 soap_get_fts__setJobPriority(struct soap *soap, struct fts__setJobPriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__setJobPriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__setJobPriority * SOAP_FMAC4 soap_in_fts__setJobPriority(struct soap *soap, const char *tag, struct fts__setJobPriority *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__priority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__setJobPriority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__setJobPriority, sizeof(struct fts__setJobPriority), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__setJobPriority(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_priority, "xsd:int"))
				{	soap_flag__priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__setJobPriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__setJobPriority, 0, sizeof(struct fts__setJobPriority), 0, soap_copy_fts__setJobPriority);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__priority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__setJobPriority * SOAP_FMAC4 soap_instantiate_fts__setJobPriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__setJobPriority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__setJobPriority, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__setJobPriority;
		if (size)
			*size = sizeof(struct fts__setJobPriority);
	}
	else
	{	cp->ptr = (void*)new struct fts__setJobPriority[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__setJobPriority);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__setJobPriority*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__setJobPriority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__setJobPriority %p -> %p\n", q, p));
	*(struct fts__setJobPriority*)p = *(struct fts__setJobPriority*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__setJobPriorityResponse(struct soap *soap, struct fts__setJobPriorityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__setJobPriorityResponse(struct soap *soap, const struct fts__setJobPriorityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__setJobPriorityResponse(struct soap *soap, const struct fts__setJobPriorityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__setJobPriorityResponse);
	if (soap_out_fts__setJobPriorityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__setJobPriorityResponse(struct soap *soap, const char *tag, int id, const struct fts__setJobPriorityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__setJobPriorityResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__setJobPriorityResponse * SOAP_FMAC4 soap_get_fts__setJobPriorityResponse(struct soap *soap, struct fts__setJobPriorityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__setJobPriorityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__setJobPriorityResponse * SOAP_FMAC4 soap_in_fts__setJobPriorityResponse(struct soap *soap, const char *tag, struct fts__setJobPriorityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__setJobPriorityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__setJobPriorityResponse, sizeof(struct fts__setJobPriorityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__setJobPriorityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__setJobPriorityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__setJobPriorityResponse, 0, sizeof(struct fts__setJobPriorityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__setJobPriorityResponse * SOAP_FMAC4 soap_instantiate_fts__setJobPriorityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__setJobPriorityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__setJobPriorityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__setJobPriorityResponse;
		if (size)
			*size = sizeof(struct fts__setJobPriorityResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__setJobPriorityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__setJobPriorityResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__setJobPriorityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__setJobPriorityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__setJobPriorityResponse %p -> %p\n", q, p));
	*(struct fts__setJobPriorityResponse*)p = *(struct fts__setJobPriorityResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__cancel(struct soap *soap, struct fts__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_requestIDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__cancel(struct soap *soap, const struct fts__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_requestIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__cancel(struct soap *soap, const struct fts__cancel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__cancel);
	if (soap_out_fts__cancel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__cancel(struct soap *soap, const char *tag, int id, const struct fts__cancel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__cancel), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, "requestIDs", -1, &a->_requestIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__cancel * SOAP_FMAC4 soap_get_fts__cancel(struct soap *soap, struct fts__cancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__cancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__cancel * SOAP_FMAC4 soap_in_fts__cancel(struct soap *soap, const char *tag, struct fts__cancel *a, const char *type)
{
	size_t soap_flag__requestIDs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__cancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__cancel, sizeof(struct fts__cancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__cancel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestIDs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_requestIDs, "fts:ArrayOf_soapenc_string"))
				{	soap_flag__requestIDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__cancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__cancel, 0, sizeof(struct fts__cancel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__cancel * SOAP_FMAC4 soap_instantiate_fts__cancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__cancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__cancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__cancel;
		if (size)
			*size = sizeof(struct fts__cancel);
	}
	else
	{	cp->ptr = (void*)new struct fts__cancel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__cancel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__cancel*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__cancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__cancel %p -> %p\n", q, p));
	*(struct fts__cancel*)p = *(struct fts__cancel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__cancelResponse(struct soap *soap, struct fts__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__cancelResponse(struct soap *soap, const struct fts__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__cancelResponse(struct soap *soap, const struct fts__cancelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__cancelResponse);
	if (soap_out_fts__cancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__cancelResponse(struct soap *soap, const char *tag, int id, const struct fts__cancelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__cancelResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__cancelResponse * SOAP_FMAC4 soap_get_fts__cancelResponse(struct soap *soap, struct fts__cancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__cancelResponse * SOAP_FMAC4 soap_in_fts__cancelResponse(struct soap *soap, const char *tag, struct fts__cancelResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__cancelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__cancelResponse, sizeof(struct fts__cancelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__cancelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__cancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__cancelResponse, 0, sizeof(struct fts__cancelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__cancelResponse * SOAP_FMAC4 soap_instantiate_fts__cancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__cancelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__cancelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__cancelResponse;
		if (size)
			*size = sizeof(struct fts__cancelResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__cancelResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__cancelResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__cancelResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__cancelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__cancelResponse %p -> %p\n", q, p));
	*(struct fts__cancelResponse*)p = *(struct fts__cancelResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobSummary2(struct soap *soap, struct fts__getTransferJobSummary2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobSummary2(struct soap *soap, const struct fts__getTransferJobSummary2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobSummary2(struct soap *soap, const struct fts__getTransferJobSummary2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobSummary2);
	if (soap_out_fts__getTransferJobSummary2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobSummary2(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobSummary2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobSummary2), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobSummary2 * SOAP_FMAC4 soap_get_fts__getTransferJobSummary2(struct soap *soap, struct fts__getTransferJobSummary2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobSummary2 * SOAP_FMAC4 soap_in_fts__getTransferJobSummary2(struct soap *soap, const char *tag, struct fts__getTransferJobSummary2 *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobSummary2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobSummary2, sizeof(struct fts__getTransferJobSummary2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobSummary2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobSummary2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobSummary2, 0, sizeof(struct fts__getTransferJobSummary2), 0, soap_copy_fts__getTransferJobSummary2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobSummary2 * SOAP_FMAC4 soap_instantiate_fts__getTransferJobSummary2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobSummary2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobSummary2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary2;
		if (size)
			*size = sizeof(struct fts__getTransferJobSummary2);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobSummary2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobSummary2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobSummary2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobSummary2 %p -> %p\n", q, p));
	*(struct fts__getTransferJobSummary2*)p = *(struct fts__getTransferJobSummary2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobSummary2Response(struct soap *soap, struct fts__getTransferJobSummary2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobSummary2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobSummary2Response(struct soap *soap, const struct fts__getTransferJobSummary2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJobSummary2(soap, &a->_getTransferJobSummary2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobSummary2Response(struct soap *soap, const struct fts__getTransferJobSummary2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobSummary2Response);
	if (soap_out_fts__getTransferJobSummary2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobSummary2Response(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobSummary2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobSummary2Response), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJobSummary2(soap, "getTransferJobSummary2Return", -1, &a->_getTransferJobSummary2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobSummary2Response * SOAP_FMAC4 soap_get_fts__getTransferJobSummary2Response(struct soap *soap, struct fts__getTransferJobSummary2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobSummary2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobSummary2Response * SOAP_FMAC4 soap_in_fts__getTransferJobSummary2Response(struct soap *soap, const char *tag, struct fts__getTransferJobSummary2Response *a, const char *type)
{
	size_t soap_flag__getTransferJobSummary2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobSummary2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobSummary2Response, sizeof(struct fts__getTransferJobSummary2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobSummary2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobSummary2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJobSummary2(soap, NULL, &a->_getTransferJobSummary2Return, "transfer:TransferJobSummary2"))
				{	soap_flag__getTransferJobSummary2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobSummary2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobSummary2Response, 0, sizeof(struct fts__getTransferJobSummary2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobSummary2Response * SOAP_FMAC4 soap_instantiate_fts__getTransferJobSummary2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobSummary2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobSummary2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary2Response;
		if (size)
			*size = sizeof(struct fts__getTransferJobSummary2Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary2Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobSummary2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobSummary2Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobSummary2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobSummary2Response %p -> %p\n", q, p));
	*(struct fts__getTransferJobSummary2Response*)p = *(struct fts__getTransferJobSummary2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobSummary(struct soap *soap, struct fts__getTransferJobSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobSummary(struct soap *soap, const struct fts__getTransferJobSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobSummary(struct soap *soap, const struct fts__getTransferJobSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobSummary);
	if (soap_out_fts__getTransferJobSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobSummary(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobSummary), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobSummary * SOAP_FMAC4 soap_get_fts__getTransferJobSummary(struct soap *soap, struct fts__getTransferJobSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobSummary * SOAP_FMAC4 soap_in_fts__getTransferJobSummary(struct soap *soap, const char *tag, struct fts__getTransferJobSummary *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobSummary, sizeof(struct fts__getTransferJobSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobSummary, 0, sizeof(struct fts__getTransferJobSummary), 0, soap_copy_fts__getTransferJobSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobSummary * SOAP_FMAC4 soap_instantiate_fts__getTransferJobSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary;
		if (size)
			*size = sizeof(struct fts__getTransferJobSummary);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobSummary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobSummary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobSummary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobSummary %p -> %p\n", q, p));
	*(struct fts__getTransferJobSummary*)p = *(struct fts__getTransferJobSummary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobSummaryResponse(struct soap *soap, struct fts__getTransferJobSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobSummaryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobSummaryResponse(struct soap *soap, const struct fts__getTransferJobSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJobSummary(soap, &a->_getTransferJobSummaryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobSummaryResponse(struct soap *soap, const struct fts__getTransferJobSummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobSummaryResponse);
	if (soap_out_fts__getTransferJobSummaryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobSummaryResponse(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobSummaryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobSummaryResponse), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJobSummary(soap, "getTransferJobSummaryReturn", -1, &a->_getTransferJobSummaryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobSummaryResponse * SOAP_FMAC4 soap_get_fts__getTransferJobSummaryResponse(struct soap *soap, struct fts__getTransferJobSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobSummaryResponse * SOAP_FMAC4 soap_in_fts__getTransferJobSummaryResponse(struct soap *soap, const char *tag, struct fts__getTransferJobSummaryResponse *a, const char *type)
{
	size_t soap_flag__getTransferJobSummaryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobSummaryResponse, sizeof(struct fts__getTransferJobSummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobSummaryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJobSummary(soap, NULL, &a->_getTransferJobSummaryReturn, "transfer:TransferJobSummary"))
				{	soap_flag__getTransferJobSummaryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobSummaryResponse, 0, sizeof(struct fts__getTransferJobSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobSummaryResponse * SOAP_FMAC4 soap_instantiate_fts__getTransferJobSummaryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobSummaryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobSummaryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobSummaryResponse;
		if (size)
			*size = sizeof(struct fts__getTransferJobSummaryResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobSummaryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobSummaryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobSummaryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobSummaryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobSummaryResponse %p -> %p\n", q, p));
	*(struct fts__getTransferJobSummaryResponse*)p = *(struct fts__getTransferJobSummaryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobStatus(struct soap *soap, struct fts__getTransferJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobStatus(struct soap *soap, const struct fts__getTransferJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobStatus(struct soap *soap, const struct fts__getTransferJobStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobStatus);
	if (soap_out_fts__getTransferJobStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobStatus(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobStatus * SOAP_FMAC4 soap_get_fts__getTransferJobStatus(struct soap *soap, struct fts__getTransferJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobStatus * SOAP_FMAC4 soap_in_fts__getTransferJobStatus(struct soap *soap, const char *tag, struct fts__getTransferJobStatus *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobStatus, sizeof(struct fts__getTransferJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobStatus, 0, sizeof(struct fts__getTransferJobStatus), 0, soap_copy_fts__getTransferJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobStatus * SOAP_FMAC4 soap_instantiate_fts__getTransferJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobStatus;
		if (size)
			*size = sizeof(struct fts__getTransferJobStatus);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobStatus %p -> %p\n", q, p));
	*(struct fts__getTransferJobStatus*)p = *(struct fts__getTransferJobStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getTransferJobStatusResponse(struct soap *soap, struct fts__getTransferJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getTransferJobStatusResponse(struct soap *soap, const struct fts__getTransferJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__JobStatus(soap, &a->_getTransferJobStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getTransferJobStatusResponse(struct soap *soap, const struct fts__getTransferJobStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getTransferJobStatusResponse);
	if (soap_out_fts__getTransferJobStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getTransferJobStatusResponse(struct soap *soap, const char *tag, int id, const struct fts__getTransferJobStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getTransferJobStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTotransfer__JobStatus(soap, "getTransferJobStatusReturn", -1, &a->_getTransferJobStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getTransferJobStatusResponse * SOAP_FMAC4 soap_get_fts__getTransferJobStatusResponse(struct soap *soap, struct fts__getTransferJobStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getTransferJobStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getTransferJobStatusResponse * SOAP_FMAC4 soap_in_fts__getTransferJobStatusResponse(struct soap *soap, const char *tag, struct fts__getTransferJobStatusResponse *a, const char *type)
{
	size_t soap_flag__getTransferJobStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getTransferJobStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getTransferJobStatusResponse, sizeof(struct fts__getTransferJobStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getTransferJobStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__JobStatus(soap, NULL, &a->_getTransferJobStatusReturn, "transfer:JobStatus"))
				{	soap_flag__getTransferJobStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getTransferJobStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getTransferJobStatusResponse, 0, sizeof(struct fts__getTransferJobStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getTransferJobStatusResponse * SOAP_FMAC4 soap_instantiate_fts__getTransferJobStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getTransferJobStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getTransferJobStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getTransferJobStatusResponse;
		if (size)
			*size = sizeof(struct fts__getTransferJobStatusResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getTransferJobStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getTransferJobStatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getTransferJobStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getTransferJobStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getTransferJobStatusResponse %p -> %p\n", q, p));
	*(struct fts__getTransferJobStatusResponse*)p = *(struct fts__getTransferJobStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getFileStatus2(struct soap *soap, struct fts__getFileStatus2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_offset);
	soap_default_int(soap, &a->_limit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getFileStatus2(struct soap *soap, const struct fts__getFileStatus2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getFileStatus2(struct soap *soap, const struct fts__getFileStatus2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getFileStatus2);
	if (soap_out_fts__getFileStatus2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getFileStatus2(struct soap *soap, const char *tag, int id, const struct fts__getFileStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getFileStatus2), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->_offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->_limit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getFileStatus2 * SOAP_FMAC4 soap_get_fts__getFileStatus2(struct soap *soap, struct fts__getFileStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getFileStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getFileStatus2 * SOAP_FMAC4 soap_in_fts__getFileStatus2(struct soap *soap, const char *tag, struct fts__getFileStatus2 *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__offset = 1;
	size_t soap_flag__limit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getFileStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getFileStatus2, sizeof(struct fts__getFileStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getFileStatus2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_offset, "xsd:int"))
				{	soap_flag__offset--;
					continue;
				}
			if (soap_flag__limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_limit, "xsd:int"))
				{	soap_flag__limit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getFileStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getFileStatus2, 0, sizeof(struct fts__getFileStatus2), 0, soap_copy_fts__getFileStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__offset > 0 || soap_flag__limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getFileStatus2 * SOAP_FMAC4 soap_instantiate_fts__getFileStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getFileStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getFileStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getFileStatus2;
		if (size)
			*size = sizeof(struct fts__getFileStatus2);
	}
	else
	{	cp->ptr = (void*)new struct fts__getFileStatus2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getFileStatus2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getFileStatus2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getFileStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getFileStatus2 %p -> %p\n", q, p));
	*(struct fts__getFileStatus2*)p = *(struct fts__getFileStatus2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getFileStatus2Response(struct soap *soap, struct fts__getFileStatus2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getFileStatus2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getFileStatus2Response(struct soap *soap, const struct fts__getFileStatus2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, &a->_getFileStatus2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getFileStatus2Response(struct soap *soap, const struct fts__getFileStatus2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getFileStatus2Response);
	if (soap_out_fts__getFileStatus2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getFileStatus2Response(struct soap *soap, const char *tag, int id, const struct fts__getFileStatus2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getFileStatus2Response), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, "getFileStatus2Return", -1, &a->_getFileStatus2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getFileStatus2Response * SOAP_FMAC4 soap_get_fts__getFileStatus2Response(struct soap *soap, struct fts__getFileStatus2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getFileStatus2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getFileStatus2Response * SOAP_FMAC4 soap_in_fts__getFileStatus2Response(struct soap *soap, const char *tag, struct fts__getFileStatus2Response *a, const char *type)
{
	size_t soap_flag__getFileStatus2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getFileStatus2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getFileStatus2Response, sizeof(struct fts__getFileStatus2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getFileStatus2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getFileStatus2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, &a->_getFileStatus2Return, "fts:ArrayOf_tns3_FileTransferStatus2"))
				{	soap_flag__getFileStatus2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getFileStatus2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getFileStatus2Response, 0, sizeof(struct fts__getFileStatus2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getFileStatus2Response * SOAP_FMAC4 soap_instantiate_fts__getFileStatus2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getFileStatus2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getFileStatus2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getFileStatus2Response;
		if (size)
			*size = sizeof(struct fts__getFileStatus2Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__getFileStatus2Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getFileStatus2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getFileStatus2Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getFileStatus2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getFileStatus2Response %p -> %p\n", q, p));
	*(struct fts__getFileStatus2Response*)p = *(struct fts__getFileStatus2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getFileStatus(struct soap *soap, struct fts__getFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_offset);
	soap_default_int(soap, &a->_limit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getFileStatus(struct soap *soap, const struct fts__getFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getFileStatus(struct soap *soap, const struct fts__getFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getFileStatus);
	if (soap_out_fts__getFileStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getFileStatus(struct soap *soap, const char *tag, int id, const struct fts__getFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getFileStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->_offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->_limit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getFileStatus * SOAP_FMAC4 soap_get_fts__getFileStatus(struct soap *soap, struct fts__getFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getFileStatus * SOAP_FMAC4 soap_in_fts__getFileStatus(struct soap *soap, const char *tag, struct fts__getFileStatus *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__offset = 1;
	size_t soap_flag__limit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getFileStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getFileStatus, sizeof(struct fts__getFileStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__getFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_offset, "xsd:int"))
				{	soap_flag__offset--;
					continue;
				}
			if (soap_flag__limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_limit, "xsd:int"))
				{	soap_flag__limit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getFileStatus, 0, sizeof(struct fts__getFileStatus), 0, soap_copy_fts__getFileStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__offset > 0 || soap_flag__limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getFileStatus * SOAP_FMAC4 soap_instantiate_fts__getFileStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getFileStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getFileStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getFileStatus;
		if (size)
			*size = sizeof(struct fts__getFileStatus);
	}
	else
	{	cp->ptr = (void*)new struct fts__getFileStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getFileStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getFileStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getFileStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getFileStatus %p -> %p\n", q, p));
	*(struct fts__getFileStatus*)p = *(struct fts__getFileStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__getFileStatusResponse(struct soap *soap, struct fts__getFileStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getFileStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__getFileStatusResponse(struct soap *soap, const struct fts__getFileStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, &a->_getFileStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__getFileStatusResponse(struct soap *soap, const struct fts__getFileStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__getFileStatusResponse);
	if (soap_out_fts__getFileStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__getFileStatusResponse(struct soap *soap, const char *tag, int id, const struct fts__getFileStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__getFileStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, "getFileStatusReturn", -1, &a->_getFileStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__getFileStatusResponse * SOAP_FMAC4 soap_get_fts__getFileStatusResponse(struct soap *soap, struct fts__getFileStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__getFileStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__getFileStatusResponse * SOAP_FMAC4 soap_in_fts__getFileStatusResponse(struct soap *soap, const char *tag, struct fts__getFileStatusResponse *a, const char *type)
{
	size_t soap_flag__getFileStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__getFileStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__getFileStatusResponse, sizeof(struct fts__getFileStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__getFileStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getFileStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, &a->_getFileStatusReturn, "fts:ArrayOf_tns3_FileTransferStatus"))
				{	soap_flag__getFileStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__getFileStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__getFileStatusResponse, 0, sizeof(struct fts__getFileStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__getFileStatusResponse * SOAP_FMAC4 soap_instantiate_fts__getFileStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__getFileStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__getFileStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__getFileStatusResponse;
		if (size)
			*size = sizeof(struct fts__getFileStatusResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__getFileStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__getFileStatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__getFileStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__getFileStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__getFileStatusResponse %p -> %p\n", q, p));
	*(struct fts__getFileStatusResponse*)p = *(struct fts__getFileStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listRequests2(struct soap *soap, struct fts__listRequests2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_inGivenStates = NULL;
	soap_default_std__string(soap, &a->_forDN);
	soap_default_std__string(soap, &a->_forVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listRequests2(struct soap *soap, const struct fts__listRequests2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_inGivenStates);
	soap_embedded(soap, &a->_forDN, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_forDN);
	soap_embedded(soap, &a->_forVO, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_forVO);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listRequests2(struct soap *soap, const struct fts__listRequests2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listRequests2);
	if (soap_out_fts__listRequests2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listRequests2(struct soap *soap, const char *tag, int id, const struct fts__listRequests2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listRequests2), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, "inGivenStates", -1, &a->_inGivenStates, ""))
		return soap->error;
	if (soap_out_std__string(soap, "forDN", -1, &a->_forDN, ""))
		return soap->error;
	if (soap_out_std__string(soap, "forVO", -1, &a->_forVO, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listRequests2 * SOAP_FMAC4 soap_get_fts__listRequests2(struct soap *soap, struct fts__listRequests2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listRequests2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listRequests2 * SOAP_FMAC4 soap_in_fts__listRequests2(struct soap *soap, const char *tag, struct fts__listRequests2 *a, const char *type)
{
	size_t soap_flag__inGivenStates = 1;
	size_t soap_flag__forDN = 1;
	size_t soap_flag__forVO = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listRequests2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listRequests2, sizeof(struct fts__listRequests2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__listRequests2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inGivenStates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_inGivenStates, "fts:ArrayOf_soapenc_string"))
				{	soap_flag__inGivenStates--;
					continue;
				}
			if (soap_flag__forDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_forDN, "xsd:string"))
				{	soap_flag__forDN--;
					continue;
				}
			if (soap_flag__forVO && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_forVO, "xsd:string"))
				{	soap_flag__forVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listRequests2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listRequests2, 0, sizeof(struct fts__listRequests2), 0, soap_copy_fts__listRequests2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__forDN > 0 || soap_flag__forVO > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listRequests2 * SOAP_FMAC4 soap_instantiate_fts__listRequests2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listRequests2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listRequests2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listRequests2;
		if (size)
			*size = sizeof(struct fts__listRequests2);
	}
	else
	{	cp->ptr = (void*)new struct fts__listRequests2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listRequests2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listRequests2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listRequests2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listRequests2 %p -> %p\n", q, p));
	*(struct fts__listRequests2*)p = *(struct fts__listRequests2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listRequests2Response(struct soap *soap, struct fts__listRequests2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listRequests2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listRequests2Response(struct soap *soap, const struct fts__listRequests2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, &a->_listRequests2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listRequests2Response(struct soap *soap, const struct fts__listRequests2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listRequests2Response);
	if (soap_out_fts__listRequests2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listRequests2Response(struct soap *soap, const char *tag, int id, const struct fts__listRequests2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listRequests2Response), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, "listRequests2Return", -1, &a->_listRequests2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listRequests2Response * SOAP_FMAC4 soap_get_fts__listRequests2Response(struct soap *soap, struct fts__listRequests2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listRequests2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listRequests2Response * SOAP_FMAC4 soap_in_fts__listRequests2Response(struct soap *soap, const char *tag, struct fts__listRequests2Response *a, const char *type)
{
	size_t soap_flag__listRequests2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listRequests2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listRequests2Response, sizeof(struct fts__listRequests2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__listRequests2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listRequests2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, &a->_listRequests2Return, "fts:ArrayOf_tns3_JobStatus"))
				{	soap_flag__listRequests2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listRequests2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listRequests2Response, 0, sizeof(struct fts__listRequests2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listRequests2Response * SOAP_FMAC4 soap_instantiate_fts__listRequests2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listRequests2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listRequests2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listRequests2Response;
		if (size)
			*size = sizeof(struct fts__listRequests2Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__listRequests2Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listRequests2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listRequests2Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listRequests2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listRequests2Response %p -> %p\n", q, p));
	*(struct fts__listRequests2Response*)p = *(struct fts__listRequests2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listRequests(struct soap *soap, struct fts__listRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_inGivenStates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listRequests(struct soap *soap, const struct fts__listRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_inGivenStates);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listRequests(struct soap *soap, const struct fts__listRequests *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listRequests);
	if (soap_out_fts__listRequests(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listRequests(struct soap *soap, const char *tag, int id, const struct fts__listRequests *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listRequests), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, "inGivenStates", -1, &a->_inGivenStates, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listRequests * SOAP_FMAC4 soap_get_fts__listRequests(struct soap *soap, struct fts__listRequests *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listRequests(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listRequests * SOAP_FMAC4 soap_in_fts__listRequests(struct soap *soap, const char *tag, struct fts__listRequests *a, const char *type)
{
	size_t soap_flag__inGivenStates = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listRequests *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listRequests, sizeof(struct fts__listRequests), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__listRequests(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inGivenStates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_inGivenStates, "fts:ArrayOf_soapenc_string"))
				{	soap_flag__inGivenStates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listRequests *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listRequests, 0, sizeof(struct fts__listRequests), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listRequests * SOAP_FMAC4 soap_instantiate_fts__listRequests(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listRequests(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listRequests, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listRequests;
		if (size)
			*size = sizeof(struct fts__listRequests);
	}
	else
	{	cp->ptr = (void*)new struct fts__listRequests[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listRequests);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listRequests*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listRequests(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listRequests %p -> %p\n", q, p));
	*(struct fts__listRequests*)p = *(struct fts__listRequests*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__listRequestsResponse(struct soap *soap, struct fts__listRequestsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listRequestsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__listRequestsResponse(struct soap *soap, const struct fts__listRequestsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, &a->_listRequestsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__listRequestsResponse(struct soap *soap, const struct fts__listRequestsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__listRequestsResponse);
	if (soap_out_fts__listRequestsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__listRequestsResponse(struct soap *soap, const char *tag, int id, const struct fts__listRequestsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__listRequestsResponse), type))
		return soap->error;
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, "listRequestsReturn", -1, &a->_listRequestsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__listRequestsResponse * SOAP_FMAC4 soap_get_fts__listRequestsResponse(struct soap *soap, struct fts__listRequestsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__listRequestsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__listRequestsResponse * SOAP_FMAC4 soap_in_fts__listRequestsResponse(struct soap *soap, const char *tag, struct fts__listRequestsResponse *a, const char *type)
{
	size_t soap_flag__listRequestsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__listRequestsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__listRequestsResponse, sizeof(struct fts__listRequestsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__listRequestsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listRequestsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, &a->_listRequestsReturn, "fts:ArrayOf_tns3_JobStatus"))
				{	soap_flag__listRequestsReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__listRequestsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__listRequestsResponse, 0, sizeof(struct fts__listRequestsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__listRequestsResponse * SOAP_FMAC4 soap_instantiate_fts__listRequestsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__listRequestsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__listRequestsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__listRequestsResponse;
		if (size)
			*size = sizeof(struct fts__listRequestsResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__listRequestsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__listRequestsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__listRequestsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__listRequestsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__listRequestsResponse %p -> %p\n", q, p));
	*(struct fts__listRequestsResponse*)p = *(struct fts__listRequestsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__submit(struct soap *soap, struct fts__submit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__submit(struct soap *soap, const struct fts__submit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__submit(struct soap *soap, const struct fts__submit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__submit);
	if (soap_out_fts__submit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__submit(struct soap *soap, const char *tag, int id, const struct fts__submit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__submit), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__submit * SOAP_FMAC4 soap_get_fts__submit(struct soap *soap, struct fts__submit *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__submit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__submit * SOAP_FMAC4 soap_in_fts__submit(struct soap *soap, const char *tag, struct fts__submit *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__submit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__submit, sizeof(struct fts__submit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__submit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJob(soap, NULL, &a->_job, "transfer:TransferJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__submit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__submit, 0, sizeof(struct fts__submit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__submit * SOAP_FMAC4 soap_instantiate_fts__submit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__submit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__submit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__submit;
		if (size)
			*size = sizeof(struct fts__submit);
	}
	else
	{	cp->ptr = (void*)new struct fts__submit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__submit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__submit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__submit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__submit %p -> %p\n", q, p));
	*(struct fts__submit*)p = *(struct fts__submit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__submitResponse(struct soap *soap, struct fts__submitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_submitReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__submitResponse(struct soap *soap, const struct fts__submitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_submitReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_submitReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__submitResponse(struct soap *soap, const struct fts__submitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__submitResponse);
	if (soap_out_fts__submitResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__submitResponse(struct soap *soap, const char *tag, int id, const struct fts__submitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__submitResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "submitReturn", -1, &a->_submitReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__submitResponse * SOAP_FMAC4 soap_get_fts__submitResponse(struct soap *soap, struct fts__submitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__submitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__submitResponse * SOAP_FMAC4 soap_in_fts__submitResponse(struct soap *soap, const char *tag, struct fts__submitResponse *a, const char *type)
{
	size_t soap_flag__submitReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__submitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__submitResponse, sizeof(struct fts__submitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__submitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__submitReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_submitReturn, "xsd:string"))
				{	soap_flag__submitReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__submitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__submitResponse, 0, sizeof(struct fts__submitResponse), 0, soap_copy_fts__submitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__submitReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__submitResponse * SOAP_FMAC4 soap_instantiate_fts__submitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__submitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__submitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__submitResponse;
		if (size)
			*size = sizeof(struct fts__submitResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__submitResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__submitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__submitResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__submitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__submitResponse %p -> %p\n", q, p));
	*(struct fts__submitResponse*)p = *(struct fts__submitResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmit3(struct soap *soap, struct fts__transferSubmit3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmit3(struct soap *soap, const struct fts__transferSubmit3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJob2(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmit3(struct soap *soap, const struct fts__transferSubmit3 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmit3);
	if (soap_out_fts__transferSubmit3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmit3(struct soap *soap, const char *tag, int id, const struct fts__transferSubmit3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmit3), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJob2(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmit3 * SOAP_FMAC4 soap_get_fts__transferSubmit3(struct soap *soap, struct fts__transferSubmit3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmit3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmit3 * SOAP_FMAC4 soap_in_fts__transferSubmit3(struct soap *soap, const char *tag, struct fts__transferSubmit3 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmit3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmit3, sizeof(struct fts__transferSubmit3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmit3(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJob2(soap, NULL, &a->_job, "transfer:TransferJob2"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmit3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmit3, 0, sizeof(struct fts__transferSubmit3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmit3 * SOAP_FMAC4 soap_instantiate_fts__transferSubmit3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmit3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmit3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmit3;
		if (size)
			*size = sizeof(struct fts__transferSubmit3);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmit3[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmit3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmit3*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmit3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmit3 %p -> %p\n", q, p));
	*(struct fts__transferSubmit3*)p = *(struct fts__transferSubmit3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmit3Response(struct soap *soap, struct fts__transferSubmit3Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmit3Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmit3Response(struct soap *soap, const struct fts__transferSubmit3Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmit3Return, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmit3Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmit3Response(struct soap *soap, const struct fts__transferSubmit3Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmit3Response);
	if (soap_out_fts__transferSubmit3Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmit3Response(struct soap *soap, const char *tag, int id, const struct fts__transferSubmit3Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmit3Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmit3Return", -1, &a->_transferSubmit3Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmit3Response * SOAP_FMAC4 soap_get_fts__transferSubmit3Response(struct soap *soap, struct fts__transferSubmit3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmit3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmit3Response * SOAP_FMAC4 soap_in_fts__transferSubmit3Response(struct soap *soap, const char *tag, struct fts__transferSubmit3Response *a, const char *type)
{
	size_t soap_flag__transferSubmit3Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmit3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmit3Response, sizeof(struct fts__transferSubmit3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmit3Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmit3Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmit3Return, "xsd:string"))
				{	soap_flag__transferSubmit3Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmit3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmit3Response, 0, sizeof(struct fts__transferSubmit3Response), 0, soap_copy_fts__transferSubmit3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmit3Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmit3Response * SOAP_FMAC4 soap_instantiate_fts__transferSubmit3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmit3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmit3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmit3Response;
		if (size)
			*size = sizeof(struct fts__transferSubmit3Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmit3Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmit3Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmit3Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmit3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmit3Response %p -> %p\n", q, p));
	*(struct fts__transferSubmit3Response*)p = *(struct fts__transferSubmit3Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmit2(struct soap *soap, struct fts__transferSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmit2(struct soap *soap, const struct fts__transferSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmit2(struct soap *soap, const struct fts__transferSubmit2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmit2);
	if (soap_out_fts__transferSubmit2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmit2(struct soap *soap, const char *tag, int id, const struct fts__transferSubmit2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmit2), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmit2 * SOAP_FMAC4 soap_get_fts__transferSubmit2(struct soap *soap, struct fts__transferSubmit2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmit2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmit2 * SOAP_FMAC4 soap_in_fts__transferSubmit2(struct soap *soap, const char *tag, struct fts__transferSubmit2 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmit2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmit2, sizeof(struct fts__transferSubmit2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmit2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJob(soap, NULL, &a->_job, "transfer:TransferJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmit2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmit2, 0, sizeof(struct fts__transferSubmit2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmit2 * SOAP_FMAC4 soap_instantiate_fts__transferSubmit2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmit2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmit2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmit2;
		if (size)
			*size = sizeof(struct fts__transferSubmit2);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmit2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmit2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmit2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmit2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmit2 %p -> %p\n", q, p));
	*(struct fts__transferSubmit2*)p = *(struct fts__transferSubmit2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmit2Response(struct soap *soap, struct fts__transferSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmit2Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmit2Response(struct soap *soap, const struct fts__transferSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmit2Return, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmit2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmit2Response(struct soap *soap, const struct fts__transferSubmit2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmit2Response);
	if (soap_out_fts__transferSubmit2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmit2Response(struct soap *soap, const char *tag, int id, const struct fts__transferSubmit2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmit2Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmit2Return", -1, &a->_transferSubmit2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmit2Response * SOAP_FMAC4 soap_get_fts__transferSubmit2Response(struct soap *soap, struct fts__transferSubmit2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmit2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmit2Response * SOAP_FMAC4 soap_in_fts__transferSubmit2Response(struct soap *soap, const char *tag, struct fts__transferSubmit2Response *a, const char *type)
{
	size_t soap_flag__transferSubmit2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmit2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmit2Response, sizeof(struct fts__transferSubmit2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmit2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmit2Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmit2Return, "xsd:string"))
				{	soap_flag__transferSubmit2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmit2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmit2Response, 0, sizeof(struct fts__transferSubmit2Response), 0, soap_copy_fts__transferSubmit2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmit2Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmit2Response * SOAP_FMAC4 soap_instantiate_fts__transferSubmit2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmit2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmit2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmit2Response;
		if (size)
			*size = sizeof(struct fts__transferSubmit2Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmit2Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmit2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmit2Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmit2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmit2Response %p -> %p\n", q, p));
	*(struct fts__transferSubmit2Response*)p = *(struct fts__transferSubmit2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmit(struct soap *soap, struct fts__transferSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmit(struct soap *soap, const struct fts__transferSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__TransferJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmit(struct soap *soap, const struct fts__transferSubmit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmit);
	if (soap_out_fts__transferSubmit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmit(struct soap *soap, const char *tag, int id, const struct fts__transferSubmit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmit), type))
		return soap->error;
	if (soap_out_PointerTotransfer__TransferJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmit * SOAP_FMAC4 soap_get_fts__transferSubmit(struct soap *soap, struct fts__transferSubmit *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmit * SOAP_FMAC4 soap_in_fts__transferSubmit(struct soap *soap, const char *tag, struct fts__transferSubmit *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmit, sizeof(struct fts__transferSubmit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__TransferJob(soap, NULL, &a->_job, "transfer:TransferJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmit, 0, sizeof(struct fts__transferSubmit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmit * SOAP_FMAC4 soap_instantiate_fts__transferSubmit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmit;
		if (size)
			*size = sizeof(struct fts__transferSubmit);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmit %p -> %p\n", q, p));
	*(struct fts__transferSubmit*)p = *(struct fts__transferSubmit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__transferSubmitResponse(struct soap *soap, struct fts__transferSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmitReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__transferSubmitResponse(struct soap *soap, const struct fts__transferSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmitReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmitReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__transferSubmitResponse(struct soap *soap, const struct fts__transferSubmitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__transferSubmitResponse);
	if (soap_out_fts__transferSubmitResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__transferSubmitResponse(struct soap *soap, const char *tag, int id, const struct fts__transferSubmitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__transferSubmitResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmitReturn", -1, &a->_transferSubmitReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__transferSubmitResponse * SOAP_FMAC4 soap_get_fts__transferSubmitResponse(struct soap *soap, struct fts__transferSubmitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__transferSubmitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__transferSubmitResponse * SOAP_FMAC4 soap_in_fts__transferSubmitResponse(struct soap *soap, const char *tag, struct fts__transferSubmitResponse *a, const char *type)
{
	size_t soap_flag__transferSubmitReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__transferSubmitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__transferSubmitResponse, sizeof(struct fts__transferSubmitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__transferSubmitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmitReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmitReturn, "xsd:string"))
				{	soap_flag__transferSubmitReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__transferSubmitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__transferSubmitResponse, 0, sizeof(struct fts__transferSubmitResponse), 0, soap_copy_fts__transferSubmitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmitReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__transferSubmitResponse * SOAP_FMAC4 soap_instantiate_fts__transferSubmitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__transferSubmitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__transferSubmitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__transferSubmitResponse;
		if (size)
			*size = sizeof(struct fts__transferSubmitResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__transferSubmitResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__transferSubmitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__transferSubmitResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__transferSubmitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__transferSubmitResponse %p -> %p\n", q, p));
	*(struct fts__transferSubmitResponse*)p = *(struct fts__transferSubmitResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__placementSubmit2(struct soap *soap, struct fts__placementSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__placementSubmit2(struct soap *soap, const struct fts__placementSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__PlacementJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__placementSubmit2(struct soap *soap, const struct fts__placementSubmit2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__placementSubmit2);
	if (soap_out_fts__placementSubmit2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__placementSubmit2(struct soap *soap, const char *tag, int id, const struct fts__placementSubmit2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__placementSubmit2), type))
		return soap->error;
	if (soap_out_PointerTotransfer__PlacementJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__placementSubmit2 * SOAP_FMAC4 soap_get_fts__placementSubmit2(struct soap *soap, struct fts__placementSubmit2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__placementSubmit2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__placementSubmit2 * SOAP_FMAC4 soap_in_fts__placementSubmit2(struct soap *soap, const char *tag, struct fts__placementSubmit2 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__placementSubmit2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__placementSubmit2, sizeof(struct fts__placementSubmit2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__placementSubmit2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__PlacementJob(soap, NULL, &a->_job, "transfer:PlacementJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__placementSubmit2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__placementSubmit2, 0, sizeof(struct fts__placementSubmit2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__placementSubmit2 * SOAP_FMAC4 soap_instantiate_fts__placementSubmit2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__placementSubmit2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__placementSubmit2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__placementSubmit2;
		if (size)
			*size = sizeof(struct fts__placementSubmit2);
	}
	else
	{	cp->ptr = (void*)new struct fts__placementSubmit2[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__placementSubmit2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__placementSubmit2*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__placementSubmit2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__placementSubmit2 %p -> %p\n", q, p));
	*(struct fts__placementSubmit2*)p = *(struct fts__placementSubmit2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__placementSubmit2Response(struct soap *soap, struct fts__placementSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_placementSubmit2Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__placementSubmit2Response(struct soap *soap, const struct fts__placementSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_placementSubmit2Return, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_placementSubmit2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__placementSubmit2Response(struct soap *soap, const struct fts__placementSubmit2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__placementSubmit2Response);
	if (soap_out_fts__placementSubmit2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__placementSubmit2Response(struct soap *soap, const char *tag, int id, const struct fts__placementSubmit2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__placementSubmit2Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "placementSubmit2Return", -1, &a->_placementSubmit2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__placementSubmit2Response * SOAP_FMAC4 soap_get_fts__placementSubmit2Response(struct soap *soap, struct fts__placementSubmit2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__placementSubmit2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__placementSubmit2Response * SOAP_FMAC4 soap_in_fts__placementSubmit2Response(struct soap *soap, const char *tag, struct fts__placementSubmit2Response *a, const char *type)
{
	size_t soap_flag__placementSubmit2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__placementSubmit2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__placementSubmit2Response, sizeof(struct fts__placementSubmit2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__placementSubmit2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__placementSubmit2Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_placementSubmit2Return, "xsd:string"))
				{	soap_flag__placementSubmit2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__placementSubmit2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__placementSubmit2Response, 0, sizeof(struct fts__placementSubmit2Response), 0, soap_copy_fts__placementSubmit2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__placementSubmit2Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__placementSubmit2Response * SOAP_FMAC4 soap_instantiate_fts__placementSubmit2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__placementSubmit2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__placementSubmit2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__placementSubmit2Response;
		if (size)
			*size = sizeof(struct fts__placementSubmit2Response);
	}
	else
	{	cp->ptr = (void*)new struct fts__placementSubmit2Response[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__placementSubmit2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__placementSubmit2Response*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__placementSubmit2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__placementSubmit2Response %p -> %p\n", q, p));
	*(struct fts__placementSubmit2Response*)p = *(struct fts__placementSubmit2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__placementSubmit(struct soap *soap, struct fts__placementSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__placementSubmit(struct soap *soap, const struct fts__placementSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotransfer__PlacementJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__placementSubmit(struct soap *soap, const struct fts__placementSubmit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__placementSubmit);
	if (soap_out_fts__placementSubmit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__placementSubmit(struct soap *soap, const char *tag, int id, const struct fts__placementSubmit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__placementSubmit), type))
		return soap->error;
	if (soap_out_PointerTotransfer__PlacementJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__placementSubmit * SOAP_FMAC4 soap_get_fts__placementSubmit(struct soap *soap, struct fts__placementSubmit *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__placementSubmit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__placementSubmit * SOAP_FMAC4 soap_in_fts__placementSubmit(struct soap *soap, const char *tag, struct fts__placementSubmit *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__placementSubmit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts__placementSubmit, sizeof(struct fts__placementSubmit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_fts__placementSubmit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotransfer__PlacementJob(soap, NULL, &a->_job, "transfer:PlacementJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__placementSubmit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__placementSubmit, 0, sizeof(struct fts__placementSubmit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__placementSubmit * SOAP_FMAC4 soap_instantiate_fts__placementSubmit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__placementSubmit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__placementSubmit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__placementSubmit;
		if (size)
			*size = sizeof(struct fts__placementSubmit);
	}
	else
	{	cp->ptr = (void*)new struct fts__placementSubmit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__placementSubmit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__placementSubmit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__placementSubmit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__placementSubmit %p -> %p\n", q, p));
	*(struct fts__placementSubmit*)p = *(struct fts__placementSubmit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fts__placementSubmitResponse(struct soap *soap, struct fts__placementSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_placementSubmitReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fts__placementSubmitResponse(struct soap *soap, const struct fts__placementSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_placementSubmitReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_placementSubmitReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fts__placementSubmitResponse(struct soap *soap, const struct fts__placementSubmitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts__placementSubmitResponse);
	if (soap_out_fts__placementSubmitResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fts__placementSubmitResponse(struct soap *soap, const char *tag, int id, const struct fts__placementSubmitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts__placementSubmitResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "placementSubmitReturn", -1, &a->_placementSubmitReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct fts__placementSubmitResponse * SOAP_FMAC4 soap_get_fts__placementSubmitResponse(struct soap *soap, struct fts__placementSubmitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fts__placementSubmitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct fts__placementSubmitResponse * SOAP_FMAC4 soap_in_fts__placementSubmitResponse(struct soap *soap, const char *tag, struct fts__placementSubmitResponse *a, const char *type)
{
	size_t soap_flag__placementSubmitReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct fts__placementSubmitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts__placementSubmitResponse, sizeof(struct fts__placementSubmitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_fts__placementSubmitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__placementSubmitReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_placementSubmitReturn, "xsd:string"))
				{	soap_flag__placementSubmitReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct fts__placementSubmitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts__placementSubmitResponse, 0, sizeof(struct fts__placementSubmitResponse), 0, soap_copy_fts__placementSubmitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__placementSubmitReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct fts__placementSubmitResponse * SOAP_FMAC4 soap_instantiate_fts__placementSubmitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fts__placementSubmitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts__placementSubmitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct fts__placementSubmitResponse;
		if (size)
			*size = sizeof(struct fts__placementSubmitResponse);
	}
	else
	{	cp->ptr = (void*)new struct fts__placementSubmitResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct fts__placementSubmitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct fts__placementSubmitResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fts__placementSubmitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct fts__placementSubmitResponse %p -> %p\n", q, p));
	*(struct fts__placementSubmitResponse*)p = *(struct fts__placementSubmitResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__Roles(struct soap *soap, transfer__Roles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__Roles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__Roles(struct soap *soap, transfer__Roles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__Roles);
	if (soap_out_PointerTotransfer__Roles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__Roles(struct soap *soap, const char *tag, int id, transfer__Roles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__Roles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__Roles ** SOAP_FMAC4 soap_get_PointerTotransfer__Roles(struct soap *soap, transfer__Roles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__Roles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__Roles ** SOAP_FMAC4 soap_in_PointerTotransfer__Roles(struct soap *soap, const char *tag, transfer__Roles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__Roles **)soap_malloc(soap, sizeof(transfer__Roles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__Roles *)soap_instantiate_transfer__Roles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__Roles ** p = (transfer__Roles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__Roles, sizeof(transfer__Roles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJobSummary2(struct soap *soap, transfer__TransferJobSummary2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJobSummary2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJobSummary2(struct soap *soap, transfer__TransferJobSummary2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJobSummary2);
	if (soap_out_PointerTotransfer__TransferJobSummary2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJobSummary2(struct soap *soap, const char *tag, int id, transfer__TransferJobSummary2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJobSummary2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJobSummary2 ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJobSummary2(struct soap *soap, transfer__TransferJobSummary2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJobSummary2 ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJobSummary2(struct soap *soap, const char *tag, transfer__TransferJobSummary2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJobSummary2 **)soap_malloc(soap, sizeof(transfer__TransferJobSummary2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJobSummary2 *)soap_instantiate_transfer__TransferJobSummary2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJobSummary2 ** p = (transfer__TransferJobSummary2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJobSummary2, sizeof(transfer__TransferJobSummary2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJobSummary(struct soap *soap, transfer__TransferJobSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJobSummary))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJobSummary(struct soap *soap, transfer__TransferJobSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJobSummary);
	if (soap_out_PointerTotransfer__TransferJobSummary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJobSummary(struct soap *soap, const char *tag, int id, transfer__TransferJobSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJobSummary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJobSummary ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJobSummary(struct soap *soap, transfer__TransferJobSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJobSummary ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJobSummary(struct soap *soap, const char *tag, transfer__TransferJobSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJobSummary **)soap_malloc(soap, sizeof(transfer__TransferJobSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJobSummary *)soap_instantiate_transfer__TransferJobSummary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJobSummary ** p = (transfer__TransferJobSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJobSummary, sizeof(transfer__TransferJobSummary), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (transfer__TransferJobSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJobSummary2, sizeof(transfer__TransferJobSummary2), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, int id, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** SOAP_FMAC4 soap_get_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** SOAP_FMAC4 soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **)soap_malloc(soap, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** p = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, int id, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** SOAP_FMAC4 soap_get_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** SOAP_FMAC4 soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus **)soap_malloc(soap, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** p = (fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus, sizeof(fts__ArrayOf_USCOREtns3_USCOREFileTransferStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, fts__ArrayOf_USCOREsoapenc_USCOREstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, fts__ArrayOf_USCOREsoapenc_USCOREstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring);
	if (soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, int id, fts__ArrayOf_USCOREsoapenc_USCOREstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREsoapenc_USCOREstring ** SOAP_FMAC4 soap_get_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, fts__ArrayOf_USCOREsoapenc_USCOREstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 fts__ArrayOf_USCOREsoapenc_USCOREstring ** SOAP_FMAC4 soap_in_PointerTofts__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, fts__ArrayOf_USCOREsoapenc_USCOREstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fts__ArrayOf_USCOREsoapenc_USCOREstring **)soap_malloc(soap, sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fts__ArrayOf_USCOREsoapenc_USCOREstring *)soap_instantiate_fts__ArrayOf_USCOREsoapenc_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fts__ArrayOf_USCOREsoapenc_USCOREstring ** p = (fts__ArrayOf_USCOREsoapenc_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts__ArrayOf_USCOREsoapenc_USCOREstring, sizeof(fts__ArrayOf_USCOREsoapenc_USCOREstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREJobStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREJobStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, int id, fts__ArrayOf_USCOREtns3_USCOREJobStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREJobStatus ** SOAP_FMAC4 soap_get_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, fts__ArrayOf_USCOREtns3_USCOREJobStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 fts__ArrayOf_USCOREtns3_USCOREJobStatus ** SOAP_FMAC4 soap_in_PointerTofts__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, fts__ArrayOf_USCOREtns3_USCOREJobStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fts__ArrayOf_USCOREtns3_USCOREJobStatus **)soap_malloc(soap, sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fts__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_instantiate_fts__ArrayOf_USCOREtns3_USCOREJobStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fts__ArrayOf_USCOREtns3_USCOREJobStatus ** p = (fts__ArrayOf_USCOREtns3_USCOREJobStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts__ArrayOf_USCOREtns3_USCOREJobStatus, sizeof(fts__ArrayOf_USCOREtns3_USCOREJobStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJob2(struct soap *soap, transfer__TransferJob2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJob2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJob2(struct soap *soap, transfer__TransferJob2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJob2);
	if (soap_out_PointerTotransfer__TransferJob2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJob2(struct soap *soap, const char *tag, int id, transfer__TransferJob2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJob2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJob2 ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJob2(struct soap *soap, transfer__TransferJob2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJob2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJob2 ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJob2(struct soap *soap, const char *tag, transfer__TransferJob2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJob2 **)soap_malloc(soap, sizeof(transfer__TransferJob2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJob2 *)soap_instantiate_transfer__TransferJob2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJob2 ** p = (transfer__TransferJob2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJob2, sizeof(transfer__TransferJob2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJob(struct soap *soap, transfer__TransferJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJob(struct soap *soap, transfer__TransferJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJob);
	if (soap_out_PointerTotransfer__TransferJob(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJob(struct soap *soap, const char *tag, int id, transfer__TransferJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJob ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJob(struct soap *soap, transfer__TransferJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJob ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJob(struct soap *soap, const char *tag, transfer__TransferJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJob **)soap_malloc(soap, sizeof(transfer__TransferJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJob *)soap_instantiate_transfer__TransferJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJob ** p = (transfer__TransferJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJob, sizeof(transfer__TransferJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__PlacementJob(struct soap *soap, transfer__PlacementJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__PlacementJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__PlacementJob(struct soap *soap, transfer__PlacementJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__PlacementJob);
	if (soap_out_PointerTotransfer__PlacementJob(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__PlacementJob(struct soap *soap, const char *tag, int id, transfer__PlacementJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__PlacementJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__PlacementJob ** SOAP_FMAC4 soap_get_PointerTotransfer__PlacementJob(struct soap *soap, transfer__PlacementJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__PlacementJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__PlacementJob ** SOAP_FMAC4 soap_in_PointerTotransfer__PlacementJob(struct soap *soap, const char *tag, transfer__PlacementJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__PlacementJob **)soap_malloc(soap, sizeof(transfer__PlacementJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__PlacementJob *)soap_instantiate_transfer__PlacementJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__PlacementJob ** p = (transfer__PlacementJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__PlacementJob, sizeof(transfer__PlacementJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__FileTransferStatus2(struct soap *soap, transfer__FileTransferStatus2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__FileTransferStatus2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__FileTransferStatus2(struct soap *soap, transfer__FileTransferStatus2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__FileTransferStatus2);
	if (soap_out_PointerTotransfer__FileTransferStatus2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__FileTransferStatus2(struct soap *soap, const char *tag, int id, transfer__FileTransferStatus2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__FileTransferStatus2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__FileTransferStatus2 ** SOAP_FMAC4 soap_get_PointerTotransfer__FileTransferStatus2(struct soap *soap, transfer__FileTransferStatus2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__FileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__FileTransferStatus2 ** SOAP_FMAC4 soap_in_PointerTotransfer__FileTransferStatus2(struct soap *soap, const char *tag, transfer__FileTransferStatus2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__FileTransferStatus2 **)soap_malloc(soap, sizeof(transfer__FileTransferStatus2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__FileTransferStatus2 *)soap_instantiate_transfer__FileTransferStatus2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__FileTransferStatus2 ** p = (transfer__FileTransferStatus2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__FileTransferStatus2, sizeof(transfer__FileTransferStatus2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__FileTransferStatus(struct soap *soap, transfer__FileTransferStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__FileTransferStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__FileTransferStatus(struct soap *soap, transfer__FileTransferStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__FileTransferStatus);
	if (soap_out_PointerTotransfer__FileTransferStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__FileTransferStatus(struct soap *soap, const char *tag, int id, transfer__FileTransferStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__FileTransferStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__FileTransferStatus ** SOAP_FMAC4 soap_get_PointerTotransfer__FileTransferStatus(struct soap *soap, transfer__FileTransferStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__FileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__FileTransferStatus ** SOAP_FMAC4 soap_in_PointerTotransfer__FileTransferStatus(struct soap *soap, const char *tag, transfer__FileTransferStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__FileTransferStatus **)soap_malloc(soap, sizeof(transfer__FileTransferStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__FileTransferStatus *)soap_instantiate_transfer__FileTransferStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__FileTransferStatus ** p = (transfer__FileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__FileTransferStatus, sizeof(transfer__FileTransferStatus), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (transfer__FileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__FileTransferStatus2, sizeof(transfer__FileTransferStatus2), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__StringPair(struct soap *soap, transfer__StringPair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__StringPair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__StringPair(struct soap *soap, transfer__StringPair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__StringPair);
	if (soap_out_PointerTotransfer__StringPair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__StringPair(struct soap *soap, const char *tag, int id, transfer__StringPair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__StringPair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__StringPair ** SOAP_FMAC4 soap_get_PointerTotransfer__StringPair(struct soap *soap, transfer__StringPair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__StringPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__StringPair ** SOAP_FMAC4 soap_in_PointerTotransfer__StringPair(struct soap *soap, const char *tag, transfer__StringPair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__StringPair **)soap_malloc(soap, sizeof(transfer__StringPair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__StringPair *)soap_instantiate_transfer__StringPair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__StringPair ** p = (transfer__StringPair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__StringPair, sizeof(transfer__StringPair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__JobStatus(struct soap *soap, transfer__JobStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__JobStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__JobStatus(struct soap *soap, transfer__JobStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__JobStatus);
	if (soap_out_PointerTotransfer__JobStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__JobStatus(struct soap *soap, const char *tag, int id, transfer__JobStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__JobStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__JobStatus ** SOAP_FMAC4 soap_get_PointerTotransfer__JobStatus(struct soap *soap, transfer__JobStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__JobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__JobStatus ** SOAP_FMAC4 soap_in_PointerTotransfer__JobStatus(struct soap *soap, const char *tag, transfer__JobStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__JobStatus **)soap_malloc(soap, sizeof(transfer__JobStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__JobStatus *)soap_instantiate_transfer__JobStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__JobStatus ** p = (transfer__JobStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__JobStatus, sizeof(transfer__JobStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJobElement2(struct soap *soap, transfer__TransferJobElement2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJobElement2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJobElement2(struct soap *soap, transfer__TransferJobElement2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJobElement2);
	if (soap_out_PointerTotransfer__TransferJobElement2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJobElement2(struct soap *soap, const char *tag, int id, transfer__TransferJobElement2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJobElement2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJobElement2 ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJobElement2(struct soap *soap, transfer__TransferJobElement2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJobElement2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJobElement2 ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJobElement2(struct soap *soap, const char *tag, transfer__TransferJobElement2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJobElement2 **)soap_malloc(soap, sizeof(transfer__TransferJobElement2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJobElement2 *)soap_instantiate_transfer__TransferJobElement2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJobElement2 ** p = (transfer__TransferJobElement2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJobElement2, sizeof(transfer__TransferJobElement2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferJobElement(struct soap *soap, transfer__TransferJobElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferJobElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferJobElement(struct soap *soap, transfer__TransferJobElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferJobElement);
	if (soap_out_PointerTotransfer__TransferJobElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferJobElement(struct soap *soap, const char *tag, int id, transfer__TransferJobElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferJobElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferJobElement ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferJobElement(struct soap *soap, transfer__TransferJobElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferJobElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferJobElement ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferJobElement(struct soap *soap, const char *tag, transfer__TransferJobElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferJobElement **)soap_malloc(soap, sizeof(transfer__TransferJobElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferJobElement *)soap_instantiate_transfer__TransferJobElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferJobElement ** p = (transfer__TransferJobElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferJobElement, sizeof(transfer__TransferJobElement), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotransfer__TransferParams(struct soap *soap, transfer__TransferParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_transfer__TransferParams))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotransfer__TransferParams(struct soap *soap, transfer__TransferParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotransfer__TransferParams);
	if (soap_out_PointerTotransfer__TransferParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotransfer__TransferParams(struct soap *soap, const char *tag, int id, transfer__TransferParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_transfer__TransferParams);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 transfer__TransferParams ** SOAP_FMAC4 soap_get_PointerTotransfer__TransferParams(struct soap *soap, transfer__TransferParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotransfer__TransferParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 transfer__TransferParams ** SOAP_FMAC4 soap_in_PointerTotransfer__TransferParams(struct soap *soap, const char *tag, transfer__TransferParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (transfer__TransferParams **)soap_malloc(soap, sizeof(transfer__TransferParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (transfer__TransferParams *)soap_instantiate_transfer__TransferParams(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	transfer__TransferParams ** p = (transfer__TransferParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_transfer__TransferParams, sizeof(transfer__TransferParams), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, std::vector<transfer__FileTransferStatus2 * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, const std::vector<transfer__FileTransferStatus2 * >*a)
{
	for (std::vector<transfer__FileTransferStatus2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__FileTransferStatus2(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, const char *tag, int id, const std::vector<transfer__FileTransferStatus2 * >*a, const char *type)
{
	for (std::vector<transfer__FileTransferStatus2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__FileTransferStatus2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__FileTransferStatus2 * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, const char *tag, std::vector<transfer__FileTransferStatus2 * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(soap, -1)))
		return NULL;
	transfer__FileTransferStatus2 *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__FileTransferStatus2, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2, sizeof(transfer__FileTransferStatus2), 1))
				break;
			if (!soap_in_PointerTotransfer__FileTransferStatus2(soap, tag, NULL, "transfer:FileTransferStatus2"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__FileTransferStatus2(soap, tag, &n, "transfer:FileTransferStatus2"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__FileTransferStatus2 * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__FileTransferStatus2 * >;
		if (size)
			*size = sizeof(std::vector<transfer__FileTransferStatus2 * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__FileTransferStatus2 * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__FileTransferStatus2 * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__FileTransferStatus2 * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__FileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__FileTransferStatus2 * > %p -> %p\n", q, p));
	*(std::vector<transfer__FileTransferStatus2 * >*)p = *(std::vector<transfer__FileTransferStatus2 * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, std::vector<transfer__FileTransferStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, const std::vector<transfer__FileTransferStatus * >*a)
{
	for (std::vector<transfer__FileTransferStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__FileTransferStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, const char *tag, int id, const std::vector<transfer__FileTransferStatus * >*a, const char *type)
{
	for (std::vector<transfer__FileTransferStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__FileTransferStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__FileTransferStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, const char *tag, std::vector<transfer__FileTransferStatus * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(soap, -1)))
		return NULL;
	transfer__FileTransferStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__FileTransferStatus, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus, sizeof(transfer__FileTransferStatus), 1))
				break;
			if (!soap_in_PointerTotransfer__FileTransferStatus(soap, tag, NULL, "transfer:FileTransferStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__FileTransferStatus(soap, tag, &n, "transfer:FileTransferStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__FileTransferStatus * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__FileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__FileTransferStatus * >;
		if (size)
			*size = sizeof(std::vector<transfer__FileTransferStatus * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__FileTransferStatus * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__FileTransferStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__FileTransferStatus * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__FileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__FileTransferStatus * > %p -> %p\n", q, p));
	*(std::vector<transfer__FileTransferStatus * >*)p = *(std::vector<transfer__FileTransferStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, std::vector<transfer__JobStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, const std::vector<transfer__JobStatus * >*a)
{
	for (std::vector<transfer__JobStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__JobStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, const char *tag, int id, const std::vector<transfer__JobStatus * >*a, const char *type)
{
	for (std::vector<transfer__JobStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__JobStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__JobStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, const char *tag, std::vector<transfer__JobStatus * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__JobStatus(soap, -1)))
		return NULL;
	transfer__JobStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__JobStatus, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__JobStatus, sizeof(transfer__JobStatus), 1))
				break;
			if (!soap_in_PointerTotransfer__JobStatus(soap, tag, NULL, "transfer:JobStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__JobStatus(soap, tag, &n, "transfer:JobStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__JobStatus * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__JobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__JobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__JobStatus * >;
		if (size)
			*size = sizeof(std::vector<transfer__JobStatus * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__JobStatus * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__JobStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__JobStatus * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__JobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__JobStatus * > %p -> %p\n", q, p));
	*(std::vector<transfer__JobStatus * >*)p = *(std::vector<transfer__JobStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, std::vector<transfer__StringPair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, const std::vector<transfer__StringPair * >*a)
{
	for (std::vector<transfer__StringPair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__StringPair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, const char *tag, int id, const std::vector<transfer__StringPair * >*a, const char *type)
{
	for (std::vector<transfer__StringPair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__StringPair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__StringPair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, const char *tag, std::vector<transfer__StringPair * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__StringPair(soap, -1)))
		return NULL;
	transfer__StringPair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__StringPair, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__StringPair, sizeof(transfer__StringPair), 1))
				break;
			if (!soap_in_PointerTotransfer__StringPair(soap, tag, NULL, "transfer:StringPair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__StringPair(soap, tag, &n, "transfer:StringPair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__StringPair * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__StringPair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__StringPair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__StringPair * >;
		if (size)
			*size = sizeof(std::vector<transfer__StringPair * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__StringPair * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__StringPair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__StringPair * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__StringPair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__StringPair * > %p -> %p\n", q, p));
	*(std::vector<transfer__StringPair * >*)p = *(std::vector<transfer__StringPair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, std::vector<transfer__TransferJobElement2 * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, const std::vector<transfer__TransferJobElement2 * >*a)
{
	for (std::vector<transfer__TransferJobElement2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__TransferJobElement2(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, const char *tag, int id, const std::vector<transfer__TransferJobElement2 * >*a, const char *type)
{
	for (std::vector<transfer__TransferJobElement2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__TransferJobElement2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__TransferJobElement2 * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, const char *tag, std::vector<transfer__TransferJobElement2 * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(soap, -1)))
		return NULL;
	transfer__TransferJobElement2 *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__TransferJobElement2, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement2, sizeof(transfer__TransferJobElement2), 1))
				break;
			if (!soap_in_PointerTotransfer__TransferJobElement2(soap, tag, NULL, "transfer:TransferJobElement2"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__TransferJobElement2(soap, tag, &n, "transfer:TransferJobElement2"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__TransferJobElement2 * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__TransferJobElement2 * >;
		if (size)
			*size = sizeof(std::vector<transfer__TransferJobElement2 * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__TransferJobElement2 * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__TransferJobElement2 * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__TransferJobElement2 * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__TransferJobElement2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__TransferJobElement2 * > %p -> %p\n", q, p));
	*(std::vector<transfer__TransferJobElement2 * >*)p = *(std::vector<transfer__TransferJobElement2 * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, std::vector<transfer__TransferJobElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, const std::vector<transfer__TransferJobElement * >*a)
{
	for (std::vector<transfer__TransferJobElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotransfer__TransferJobElement(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, const char *tag, int id, const std::vector<transfer__TransferJobElement * >*a, const char *type)
{
	for (std::vector<transfer__TransferJobElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotransfer__TransferJobElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<transfer__TransferJobElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, const char *tag, std::vector<transfer__TransferJobElement * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotransfer__TransferJobElement(soap, -1)))
		return NULL;
	transfer__TransferJobElement *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_transfer__TransferJobElement, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement, sizeof(transfer__TransferJobElement), 1))
				break;
			if (!soap_in_PointerTotransfer__TransferJobElement(soap, tag, NULL, "transfer:TransferJobElement"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotransfer__TransferJobElement(soap, tag, &n, "transfer:TransferJobElement"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<transfer__TransferJobElement * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotransfer__TransferJobElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTotransfer__TransferJobElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<transfer__TransferJobElement * >;
		if (size)
			*size = sizeof(std::vector<transfer__TransferJobElement * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<transfer__TransferJobElement * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<transfer__TransferJobElement * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<transfer__TransferJobElement * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotransfer__TransferJobElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<transfer__TransferJobElement * > %p -> %p\n", q, p));
	*(std::vector<transfer__TransferJobElement * >*)p = *(std::vector<transfer__TransferJobElement * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of ftsC.cpp */
