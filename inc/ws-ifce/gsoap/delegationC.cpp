/* delegationC.cpp
   Generated by gSOAP 2.7.16 from /home/simonm/tmp/build/src/ws-ifce/gsoap/delegation_interface.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "delegationH.h"

SOAP_SOURCE_STAMP("@(#) delegationC.cpp ver 2.7.16 2012-06-22 11:35:11 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_delegation__NewProxyReq:
		return soap_in_delegation__NewProxyReq(soap, NULL, NULL, "delegation:NewProxyReq");
	case SOAP_TYPE_delegation__destroy:
		return soap_in_delegation__destroy(soap, NULL, NULL, "delegation:destroy");
	case SOAP_TYPE_delegation__destroyResponse:
		return soap_in_delegation__destroyResponse(soap, NULL, NULL, "delegation:destroyResponse");
	case SOAP_TYPE_delegation__getTerminationTime:
		return soap_in_delegation__getTerminationTime(soap, NULL, NULL, "delegation:getTerminationTime");
	case SOAP_TYPE_delegation__getTerminationTimeResponse:
		return soap_in_delegation__getTerminationTimeResponse(soap, NULL, NULL, "delegation:getTerminationTimeResponse");
	case SOAP_TYPE_delegation__putProxy:
		return soap_in_delegation__putProxy(soap, NULL, NULL, "delegation:putProxy");
	case SOAP_TYPE_delegation__putProxyResponse:
		return soap_in_delegation__putProxyResponse(soap, NULL, NULL, "delegation:putProxyResponse");
	case SOAP_TYPE_delegation__renewProxyReq:
		return soap_in_delegation__renewProxyReq(soap, NULL, NULL, "delegation:renewProxyReq");
	case SOAP_TYPE_delegation__renewProxyReqResponse:
		return soap_in_delegation__renewProxyReqResponse(soap, NULL, NULL, "delegation:renewProxyReqResponse");
	case SOAP_TYPE_delegation__getNewProxyReq:
		return soap_in_delegation__getNewProxyReq(soap, NULL, NULL, "delegation:getNewProxyReq");
	case SOAP_TYPE_delegation__getNewProxyReqResponse:
		return soap_in_delegation__getNewProxyReqResponse(soap, NULL, NULL, "delegation:getNewProxyReqResponse");
	case SOAP_TYPE_delegation__getProxyReq:
		return soap_in_delegation__getProxyReq(soap, NULL, NULL, "delegation:getProxyReq");
	case SOAP_TYPE_delegation__getProxyReqResponse:
		return soap_in_delegation__getProxyReqResponse(soap, NULL, NULL, "delegation:getProxyReqResponse");
	case SOAP_TYPE_delegation__getServiceMetadata:
		return soap_in_delegation__getServiceMetadata(soap, NULL, NULL, "delegation:getServiceMetadata");
	case SOAP_TYPE_delegation__getServiceMetadataResponse:
		return soap_in_delegation__getServiceMetadataResponse(soap, NULL, NULL, "delegation:getServiceMetadataResponse");
	case SOAP_TYPE_delegation__getInterfaceVersion:
		return soap_in_delegation__getInterfaceVersion(soap, NULL, NULL, "delegation:getInterfaceVersion");
	case SOAP_TYPE_delegation__getInterfaceVersionResponse:
		return soap_in_delegation__getInterfaceVersionResponse(soap, NULL, NULL, "delegation:getInterfaceVersionResponse");
	case SOAP_TYPE_delegation__getVersion:
		return soap_in_delegation__getVersion(soap, NULL, NULL, "delegation:getVersion");
	case SOAP_TYPE_delegation__getVersionResponse:
		return soap_in_delegation__getVersionResponse(soap, NULL, NULL, "delegation:getVersionResponse");
	case SOAP_TYPE_PointerTodelegation__NewProxyReq:
		return soap_in_PointerTodelegation__NewProxyReq(soap, NULL, NULL, "delegation:NewProxyReq");
	case SOAP_TYPE_PointerTo_delegation__DelegationException:
		return soap_in_PointerTo_delegation__DelegationException(soap, NULL, NULL, "delegation:DelegationException");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:NewProxyReq"))
		{	*type = SOAP_TYPE_delegation__NewProxyReq;
			return soap_in_delegation__NewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:destroy"))
		{	*type = SOAP_TYPE_delegation__destroy;
			return soap_in_delegation__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:destroyResponse"))
		{	*type = SOAP_TYPE_delegation__destroyResponse;
			return soap_in_delegation__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getTerminationTime"))
		{	*type = SOAP_TYPE_delegation__getTerminationTime;
			return soap_in_delegation__getTerminationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getTerminationTimeResponse"))
		{	*type = SOAP_TYPE_delegation__getTerminationTimeResponse;
			return soap_in_delegation__getTerminationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:putProxy"))
		{	*type = SOAP_TYPE_delegation__putProxy;
			return soap_in_delegation__putProxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:putProxyResponse"))
		{	*type = SOAP_TYPE_delegation__putProxyResponse;
			return soap_in_delegation__putProxyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:renewProxyReq"))
		{	*type = SOAP_TYPE_delegation__renewProxyReq;
			return soap_in_delegation__renewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:renewProxyReqResponse"))
		{	*type = SOAP_TYPE_delegation__renewProxyReqResponse;
			return soap_in_delegation__renewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getNewProxyReq"))
		{	*type = SOAP_TYPE_delegation__getNewProxyReq;
			return soap_in_delegation__getNewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getNewProxyReqResponse"))
		{	*type = SOAP_TYPE_delegation__getNewProxyReqResponse;
			return soap_in_delegation__getNewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getProxyReq"))
		{	*type = SOAP_TYPE_delegation__getProxyReq;
			return soap_in_delegation__getProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getProxyReqResponse"))
		{	*type = SOAP_TYPE_delegation__getProxyReqResponse;
			return soap_in_delegation__getProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getServiceMetadata"))
		{	*type = SOAP_TYPE_delegation__getServiceMetadata;
			return soap_in_delegation__getServiceMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getServiceMetadataResponse"))
		{	*type = SOAP_TYPE_delegation__getServiceMetadataResponse;
			return soap_in_delegation__getServiceMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getInterfaceVersion"))
		{	*type = SOAP_TYPE_delegation__getInterfaceVersion;
			return soap_in_delegation__getInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_delegation__getInterfaceVersionResponse;
			return soap_in_delegation__getInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getVersion"))
		{	*type = SOAP_TYPE_delegation__getVersion;
			return soap_in_delegation__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getVersionResponse"))
		{	*type = SOAP_TYPE_delegation__getVersionResponse;
			return soap_in_delegation__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "delegation:DelegationException"))
		{	*type = SOAP_TYPE__delegation__DelegationException;
			return soap_in__delegation__DelegationException(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__delegation__DelegationException:
		return ((_delegation__DelegationException *)ptr)->soap_out(soap, "delegation:DelegationException", id, NULL);
	case SOAP_TYPE_delegation__NewProxyReq:
		return ((delegation__NewProxyReq *)ptr)->soap_out(soap, tag, id, "delegation:NewProxyReq");
	case SOAP_TYPE_delegation__destroy:
		return soap_out_delegation__destroy(soap, tag, id, (const struct delegation__destroy *)ptr, "delegation:destroy");
	case SOAP_TYPE_delegation__destroyResponse:
		return soap_out_delegation__destroyResponse(soap, tag, id, (const struct delegation__destroyResponse *)ptr, "delegation:destroyResponse");
	case SOAP_TYPE_delegation__getTerminationTime:
		return soap_out_delegation__getTerminationTime(soap, tag, id, (const struct delegation__getTerminationTime *)ptr, "delegation:getTerminationTime");
	case SOAP_TYPE_delegation__getTerminationTimeResponse:
		return soap_out_delegation__getTerminationTimeResponse(soap, tag, id, (const struct delegation__getTerminationTimeResponse *)ptr, "delegation:getTerminationTimeResponse");
	case SOAP_TYPE_delegation__putProxy:
		return soap_out_delegation__putProxy(soap, tag, id, (const struct delegation__putProxy *)ptr, "delegation:putProxy");
	case SOAP_TYPE_delegation__putProxyResponse:
		return soap_out_delegation__putProxyResponse(soap, tag, id, (const struct delegation__putProxyResponse *)ptr, "delegation:putProxyResponse");
	case SOAP_TYPE_delegation__renewProxyReq:
		return soap_out_delegation__renewProxyReq(soap, tag, id, (const struct delegation__renewProxyReq *)ptr, "delegation:renewProxyReq");
	case SOAP_TYPE_delegation__renewProxyReqResponse:
		return soap_out_delegation__renewProxyReqResponse(soap, tag, id, (const struct delegation__renewProxyReqResponse *)ptr, "delegation:renewProxyReqResponse");
	case SOAP_TYPE_delegation__getNewProxyReq:
		return soap_out_delegation__getNewProxyReq(soap, tag, id, (const struct delegation__getNewProxyReq *)ptr, "delegation:getNewProxyReq");
	case SOAP_TYPE_delegation__getNewProxyReqResponse:
		return soap_out_delegation__getNewProxyReqResponse(soap, tag, id, (const struct delegation__getNewProxyReqResponse *)ptr, "delegation:getNewProxyReqResponse");
	case SOAP_TYPE_delegation__getProxyReq:
		return soap_out_delegation__getProxyReq(soap, tag, id, (const struct delegation__getProxyReq *)ptr, "delegation:getProxyReq");
	case SOAP_TYPE_delegation__getProxyReqResponse:
		return soap_out_delegation__getProxyReqResponse(soap, tag, id, (const struct delegation__getProxyReqResponse *)ptr, "delegation:getProxyReqResponse");
	case SOAP_TYPE_delegation__getServiceMetadata:
		return soap_out_delegation__getServiceMetadata(soap, tag, id, (const struct delegation__getServiceMetadata *)ptr, "delegation:getServiceMetadata");
	case SOAP_TYPE_delegation__getServiceMetadataResponse:
		return soap_out_delegation__getServiceMetadataResponse(soap, tag, id, (const struct delegation__getServiceMetadataResponse *)ptr, "delegation:getServiceMetadataResponse");
	case SOAP_TYPE_delegation__getInterfaceVersion:
		return soap_out_delegation__getInterfaceVersion(soap, tag, id, (const struct delegation__getInterfaceVersion *)ptr, "delegation:getInterfaceVersion");
	case SOAP_TYPE_delegation__getInterfaceVersionResponse:
		return soap_out_delegation__getInterfaceVersionResponse(soap, tag, id, (const struct delegation__getInterfaceVersionResponse *)ptr, "delegation:getInterfaceVersionResponse");
	case SOAP_TYPE_delegation__getVersion:
		return soap_out_delegation__getVersion(soap, tag, id, (const struct delegation__getVersion *)ptr, "delegation:getVersion");
	case SOAP_TYPE_delegation__getVersionResponse:
		return soap_out_delegation__getVersionResponse(soap, tag, id, (const struct delegation__getVersionResponse *)ptr, "delegation:getVersionResponse");
	case SOAP_TYPE_PointerTodelegation__NewProxyReq:
		return soap_out_PointerTodelegation__NewProxyReq(soap, tag, id, (delegation__NewProxyReq *const*)ptr, "delegation:NewProxyReq");
	case SOAP_TYPE_PointerTo_delegation__DelegationException:
		return soap_out_PointerTo_delegation__DelegationException(soap, tag, id, (_delegation__DelegationException *const*)ptr, "delegation:DelegationException");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__delegation__DelegationException:
		((_delegation__DelegationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_delegation__NewProxyReq:
		((delegation__NewProxyReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_delegation__destroy:
		soap_serialize_delegation__destroy(soap, (const struct delegation__destroy *)ptr);
		break;
	case SOAP_TYPE_delegation__destroyResponse:
		soap_serialize_delegation__destroyResponse(soap, (const struct delegation__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getTerminationTime:
		soap_serialize_delegation__getTerminationTime(soap, (const struct delegation__getTerminationTime *)ptr);
		break;
	case SOAP_TYPE_delegation__getTerminationTimeResponse:
		soap_serialize_delegation__getTerminationTimeResponse(soap, (const struct delegation__getTerminationTimeResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__putProxy:
		soap_serialize_delegation__putProxy(soap, (const struct delegation__putProxy *)ptr);
		break;
	case SOAP_TYPE_delegation__putProxyResponse:
		soap_serialize_delegation__putProxyResponse(soap, (const struct delegation__putProxyResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__renewProxyReq:
		soap_serialize_delegation__renewProxyReq(soap, (const struct delegation__renewProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegation__renewProxyReqResponse:
		soap_serialize_delegation__renewProxyReqResponse(soap, (const struct delegation__renewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getNewProxyReq:
		soap_serialize_delegation__getNewProxyReq(soap, (const struct delegation__getNewProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegation__getNewProxyReqResponse:
		soap_serialize_delegation__getNewProxyReqResponse(soap, (const struct delegation__getNewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getProxyReq:
		soap_serialize_delegation__getProxyReq(soap, (const struct delegation__getProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegation__getProxyReqResponse:
		soap_serialize_delegation__getProxyReqResponse(soap, (const struct delegation__getProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getServiceMetadata:
		soap_serialize_delegation__getServiceMetadata(soap, (const struct delegation__getServiceMetadata *)ptr);
		break;
	case SOAP_TYPE_delegation__getServiceMetadataResponse:
		soap_serialize_delegation__getServiceMetadataResponse(soap, (const struct delegation__getServiceMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getInterfaceVersion:
		soap_serialize_delegation__getInterfaceVersion(soap, (const struct delegation__getInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_delegation__getInterfaceVersionResponse:
		soap_serialize_delegation__getInterfaceVersionResponse(soap, (const struct delegation__getInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_delegation__getVersion:
		soap_serialize_delegation__getVersion(soap, (const struct delegation__getVersion *)ptr);
		break;
	case SOAP_TYPE_delegation__getVersionResponse:
		soap_serialize_delegation__getVersionResponse(soap, (const struct delegation__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTodelegation__NewProxyReq:
		soap_serialize_PointerTodelegation__NewProxyReq(soap, (delegation__NewProxyReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_delegation__DelegationException:
		soap_serialize_PointerTo_delegation__DelegationException(soap, (_delegation__DelegationException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__NewProxyReq:
		return (void*)soap_instantiate_delegation__NewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE__delegation__DelegationException:
		return (void*)soap_instantiate__delegation__DelegationException(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_delegation__getVersionResponse:
		return (void*)soap_instantiate_delegation__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getVersion:
		return (void*)soap_instantiate_delegation__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getInterfaceVersionResponse:
		return (void*)soap_instantiate_delegation__getInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getInterfaceVersion:
		return (void*)soap_instantiate_delegation__getInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getServiceMetadataResponse:
		return (void*)soap_instantiate_delegation__getServiceMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getServiceMetadata:
		return (void*)soap_instantiate_delegation__getServiceMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getProxyReqResponse:
		return (void*)soap_instantiate_delegation__getProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getProxyReq:
		return (void*)soap_instantiate_delegation__getProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getNewProxyReqResponse:
		return (void*)soap_instantiate_delegation__getNewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getNewProxyReq:
		return (void*)soap_instantiate_delegation__getNewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__renewProxyReqResponse:
		return (void*)soap_instantiate_delegation__renewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__renewProxyReq:
		return (void*)soap_instantiate_delegation__renewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__putProxyResponse:
		return (void*)soap_instantiate_delegation__putProxyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__putProxy:
		return (void*)soap_instantiate_delegation__putProxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getTerminationTimeResponse:
		return (void*)soap_instantiate_delegation__getTerminationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__getTerminationTime:
		return (void*)soap_instantiate_delegation__getTerminationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__destroyResponse:
		return (void*)soap_instantiate_delegation__destroyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation__destroy:
		return (void*)soap_instantiate_delegation__destroy(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_delegation__NewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((delegation__NewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((delegation__NewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE__delegation__DelegationException:
		if (p->size < 0)
			SOAP_DELETE((_delegation__DelegationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_delegation__DelegationException*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getInterfaceVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getInterfaceVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getInterfaceVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getInterfaceVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getInterfaceVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getInterfaceVersion*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getServiceMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getServiceMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getServiceMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getServiceMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getServiceMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getServiceMetadata*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getNewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getNewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getNewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getNewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getNewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getNewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegation__renewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__renewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__renewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__renewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__renewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__renewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegation__putProxyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__putProxyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__putProxyResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__putProxy:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__putProxy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__putProxy*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getTerminationTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getTerminationTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getTerminationTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__getTerminationTime:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getTerminationTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getTerminationTime*)p->ptr);
		break;
	case SOAP_TYPE_delegation__destroyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__destroyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__destroyResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation__destroy:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__destroy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__destroy*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _delegation__DelegationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_delegation__DelegationException::msg = NULL;
	/* transient soap skipped */
}

void _delegation__DelegationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_delegation__DelegationException::msg);
	/* transient soap skipped */
}

int _delegation__DelegationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__delegation__DelegationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__delegation__DelegationException(struct soap *soap, const char *tag, int id, const _delegation__DelegationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__delegation__DelegationException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_delegation__DelegationException::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_delegation__DelegationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__delegation__DelegationException(soap, tag, this, type);
}

SOAP_FMAC3 _delegation__DelegationException * SOAP_FMAC4 soap_in__delegation__DelegationException(struct soap *soap, const char *tag, _delegation__DelegationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_delegation__DelegationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__delegation__DelegationException, sizeof(_delegation__DelegationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__delegation__DelegationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_delegation__DelegationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_delegation__DelegationException::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_delegation__DelegationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__delegation__DelegationException, 0, sizeof(_delegation__DelegationException), 0, soap_copy__delegation__DelegationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _delegation__DelegationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__delegation__DelegationException);
	if (this->soap_out(soap, tag?tag:"delegation:DelegationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_delegation__DelegationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__delegation__DelegationException(soap, this, tag, type);
}

SOAP_FMAC3 _delegation__DelegationException * SOAP_FMAC4 soap_get__delegation__DelegationException(struct soap *soap, _delegation__DelegationException *p, const char *tag, const char *type)
{
	if ((p = soap_in__delegation__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _delegation__DelegationException * SOAP_FMAC2 soap_instantiate__delegation__DelegationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__delegation__DelegationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__delegation__DelegationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_delegation__DelegationException);
		if (size)
			*size = sizeof(_delegation__DelegationException);
		((_delegation__DelegationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_delegation__DelegationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_delegation__DelegationException);
		for (int i = 0; i < n; i++)
			((_delegation__DelegationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_delegation__DelegationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__delegation__DelegationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _delegation__DelegationException %p -> %p\n", q, p));
	*(_delegation__DelegationException*)p = *(_delegation__DelegationException*)q;
}

void delegation__NewProxyReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->delegation__NewProxyReq::proxyRequest = NULL;
	this->delegation__NewProxyReq::delegationID = NULL;
	/* transient soap skipped */
}

void delegation__NewProxyReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->delegation__NewProxyReq::proxyRequest);
	soap_serialize_PointerTostd__string(soap, &this->delegation__NewProxyReq::delegationID);
	/* transient soap skipped */
}

int delegation__NewProxyReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_delegation__NewProxyReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__NewProxyReq(struct soap *soap, const char *tag, int id, const delegation__NewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__NewProxyReq), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "proxyRequest", -1, &(a->delegation__NewProxyReq::proxyRequest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "delegationID", -1, &(a->delegation__NewProxyReq::delegationID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *delegation__NewProxyReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_delegation__NewProxyReq(soap, tag, this, type);
}

SOAP_FMAC3 delegation__NewProxyReq * SOAP_FMAC4 soap_in_delegation__NewProxyReq(struct soap *soap, const char *tag, delegation__NewProxyReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (delegation__NewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__NewProxyReq, sizeof(delegation__NewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_delegation__NewProxyReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (delegation__NewProxyReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_proxyRequest1 = 1;
	size_t soap_flag_delegationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_proxyRequest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "proxyRequest", &(a->delegation__NewProxyReq::proxyRequest), "xsd:string"))
				{	soap_flag_proxyRequest1--;
					continue;
				}
			if (soap_flag_delegationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "delegationID", &(a->delegation__NewProxyReq::delegationID), "xsd:string"))
				{	soap_flag_delegationID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (delegation__NewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__NewProxyReq, 0, sizeof(delegation__NewProxyReq), 0, soap_copy_delegation__NewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int delegation__NewProxyReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_delegation__NewProxyReq);
	if (this->soap_out(soap, tag?tag:"delegation:NewProxyReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *delegation__NewProxyReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_delegation__NewProxyReq(soap, this, tag, type);
}

SOAP_FMAC3 delegation__NewProxyReq * SOAP_FMAC4 soap_get_delegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 delegation__NewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__NewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__NewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__NewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(delegation__NewProxyReq);
		if (size)
			*size = sizeof(delegation__NewProxyReq);
		((delegation__NewProxyReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(delegation__NewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(delegation__NewProxyReq);
		for (int i = 0; i < n; i++)
			((delegation__NewProxyReq*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (delegation__NewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__NewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying delegation__NewProxyReq %p -> %p\n", q, p));
	*(delegation__NewProxyReq*)p = *(delegation__NewProxyReq*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__destroy(struct soap *soap, struct delegation__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__destroy(struct soap *soap, const struct delegation__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__destroy(struct soap *soap, const char *tag, int id, const struct delegation__destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__destroy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__destroy * SOAP_FMAC4 soap_in_delegation__destroy(struct soap *soap, const char *tag, struct delegation__destroy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__destroy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__destroy, sizeof(struct delegation__destroy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__destroy, 0, sizeof(struct delegation__destroy), 0, soap_copy_delegation__destroy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__destroy(struct soap *soap, const struct delegation__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__destroy);
	if (soap_out_delegation__destroy(soap, tag?tag:"delegation:destroy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__destroy * SOAP_FMAC4 soap_get_delegation__destroy(struct soap *soap, struct delegation__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__destroy * SOAP_FMAC2 soap_instantiate_delegation__destroy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__destroy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__destroy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroy);
		if (size)
			*size = sizeof(struct delegation__destroy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__destroy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__destroy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__destroy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__destroy %p -> %p\n", q, p));
	*(struct delegation__destroy*)p = *(struct delegation__destroy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__destroyResponse(struct soap *soap, struct delegation__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__destroyResponse(struct soap *soap, const struct delegation__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__destroyResponse(struct soap *soap, const char *tag, int id, const struct delegation__destroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__destroyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__destroyResponse * SOAP_FMAC4 soap_in_delegation__destroyResponse(struct soap *soap, const char *tag, struct delegation__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__destroyResponse, sizeof(struct delegation__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__destroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__destroyResponse, 0, sizeof(struct delegation__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__destroyResponse(struct soap *soap, const struct delegation__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__destroyResponse);
	if (soap_out_delegation__destroyResponse(soap, tag?tag:"delegation:destroyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__destroyResponse * SOAP_FMAC4 soap_get_delegation__destroyResponse(struct soap *soap, struct delegation__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__destroyResponse * SOAP_FMAC2 soap_instantiate_delegation__destroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__destroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__destroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroyResponse);
		if (size)
			*size = sizeof(struct delegation__destroyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__destroyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__destroyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__destroyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__destroyResponse %p -> %p\n", q, p));
	*(struct delegation__destroyResponse*)p = *(struct delegation__destroyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getTerminationTime(struct soap *soap, struct delegation__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getTerminationTime(struct soap *soap, const struct delegation__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getTerminationTime(struct soap *soap, const char *tag, int id, const struct delegation__getTerminationTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getTerminationTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getTerminationTime * SOAP_FMAC4 soap_in_delegation__getTerminationTime(struct soap *soap, const char *tag, struct delegation__getTerminationTime *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getTerminationTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getTerminationTime, sizeof(struct delegation__getTerminationTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getTerminationTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getTerminationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getTerminationTime, 0, sizeof(struct delegation__getTerminationTime), 0, soap_copy_delegation__getTerminationTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getTerminationTime(struct soap *soap, const struct delegation__getTerminationTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getTerminationTime);
	if (soap_out_delegation__getTerminationTime(soap, tag?tag:"delegation:getTerminationTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getTerminationTime * SOAP_FMAC4 soap_get_delegation__getTerminationTime(struct soap *soap, struct delegation__getTerminationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getTerminationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getTerminationTime * SOAP_FMAC2 soap_instantiate_delegation__getTerminationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getTerminationTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getTerminationTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTime);
		if (size)
			*size = sizeof(struct delegation__getTerminationTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getTerminationTime);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getTerminationTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getTerminationTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getTerminationTime %p -> %p\n", q, p));
	*(struct delegation__getTerminationTime*)p = *(struct delegation__getTerminationTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getTerminationTimeResponse(struct soap *soap, struct delegation__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->_getTerminationTimeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getTerminationTimeResponse(struct soap *soap, const struct delegation__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getTerminationTimeResponse(struct soap *soap, const char *tag, int id, const struct delegation__getTerminationTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getTerminationTimeResponse), type))
		return soap->error;
	if (soap_out_time(soap, "getTerminationTimeReturn", -1, &a->_getTerminationTimeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getTerminationTimeResponse * SOAP_FMAC4 soap_in_delegation__getTerminationTimeResponse(struct soap *soap, const char *tag, struct delegation__getTerminationTimeResponse *a, const char *type)
{
	size_t soap_flag__getTerminationTimeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getTerminationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getTerminationTimeResponse, sizeof(struct delegation__getTerminationTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getTerminationTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTerminationTimeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_getTerminationTimeReturn, "xsd:dateTime"))
				{	soap_flag__getTerminationTimeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getTerminationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getTerminationTimeResponse, 0, sizeof(struct delegation__getTerminationTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getTerminationTimeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getTerminationTimeResponse(struct soap *soap, const struct delegation__getTerminationTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getTerminationTimeResponse);
	if (soap_out_delegation__getTerminationTimeResponse(soap, tag?tag:"delegation:getTerminationTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getTerminationTimeResponse * SOAP_FMAC4 soap_get_delegation__getTerminationTimeResponse(struct soap *soap, struct delegation__getTerminationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getTerminationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getTerminationTimeResponse * SOAP_FMAC2 soap_instantiate_delegation__getTerminationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getTerminationTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getTerminationTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTimeResponse);
		if (size)
			*size = sizeof(struct delegation__getTerminationTimeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getTerminationTimeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getTerminationTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getTerminationTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getTerminationTimeResponse %p -> %p\n", q, p));
	*(struct delegation__getTerminationTimeResponse*)p = *(struct delegation__getTerminationTimeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__putProxy(struct soap *soap, struct delegation__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
	soap_default_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__putProxy(struct soap *soap, const struct delegation__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
	soap_embedded(soap, &a->_proxy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__putProxy(struct soap *soap, const char *tag, int id, const struct delegation__putProxy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__putProxy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "proxy", -1, &a->_proxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__putProxy * SOAP_FMAC4 soap_in_delegation__putProxy(struct soap *soap, const char *tag, struct delegation__putProxy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	size_t soap_flag__proxy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__putProxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__putProxy, sizeof(struct delegation__putProxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__putProxy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap_flag__proxy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_proxy, "xsd:string"))
				{	soap_flag__proxy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__putProxy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__putProxy, 0, sizeof(struct delegation__putProxy), 0, soap_copy_delegation__putProxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0 || soap_flag__proxy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__putProxy(struct soap *soap, const struct delegation__putProxy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__putProxy);
	if (soap_out_delegation__putProxy(soap, tag?tag:"delegation:putProxy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__putProxy * SOAP_FMAC4 soap_get_delegation__putProxy(struct soap *soap, struct delegation__putProxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__putProxy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__putProxy * SOAP_FMAC2 soap_instantiate_delegation__putProxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__putProxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__putProxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxy);
		if (size)
			*size = sizeof(struct delegation__putProxy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__putProxy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__putProxy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__putProxy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__putProxy %p -> %p\n", q, p));
	*(struct delegation__putProxy*)p = *(struct delegation__putProxy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__putProxyResponse(struct soap *soap, struct delegation__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__putProxyResponse(struct soap *soap, const struct delegation__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__putProxyResponse(struct soap *soap, const char *tag, int id, const struct delegation__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__putProxyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__putProxyResponse * SOAP_FMAC4 soap_in_delegation__putProxyResponse(struct soap *soap, const char *tag, struct delegation__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__putProxyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__putProxyResponse, sizeof(struct delegation__putProxyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__putProxyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__putProxyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__putProxyResponse, 0, sizeof(struct delegation__putProxyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__putProxyResponse(struct soap *soap, const struct delegation__putProxyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__putProxyResponse);
	if (soap_out_delegation__putProxyResponse(soap, tag?tag:"delegation:putProxyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__putProxyResponse * SOAP_FMAC4 soap_get_delegation__putProxyResponse(struct soap *soap, struct delegation__putProxyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__putProxyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__putProxyResponse * SOAP_FMAC2 soap_instantiate_delegation__putProxyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__putProxyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__putProxyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxyResponse);
		if (size)
			*size = sizeof(struct delegation__putProxyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__putProxyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__putProxyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__putProxyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__putProxyResponse %p -> %p\n", q, p));
	*(struct delegation__putProxyResponse*)p = *(struct delegation__putProxyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__renewProxyReq(struct soap *soap, struct delegation__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__renewProxyReq(struct soap *soap, const struct delegation__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__renewProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__renewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__renewProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__renewProxyReq * SOAP_FMAC4 soap_in_delegation__renewProxyReq(struct soap *soap, const char *tag, struct delegation__renewProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__renewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__renewProxyReq, sizeof(struct delegation__renewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__renewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__renewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__renewProxyReq, 0, sizeof(struct delegation__renewProxyReq), 0, soap_copy_delegation__renewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__renewProxyReq(struct soap *soap, const struct delegation__renewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__renewProxyReq);
	if (soap_out_delegation__renewProxyReq(soap, tag?tag:"delegation:renewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__renewProxyReq * SOAP_FMAC4 soap_get_delegation__renewProxyReq(struct soap *soap, struct delegation__renewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__renewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__renewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__renewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__renewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__renewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReq);
		if (size)
			*size = sizeof(struct delegation__renewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__renewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__renewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__renewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__renewProxyReq %p -> %p\n", q, p));
	*(struct delegation__renewProxyReq*)p = *(struct delegation__renewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__renewProxyReqResponse(struct soap *soap, struct delegation__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__renewProxyReqResponse(struct soap *soap, const struct delegation__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_renewProxyReqReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__renewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__renewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__renewProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "renewProxyReqReturn", -1, &a->_renewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__renewProxyReqResponse * SOAP_FMAC4 soap_in_delegation__renewProxyReqResponse(struct soap *soap, const char *tag, struct delegation__renewProxyReqResponse *a, const char *type)
{
	size_t soap_flag__renewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__renewProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__renewProxyReqResponse, sizeof(struct delegation__renewProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__renewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__renewProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_renewProxyReqReturn, "xsd:string"))
				{	soap_flag__renewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__renewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__renewProxyReqResponse, 0, sizeof(struct delegation__renewProxyReqResponse), 0, soap_copy_delegation__renewProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__renewProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__renewProxyReqResponse(struct soap *soap, const struct delegation__renewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__renewProxyReqResponse);
	if (soap_out_delegation__renewProxyReqResponse(soap, tag?tag:"delegation:renewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__renewProxyReqResponse * SOAP_FMAC4 soap_get_delegation__renewProxyReqResponse(struct soap *soap, struct delegation__renewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__renewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__renewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__renewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__renewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__renewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__renewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__renewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__renewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__renewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__renewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__renewProxyReqResponse*)p = *(struct delegation__renewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getNewProxyReq(struct soap *soap, struct delegation__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getNewProxyReq(struct soap *soap, const struct delegation__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getNewProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getNewProxyReq), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getNewProxyReq * SOAP_FMAC4 soap_in_delegation__getNewProxyReq(struct soap *soap, const char *tag, struct delegation__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getNewProxyReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getNewProxyReq, sizeof(struct delegation__getNewProxyReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getNewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getNewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getNewProxyReq, 0, sizeof(struct delegation__getNewProxyReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getNewProxyReq(struct soap *soap, const struct delegation__getNewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getNewProxyReq);
	if (soap_out_delegation__getNewProxyReq(soap, tag?tag:"delegation:getNewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getNewProxyReq * SOAP_FMAC4 soap_get_delegation__getNewProxyReq(struct soap *soap, struct delegation__getNewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getNewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getNewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__getNewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getNewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getNewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReq);
		if (size)
			*size = sizeof(struct delegation__getNewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getNewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getNewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getNewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getNewProxyReq %p -> %p\n", q, p));
	*(struct delegation__getNewProxyReq*)p = *(struct delegation__getNewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getNewProxyReqResponse(struct soap *soap, struct delegation__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getNewProxyReqReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getNewProxyReqResponse(struct soap *soap, const struct delegation__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodelegation__NewProxyReq(soap, &a->getNewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getNewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__getNewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getNewProxyReqResponse), type))
		return soap->error;
	if (soap_out_PointerTodelegation__NewProxyReq(soap, "getNewProxyReqReturn", -1, &a->getNewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getNewProxyReqResponse * SOAP_FMAC4 soap_in_delegation__getNewProxyReqResponse(struct soap *soap, const char *tag, struct delegation__getNewProxyReqResponse *a, const char *type)
{
	size_t soap_flag_getNewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getNewProxyReqResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getNewProxyReqResponse, sizeof(struct delegation__getNewProxyReqResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getNewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getNewProxyReqReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodelegation__NewProxyReq(soap, "getNewProxyReqReturn", &a->getNewProxyReqReturn, "delegation:NewProxyReq"))
				{	soap_flag_getNewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getNewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getNewProxyReqResponse, 0, sizeof(struct delegation__getNewProxyReqResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getNewProxyReqResponse(struct soap *soap, const struct delegation__getNewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getNewProxyReqResponse);
	if (soap_out_delegation__getNewProxyReqResponse(soap, tag?tag:"delegation:getNewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getNewProxyReqResponse * SOAP_FMAC4 soap_get_delegation__getNewProxyReqResponse(struct soap *soap, struct delegation__getNewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getNewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getNewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__getNewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getNewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getNewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__getNewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getNewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getNewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getNewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getNewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__getNewProxyReqResponse*)p = *(struct delegation__getNewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getProxyReq(struct soap *soap, struct delegation__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getProxyReq(struct soap *soap, const struct delegation__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__getProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getProxyReq * SOAP_FMAC4 soap_in_delegation__getProxyReq(struct soap *soap, const char *tag, struct delegation__getProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getProxyReq, sizeof(struct delegation__getProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getProxyReq, 0, sizeof(struct delegation__getProxyReq), 0, soap_copy_delegation__getProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getProxyReq(struct soap *soap, const struct delegation__getProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getProxyReq);
	if (soap_out_delegation__getProxyReq(soap, tag?tag:"delegation:getProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getProxyReq * SOAP_FMAC4 soap_get_delegation__getProxyReq(struct soap *soap, struct delegation__getProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getProxyReq * SOAP_FMAC2 soap_instantiate_delegation__getProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReq);
		if (size)
			*size = sizeof(struct delegation__getProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getProxyReq %p -> %p\n", q, p));
	*(struct delegation__getProxyReq*)p = *(struct delegation__getProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getProxyReqResponse(struct soap *soap, struct delegation__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getProxyReqResponse(struct soap *soap, const struct delegation__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getProxyReqReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__getProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getProxyReqReturn", -1, &a->_getProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getProxyReqResponse * SOAP_FMAC4 soap_in_delegation__getProxyReqResponse(struct soap *soap, const char *tag, struct delegation__getProxyReqResponse *a, const char *type)
{
	size_t soap_flag__getProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getProxyReqResponse, sizeof(struct delegation__getProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getProxyReqReturn, "xsd:string"))
				{	soap_flag__getProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getProxyReqResponse, 0, sizeof(struct delegation__getProxyReqResponse), 0, soap_copy_delegation__getProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getProxyReqResponse(struct soap *soap, const struct delegation__getProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getProxyReqResponse);
	if (soap_out_delegation__getProxyReqResponse(soap, tag?tag:"delegation:getProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getProxyReqResponse * SOAP_FMAC4 soap_get_delegation__getProxyReqResponse(struct soap *soap, struct delegation__getProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__getProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__getProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__getProxyReqResponse*)p = *(struct delegation__getProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getServiceMetadata(struct soap *soap, struct delegation__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getServiceMetadata(struct soap *soap, const struct delegation__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getServiceMetadata(struct soap *soap, const char *tag, int id, const struct delegation__getServiceMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getServiceMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getServiceMetadata * SOAP_FMAC4 soap_in_delegation__getServiceMetadata(struct soap *soap, const char *tag, struct delegation__getServiceMetadata *a, const char *type)
{
	size_t soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getServiceMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getServiceMetadata, sizeof(struct delegation__getServiceMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getServiceMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getServiceMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getServiceMetadata, 0, sizeof(struct delegation__getServiceMetadata), 0, soap_copy_delegation__getServiceMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getServiceMetadata(struct soap *soap, const struct delegation__getServiceMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getServiceMetadata);
	if (soap_out_delegation__getServiceMetadata(soap, tag?tag:"delegation:getServiceMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getServiceMetadata * SOAP_FMAC4 soap_get_delegation__getServiceMetadata(struct soap *soap, struct delegation__getServiceMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getServiceMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getServiceMetadata * SOAP_FMAC2 soap_instantiate_delegation__getServiceMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getServiceMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getServiceMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadata);
		if (size)
			*size = sizeof(struct delegation__getServiceMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getServiceMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getServiceMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getServiceMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getServiceMetadata %p -> %p\n", q, p));
	*(struct delegation__getServiceMetadata*)p = *(struct delegation__getServiceMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getServiceMetadataResponse(struct soap *soap, struct delegation__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getServiceMetadataResponse(struct soap *soap, const struct delegation__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getServiceMetadataReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getServiceMetadataResponse(struct soap *soap, const char *tag, int id, const struct delegation__getServiceMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getServiceMetadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getServiceMetadataReturn", -1, &a->_getServiceMetadataReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getServiceMetadataResponse * SOAP_FMAC4 soap_in_delegation__getServiceMetadataResponse(struct soap *soap, const char *tag, struct delegation__getServiceMetadataResponse *a, const char *type)
{
	size_t soap_flag__getServiceMetadataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getServiceMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getServiceMetadataResponse, sizeof(struct delegation__getServiceMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getServiceMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getServiceMetadataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getServiceMetadataReturn, "xsd:string"))
				{	soap_flag__getServiceMetadataReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getServiceMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getServiceMetadataResponse, 0, sizeof(struct delegation__getServiceMetadataResponse), 0, soap_copy_delegation__getServiceMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getServiceMetadataReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getServiceMetadataResponse(struct soap *soap, const struct delegation__getServiceMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getServiceMetadataResponse);
	if (soap_out_delegation__getServiceMetadataResponse(soap, tag?tag:"delegation:getServiceMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getServiceMetadataResponse * SOAP_FMAC4 soap_get_delegation__getServiceMetadataResponse(struct soap *soap, struct delegation__getServiceMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getServiceMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getServiceMetadataResponse * SOAP_FMAC2 soap_instantiate_delegation__getServiceMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getServiceMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getServiceMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadataResponse);
		if (size)
			*size = sizeof(struct delegation__getServiceMetadataResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getServiceMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getServiceMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getServiceMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getServiceMetadataResponse %p -> %p\n", q, p));
	*(struct delegation__getServiceMetadataResponse*)p = *(struct delegation__getServiceMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getInterfaceVersion(struct soap *soap, struct delegation__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getInterfaceVersion(struct soap *soap, const struct delegation__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getInterfaceVersion(struct soap *soap, const char *tag, int id, const struct delegation__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getInterfaceVersion * SOAP_FMAC4 soap_in_delegation__getInterfaceVersion(struct soap *soap, const char *tag, struct delegation__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getInterfaceVersion, sizeof(struct delegation__getInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getInterfaceVersion, 0, sizeof(struct delegation__getInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getInterfaceVersion(struct soap *soap, const struct delegation__getInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getInterfaceVersion);
	if (soap_out_delegation__getInterfaceVersion(soap, tag?tag:"delegation:getInterfaceVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getInterfaceVersion * SOAP_FMAC4 soap_get_delegation__getInterfaceVersion(struct soap *soap, struct delegation__getInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getInterfaceVersion * SOAP_FMAC2 soap_instantiate_delegation__getInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersion);
		if (size)
			*size = sizeof(struct delegation__getInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getInterfaceVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getInterfaceVersion %p -> %p\n", q, p));
	*(struct delegation__getInterfaceVersion*)p = *(struct delegation__getInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getInterfaceVersionResponse(struct soap *soap, struct delegation__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getInterfaceVersionResponse(struct soap *soap, const struct delegation__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getInterfaceVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct delegation__getInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getInterfaceVersionReturn", -1, &a->getInterfaceVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getInterfaceVersionResponse * SOAP_FMAC4 soap_in_delegation__getInterfaceVersionResponse(struct soap *soap, const char *tag, struct delegation__getInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_getInterfaceVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getInterfaceVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getInterfaceVersionResponse, sizeof(struct delegation__getInterfaceVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInterfaceVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getInterfaceVersionReturn", &a->getInterfaceVersionReturn, "xsd:string"))
				{	soap_flag_getInterfaceVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getInterfaceVersionResponse, 0, sizeof(struct delegation__getInterfaceVersionResponse), 0, soap_copy_delegation__getInterfaceVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getInterfaceVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getInterfaceVersionResponse(struct soap *soap, const struct delegation__getInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getInterfaceVersionResponse);
	if (soap_out_delegation__getInterfaceVersionResponse(soap, tag?tag:"delegation:getInterfaceVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getInterfaceVersionResponse * SOAP_FMAC4 soap_get_delegation__getInterfaceVersionResponse(struct soap *soap, struct delegation__getInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getInterfaceVersionResponse * SOAP_FMAC2 soap_instantiate_delegation__getInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersionResponse);
		if (size)
			*size = sizeof(struct delegation__getInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getInterfaceVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct delegation__getInterfaceVersionResponse*)p = *(struct delegation__getInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getVersion(struct soap *soap, struct delegation__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getVersion(struct soap *soap, const struct delegation__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getVersion(struct soap *soap, const char *tag, int id, const struct delegation__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getVersion * SOAP_FMAC4 soap_in_delegation__getVersion(struct soap *soap, const char *tag, struct delegation__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getVersion, sizeof(struct delegation__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getVersion, 0, sizeof(struct delegation__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getVersion(struct soap *soap, const struct delegation__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getVersion);
	if (soap_out_delegation__getVersion(soap, tag?tag:"delegation:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getVersion * SOAP_FMAC4 soap_get_delegation__getVersion(struct soap *soap, struct delegation__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getVersion * SOAP_FMAC2 soap_instantiate_delegation__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersion);
		if (size)
			*size = sizeof(struct delegation__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getVersion %p -> %p\n", q, p));
	*(struct delegation__getVersion*)p = *(struct delegation__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getVersionResponse(struct soap *soap, struct delegation__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getVersionResponse(struct soap *soap, const struct delegation__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getVersionResponse(struct soap *soap, const char *tag, int id, const struct delegation__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getVersionReturn", -1, &a->getVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getVersionResponse * SOAP_FMAC4 soap_in_delegation__getVersionResponse(struct soap *soap, const char *tag, struct delegation__getVersionResponse *a, const char *type)
{
	size_t soap_flag_getVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation__getVersionResponse, sizeof(struct delegation__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getVersionReturn", &a->getVersionReturn, "xsd:string"))
				{	soap_flag_getVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation__getVersionResponse, 0, sizeof(struct delegation__getVersionResponse), 0, soap_copy_delegation__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getVersionResponse(struct soap *soap, const struct delegation__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation__getVersionResponse);
	if (soap_out_delegation__getVersionResponse(soap, tag?tag:"delegation:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getVersionResponse * SOAP_FMAC4 soap_get_delegation__getVersionResponse(struct soap *soap, struct delegation__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getVersionResponse * SOAP_FMAC2 soap_instantiate_delegation__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersionResponse);
		if (size)
			*size = sizeof(struct delegation__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getVersionResponse %p -> %p\n", q, p));
	*(struct delegation__getVersionResponse*)p = *(struct delegation__getVersionResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->delegation__DelegationException = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_delegation__DelegationException(soap, &a->delegation__DelegationException);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_delegation__DelegationException(soap, "delegation:DelegationException", -1, &a->delegation__DelegationException, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_delegation__DelegationException = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delegation__DelegationException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_delegation__DelegationException(soap, "delegation:DelegationException", &a->delegation__DelegationException, ""))
				{	soap_flag_delegation__DelegationException--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_delegation__NewProxyReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodelegation__NewProxyReq(struct soap *soap, const char *tag, int id, delegation__NewProxyReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_delegation__NewProxyReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 delegation__NewProxyReq ** SOAP_FMAC4 soap_in_PointerTodelegation__NewProxyReq(struct soap *soap, const char *tag, delegation__NewProxyReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (delegation__NewProxyReq **)soap_malloc(soap, sizeof(delegation__NewProxyReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (delegation__NewProxyReq *)soap_instantiate_delegation__NewProxyReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	delegation__NewProxyReq ** p = (delegation__NewProxyReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_delegation__NewProxyReq, sizeof(delegation__NewProxyReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodelegation__NewProxyReq);
	if (soap_out_PointerTodelegation__NewProxyReq(soap, tag?tag:"delegation:NewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 delegation__NewProxyReq ** SOAP_FMAC4 soap_get_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodelegation__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__delegation__DelegationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_delegation__DelegationException(struct soap *soap, const char *tag, int id, _delegation__DelegationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__delegation__DelegationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _delegation__DelegationException ** SOAP_FMAC4 soap_in_PointerTo_delegation__DelegationException(struct soap *soap, const char *tag, _delegation__DelegationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_delegation__DelegationException **)soap_malloc(soap, sizeof(_delegation__DelegationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_delegation__DelegationException *)soap_instantiate__delegation__DelegationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_delegation__DelegationException ** p = (_delegation__DelegationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__delegation__DelegationException, sizeof(_delegation__DelegationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_delegation__DelegationException);
	if (soap_out_PointerTo_delegation__DelegationException(soap, tag?tag:"delegation:DelegationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _delegation__DelegationException ** SOAP_FMAC4 soap_get_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_delegation__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of delegationC.cpp */
