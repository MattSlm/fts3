/* fts3C.cpp
   Generated by gSOAP 2.7.16 from /home/simonm/tmp/build/src/ws-ifce/gsoap/gsoap_interface.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "fts3H.h"

namespace fts3 {

SOAP_SOURCE_STAMP("@(#) fts3C.cpp ver 2.7.16 2013-02-05 11:10:01 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_fts3_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_fts3_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_fts3_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_fts3_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_fts3_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_fts3_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_fts3_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_fts3_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_fts3_log__LogInternal:
		return soap_in_log__LogInternal(soap, NULL, NULL, "log:LogInternal");
	case SOAP_TYPE_fts3_log__Log:
		return soap_in_log__Log(soap, NULL, NULL, "log:Log");
	case SOAP_TYPE_fts3_delegation__NewProxyReq:
		return soap_in_delegation__NewProxyReq(soap, NULL, NULL, "delegation:NewProxyReq");
	case SOAP_TYPE_fts3_config__InternalException:
		return soap_in_config__InternalException(soap, NULL, NULL, "config:InternalException");
	case SOAP_TYPE_fts3_config__ServiceBusyException:
		return soap_in_config__ServiceBusyException(soap, NULL, NULL, "config:ServiceBusyException");
	case SOAP_TYPE_fts3_config__AuthorizationException:
		return soap_in_config__AuthorizationException(soap, NULL, NULL, "config:AuthorizationException");
	case SOAP_TYPE_fts3_config__InvalidConfigurationException:
		return soap_in_config__InvalidConfigurationException(soap, NULL, NULL, "config:InvalidConfigurationException");
	case SOAP_TYPE_fts3_config__ConfigurationException:
		return soap_in_config__ConfigurationException(soap, NULL, NULL, "config:ConfigurationException");
	case SOAP_TYPE_fts3_config__Configuration:
		return soap_in_config__Configuration(soap, NULL, NULL, "config:Configuration");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, "impltns:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, "impltns:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_in_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, "impltns:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_in_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, "impltns:ArrayOf_soapenc_string");
	case SOAP_TYPE_fts3_tns3__Roles:
		return soap_in_tns3__Roles(soap, NULL, NULL, "tns3:Roles");
	case SOAP_TYPE_fts3_tns3__StringPair:
		return soap_in_tns3__StringPair(soap, NULL, NULL, "tns3:StringPair");
	case SOAP_TYPE_fts3_tns3__ExistsException:
		return soap_in_tns3__ExistsException(soap, NULL, NULL, "tns3:ExistsException");
	case SOAP_TYPE_fts3_tns3__CannotCancelException:
		return soap_in_tns3__CannotCancelException(soap, NULL, NULL, "tns3:CannotCancelException");
	case SOAP_TYPE_fts3_tns3__TransferJobSummary2:
		return soap_in_tns3__TransferJobSummary2(soap, NULL, NULL, "tns3:TransferJobSummary2");
	case SOAP_TYPE_fts3_tns3__TransferJobSummary:
		return soap_in_tns3__TransferJobSummary(soap, NULL, NULL, "tns3:TransferJobSummary");
	case SOAP_TYPE_fts3_tns3__FileTransferStatus2:
		return soap_in_tns3__FileTransferStatus2(soap, NULL, NULL, "tns3:FileTransferStatus2");
	case SOAP_TYPE_fts3_tns3__NotExistsException:
		return soap_in_tns3__NotExistsException(soap, NULL, NULL, "tns3:NotExistsException");
	case SOAP_TYPE_fts3_tns3__FileTransferStatus:
		return soap_in_tns3__FileTransferStatus(soap, NULL, NULL, "tns3:FileTransferStatus");
	case SOAP_TYPE_fts3_tns3__JobStatus:
		return soap_in_tns3__JobStatus(soap, NULL, NULL, "tns3:JobStatus");
	case SOAP_TYPE_fts3_tns3__TransferJob3:
		return soap_in_tns3__TransferJob3(soap, NULL, NULL, "tns3:TransferJob3");
	case SOAP_TYPE_fts3_tns3__TransferJobElement3:
		return soap_in_tns3__TransferJobElement3(soap, NULL, NULL, "tns3:TransferJobElement3");
	case SOAP_TYPE_fts3_tns3__TransferJob2:
		return soap_in_tns3__TransferJob2(soap, NULL, NULL, "tns3:TransferJob2");
	case SOAP_TYPE_fts3_tns3__TransferJobElement2:
		return soap_in_tns3__TransferJobElement2(soap, NULL, NULL, "tns3:TransferJobElement2");
	case SOAP_TYPE_fts3_tns3__TransferJob:
		return soap_in_tns3__TransferJob(soap, NULL, NULL, "tns3:TransferJob");
	case SOAP_TYPE_fts3_tns3__TransferJobElement:
		return soap_in_tns3__TransferJobElement(soap, NULL, NULL, "tns3:TransferJobElement");
	case SOAP_TYPE_fts3_tns3__InternalException:
		return soap_in_tns3__InternalException(soap, NULL, NULL, "tns3:InternalException");
	case SOAP_TYPE_fts3_tns3__ServiceBusyException:
		return soap_in_tns3__ServiceBusyException(soap, NULL, NULL, "tns3:ServiceBusyException");
	case SOAP_TYPE_fts3_tns3__AuthorizationException:
		return soap_in_tns3__AuthorizationException(soap, NULL, NULL, "tns3:AuthorizationException");
	case SOAP_TYPE_fts3_tns3__InvalidArgumentException:
		return soap_in_tns3__InvalidArgumentException(soap, NULL, NULL, "tns3:InvalidArgumentException");
	case SOAP_TYPE_fts3_tns3__TransferException:
		return soap_in_tns3__TransferException(soap, NULL, NULL, "tns3:TransferException");
	case SOAP_TYPE_fts3_tns3__PlacementJob:
		return soap_in_tns3__PlacementJob(soap, NULL, NULL, "tns3:PlacementJob");
	case SOAP_TYPE_fts3_tns3__TransferParams:
		return soap_in_tns3__TransferParams(soap, NULL, NULL, "tns3:TransferParams");
	case SOAP_TYPE_fts3_log__GetLogInternal:
		return soap_in_log__GetLogInternal(soap, NULL, NULL, "log:GetLogInternal");
	case SOAP_TYPE_fts3_log__GetLogInternalResponse:
		return soap_in_log__GetLogInternalResponse(soap, NULL, NULL, "log:GetLogInternalResponse");
	case SOAP_TYPE_fts3_log__GetLog:
		return soap_in_log__GetLog(soap, NULL, NULL, "log:GetLog");
	case SOAP_TYPE_fts3_log__GetLogResponse:
		return soap_in_log__GetLogResponse(soap, NULL, NULL, "log:GetLogResponse");
	case SOAP_TYPE_fts3_impltns__getServiceMetadata:
		return soap_in_impltns__getServiceMetadata(soap, NULL, NULL, "impltns:getServiceMetadata");
	case SOAP_TYPE_fts3_impltns__getServiceMetadataResponse:
		return soap_in_impltns__getServiceMetadataResponse(soap, NULL, NULL, "impltns:getServiceMetadataResponse");
	case SOAP_TYPE_fts3_impltns__getInterfaceVersion:
		return soap_in_impltns__getInterfaceVersion(soap, NULL, NULL, "impltns:getInterfaceVersion");
	case SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse:
		return soap_in_impltns__getInterfaceVersionResponse(soap, NULL, NULL, "impltns:getInterfaceVersionResponse");
	case SOAP_TYPE_fts3_impltns__getSchemaVersion:
		return soap_in_impltns__getSchemaVersion(soap, NULL, NULL, "impltns:getSchemaVersion");
	case SOAP_TYPE_fts3_impltns__getSchemaVersionResponse:
		return soap_in_impltns__getSchemaVersionResponse(soap, NULL, NULL, "impltns:getSchemaVersionResponse");
	case SOAP_TYPE_fts3_impltns__getVersion:
		return soap_in_impltns__getVersion(soap, NULL, NULL, "impltns:getVersion");
	case SOAP_TYPE_fts3_impltns__getVersionResponse:
		return soap_in_impltns__getVersionResponse(soap, NULL, NULL, "impltns:getVersionResponse");
	case SOAP_TYPE_fts3_impltns__getRolesOf:
		return soap_in_impltns__getRolesOf(soap, NULL, NULL, "impltns:getRolesOf");
	case SOAP_TYPE_fts3_impltns__getRolesOfResponse:
		return soap_in_impltns__getRolesOfResponse(soap, NULL, NULL, "impltns:getRolesOfResponse");
	case SOAP_TYPE_fts3_impltns__getRoles:
		return soap_in_impltns__getRoles(soap, NULL, NULL, "impltns:getRoles");
	case SOAP_TYPE_fts3_impltns__getRolesResponse:
		return soap_in_impltns__getRolesResponse(soap, NULL, NULL, "impltns:getRolesResponse");
	case SOAP_TYPE_fts3_impltns__listVOManagers:
		return soap_in_impltns__listVOManagers(soap, NULL, NULL, "impltns:listVOManagers");
	case SOAP_TYPE_fts3_impltns__listVOManagersResponse:
		return soap_in_impltns__listVOManagersResponse(soap, NULL, NULL, "impltns:listVOManagersResponse");
	case SOAP_TYPE_fts3_impltns__removeVOManager:
		return soap_in_impltns__removeVOManager(soap, NULL, NULL, "impltns:removeVOManager");
	case SOAP_TYPE_fts3_impltns__removeVOManagerResponse:
		return soap_in_impltns__removeVOManagerResponse(soap, NULL, NULL, "impltns:removeVOManagerResponse");
	case SOAP_TYPE_fts3_impltns__addVOManager:
		return soap_in_impltns__addVOManager(soap, NULL, NULL, "impltns:addVOManager");
	case SOAP_TYPE_fts3_impltns__addVOManagerResponse:
		return soap_in_impltns__addVOManagerResponse(soap, NULL, NULL, "impltns:addVOManagerResponse");
	case SOAP_TYPE_fts3_impltns__setJobPriority:
		return soap_in_impltns__setJobPriority(soap, NULL, NULL, "impltns:setJobPriority");
	case SOAP_TYPE_fts3_impltns__setJobPriorityResponse:
		return soap_in_impltns__setJobPriorityResponse(soap, NULL, NULL, "impltns:setJobPriorityResponse");
	case SOAP_TYPE_fts3_impltns__cancel:
		return soap_in_impltns__cancel(soap, NULL, NULL, "impltns:cancel");
	case SOAP_TYPE_fts3_impltns__cancelResponse:
		return soap_in_impltns__cancelResponse(soap, NULL, NULL, "impltns:cancelResponse");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2:
		return soap_in_impltns__getTransferJobSummary2(soap, NULL, NULL, "impltns:getTransferJobSummary2");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response:
		return soap_in_impltns__getTransferJobSummary2Response(soap, NULL, NULL, "impltns:getTransferJobSummary2Response");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary:
		return soap_in_impltns__getTransferJobSummary(soap, NULL, NULL, "impltns:getTransferJobSummary");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse:
		return soap_in_impltns__getTransferJobSummaryResponse(soap, NULL, NULL, "impltns:getTransferJobSummaryResponse");
	case SOAP_TYPE_fts3_impltns__getTransferJobStatus:
		return soap_in_impltns__getTransferJobStatus(soap, NULL, NULL, "impltns:getTransferJobStatus");
	case SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse:
		return soap_in_impltns__getTransferJobStatusResponse(soap, NULL, NULL, "impltns:getTransferJobStatusResponse");
	case SOAP_TYPE_fts3_impltns__getFileStatus2:
		return soap_in_impltns__getFileStatus2(soap, NULL, NULL, "impltns:getFileStatus2");
	case SOAP_TYPE_fts3_impltns__getFileStatus2Response:
		return soap_in_impltns__getFileStatus2Response(soap, NULL, NULL, "impltns:getFileStatus2Response");
	case SOAP_TYPE_fts3_impltns__getFileStatus:
		return soap_in_impltns__getFileStatus(soap, NULL, NULL, "impltns:getFileStatus");
	case SOAP_TYPE_fts3_impltns__getFileStatusResponse:
		return soap_in_impltns__getFileStatusResponse(soap, NULL, NULL, "impltns:getFileStatusResponse");
	case SOAP_TYPE_fts3_impltns__listRequests2:
		return soap_in_impltns__listRequests2(soap, NULL, NULL, "impltns:listRequests2");
	case SOAP_TYPE_fts3_impltns__listRequests2Response:
		return soap_in_impltns__listRequests2Response(soap, NULL, NULL, "impltns:listRequests2Response");
	case SOAP_TYPE_fts3_impltns__listRequests:
		return soap_in_impltns__listRequests(soap, NULL, NULL, "impltns:listRequests");
	case SOAP_TYPE_fts3_impltns__listRequestsResponse:
		return soap_in_impltns__listRequestsResponse(soap, NULL, NULL, "impltns:listRequestsResponse");
	case SOAP_TYPE_fts3_impltns__blacklist:
		return soap_in_impltns__blacklist(soap, NULL, NULL, "impltns:blacklist");
	case SOAP_TYPE_fts3_impltns__blacklistResponse:
		return soap_in_impltns__blacklistResponse(soap, NULL, NULL, "impltns:blacklistResponse");
	case SOAP_TYPE_fts3_impltns__debugSet:
		return soap_in_impltns__debugSet(soap, NULL, NULL, "impltns:debugSet");
	case SOAP_TYPE_fts3_impltns__debugSetResponse:
		return soap_in_impltns__debugSetResponse(soap, NULL, NULL, "impltns:debugSetResponse");
	case SOAP_TYPE_fts3_impltns__prioritySet:
		return soap_in_impltns__prioritySet(soap, NULL, NULL, "impltns:prioritySet");
	case SOAP_TYPE_fts3_impltns__prioritySetResponse:
		return soap_in_impltns__prioritySetResponse(soap, NULL, NULL, "impltns:prioritySetResponse");
	case SOAP_TYPE_fts3_impltns__transferSubmit4:
		return soap_in_impltns__transferSubmit4(soap, NULL, NULL, "impltns:transferSubmit4");
	case SOAP_TYPE_fts3_impltns__transferSubmit4Response:
		return soap_in_impltns__transferSubmit4Response(soap, NULL, NULL, "impltns:transferSubmit4Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit3:
		return soap_in_impltns__transferSubmit3(soap, NULL, NULL, "impltns:transferSubmit3");
	case SOAP_TYPE_fts3_impltns__transferSubmit3Response:
		return soap_in_impltns__transferSubmit3Response(soap, NULL, NULL, "impltns:transferSubmit3Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit2:
		return soap_in_impltns__transferSubmit2(soap, NULL, NULL, "impltns:transferSubmit2");
	case SOAP_TYPE_fts3_impltns__transferSubmit2Response:
		return soap_in_impltns__transferSubmit2Response(soap, NULL, NULL, "impltns:transferSubmit2Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit:
		return soap_in_impltns__transferSubmit(soap, NULL, NULL, "impltns:transferSubmit");
	case SOAP_TYPE_fts3_impltns__transferSubmitResponse:
		return soap_in_impltns__transferSubmitResponse(soap, NULL, NULL, "impltns:transferSubmitResponse");
	case SOAP_TYPE_fts3_implcfg__setQueueTimeout:
		return soap_in_implcfg__setQueueTimeout(soap, NULL, NULL, "implcfg:setQueueTimeout");
	case SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse:
		return soap_in_implcfg__setQueueTimeoutResponse(soap, NULL, NULL, "implcfg:setQueueTimeoutResponse");
	case SOAP_TYPE_fts3_implcfg__setRetry:
		return soap_in_implcfg__setRetry(soap, NULL, NULL, "implcfg:setRetry");
	case SOAP_TYPE_fts3_implcfg__setRetryResponse:
		return soap_in_implcfg__setRetryResponse(soap, NULL, NULL, "implcfg:setRetryResponse");
	case SOAP_TYPE_fts3_implcfg__doDrain:
		return soap_in_implcfg__doDrain(soap, NULL, NULL, "implcfg:doDrain");
	case SOAP_TYPE_fts3_implcfg__doDrainResponse:
		return soap_in_implcfg__doDrainResponse(soap, NULL, NULL, "implcfg:doDrainResponse");
	case SOAP_TYPE_fts3_implcfg__getConfiguration:
		return soap_in_implcfg__getConfiguration(soap, NULL, NULL, "implcfg:getConfiguration");
	case SOAP_TYPE_fts3_implcfg__getConfigurationResponse:
		return soap_in_implcfg__getConfigurationResponse(soap, NULL, NULL, "implcfg:getConfigurationResponse");
	case SOAP_TYPE_fts3_implcfg__delConfiguration:
		return soap_in_implcfg__delConfiguration(soap, NULL, NULL, "implcfg:delConfiguration");
	case SOAP_TYPE_fts3_implcfg__delConfigurationResponse:
		return soap_in_implcfg__delConfigurationResponse(soap, NULL, NULL, "implcfg:delConfigurationResponse");
	case SOAP_TYPE_fts3_implcfg__setConfiguration:
		return soap_in_implcfg__setConfiguration(soap, NULL, NULL, "implcfg:setConfiguration");
	case SOAP_TYPE_fts3_implcfg__setConfigurationResponse:
		return soap_in_implcfg__setConfigurationResponse(soap, NULL, NULL, "implcfg:setConfigurationResponse");
	case SOAP_TYPE_fts3_delegation__destroy:
		return soap_in_delegation__destroy(soap, NULL, NULL, "delegation:destroy");
	case SOAP_TYPE_fts3_delegation__destroyResponse:
		return soap_in_delegation__destroyResponse(soap, NULL, NULL, "delegation:destroyResponse");
	case SOAP_TYPE_fts3_delegation__getTerminationTime:
		return soap_in_delegation__getTerminationTime(soap, NULL, NULL, "delegation:getTerminationTime");
	case SOAP_TYPE_fts3_delegation__getTerminationTimeResponse:
		return soap_in_delegation__getTerminationTimeResponse(soap, NULL, NULL, "delegation:getTerminationTimeResponse");
	case SOAP_TYPE_fts3_delegation__putProxy:
		return soap_in_delegation__putProxy(soap, NULL, NULL, "delegation:putProxy");
	case SOAP_TYPE_fts3_delegation__putProxyResponse:
		return soap_in_delegation__putProxyResponse(soap, NULL, NULL, "delegation:putProxyResponse");
	case SOAP_TYPE_fts3_delegation__renewProxyReq:
		return soap_in_delegation__renewProxyReq(soap, NULL, NULL, "delegation:renewProxyReq");
	case SOAP_TYPE_fts3_delegation__renewProxyReqResponse:
		return soap_in_delegation__renewProxyReqResponse(soap, NULL, NULL, "delegation:renewProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getNewProxyReq:
		return soap_in_delegation__getNewProxyReq(soap, NULL, NULL, "delegation:getNewProxyReq");
	case SOAP_TYPE_fts3_delegation__getNewProxyReqResponse:
		return soap_in_delegation__getNewProxyReqResponse(soap, NULL, NULL, "delegation:getNewProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getProxyReq:
		return soap_in_delegation__getProxyReq(soap, NULL, NULL, "delegation:getProxyReq");
	case SOAP_TYPE_fts3_delegation__getProxyReqResponse:
		return soap_in_delegation__getProxyReqResponse(soap, NULL, NULL, "delegation:getProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getServiceMetadata:
		return soap_in_delegation__getServiceMetadata(soap, NULL, NULL, "delegation:getServiceMetadata");
	case SOAP_TYPE_fts3_delegation__getServiceMetadataResponse:
		return soap_in_delegation__getServiceMetadataResponse(soap, NULL, NULL, "delegation:getServiceMetadataResponse");
	case SOAP_TYPE_fts3_delegation__getInterfaceVersion:
		return soap_in_delegation__getInterfaceVersion(soap, NULL, NULL, "delegation:getInterfaceVersion");
	case SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse:
		return soap_in_delegation__getInterfaceVersionResponse(soap, NULL, NULL, "delegation:getInterfaceVersionResponse");
	case SOAP_TYPE_fts3_delegation__getVersion:
		return soap_in_delegation__getVersion(soap, NULL, NULL, "delegation:getVersion");
	case SOAP_TYPE_fts3_delegation__getVersionResponse:
		return soap_in_delegation__getVersionResponse(soap, NULL, NULL, "delegation:getVersionResponse");
	case SOAP_TYPE_fts3_PointerTolog__LogInternal:
		return soap_in_PointerTolog__LogInternal(soap, NULL, NULL, "log:LogInternal");
	case SOAP_TYPE_fts3_PointerTotns3__Roles:
		return soap_in_PointerTotns3__Roles(soap, NULL, NULL, "tns3:Roles");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary2:
		return soap_in_PointerTotns3__TransferJobSummary2(soap, NULL, NULL, "tns3:TransferJobSummary2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary:
		return soap_in_PointerTotns3__TransferJobSummary(soap, NULL, NULL, "tns3:TransferJobSummary");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, "impltns:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, "impltns:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, "impltns:ArrayOf_soapenc_string");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, "impltns:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob3:
		return soap_in_PointerTotns3__TransferJob3(soap, NULL, NULL, "tns3:TransferJob3");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob2:
		return soap_in_PointerTotns3__TransferJob2(soap, NULL, NULL, "tns3:TransferJob2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob:
		return soap_in_PointerTotns3__TransferJob(soap, NULL, NULL, "tns3:TransferJob");
	case SOAP_TYPE_fts3_PointerToconfig__Configuration:
		return soap_in_PointerToconfig__Configuration(soap, NULL, NULL, "config:Configuration");
	case SOAP_TYPE_fts3_PointerTodelegation__NewProxyReq:
		return soap_in_PointerTodelegation__NewProxyReq(soap, NULL, NULL, "delegation:NewProxyReq");
	case SOAP_TYPE_fts3_PointerTotns3__ServiceBusyException:
		return soap_in_PointerTotns3__ServiceBusyException(soap, NULL, NULL, "tns3:ServiceBusyException");
	case SOAP_TYPE_fts3_PointerTotns3__NotExistsException:
		return soap_in_PointerTotns3__NotExistsException(soap, NULL, NULL, "tns3:NotExistsException");
	case SOAP_TYPE_fts3_PointerTotns3__InvalidArgumentException:
		return soap_in_PointerTotns3__InvalidArgumentException(soap, NULL, NULL, "tns3:InvalidArgumentException");
	case SOAP_TYPE_fts3_PointerTotns3__InternalException:
		return soap_in_PointerTotns3__InternalException(soap, NULL, NULL, "tns3:InternalException");
	case SOAP_TYPE_fts3_PointerTotns3__ExistsException:
		return soap_in_PointerTotns3__ExistsException(soap, NULL, NULL, "tns3:ExistsException");
	case SOAP_TYPE_fts3_PointerTotns3__CannotCancelException:
		return soap_in_PointerTotns3__CannotCancelException(soap, NULL, NULL, "tns3:CannotCancelException");
	case SOAP_TYPE_fts3_PointerTotns3__AuthorizationException:
		return soap_in_PointerTotns3__AuthorizationException(soap, NULL, NULL, "tns3:AuthorizationException");
	case SOAP_TYPE_fts3_PointerToconfig__ServiceBusyException:
		return soap_in_PointerToconfig__ServiceBusyException(soap, NULL, NULL, "config:ServiceBusyException");
	case SOAP_TYPE_fts3_PointerToconfig__InvalidConfigurationException:
		return soap_in_PointerToconfig__InvalidConfigurationException(soap, NULL, NULL, "config:InvalidConfigurationException");
	case SOAP_TYPE_fts3_PointerToconfig__InternalException:
		return soap_in_PointerToconfig__InternalException(soap, NULL, NULL, "config:InternalException");
	case SOAP_TYPE_fts3_PointerToconfig__AuthorizationException:
		return soap_in_PointerToconfig__AuthorizationException(soap, NULL, NULL, "config:AuthorizationException");
	case SOAP_TYPE_fts3_PointerTo_delegation__DelegationException:
		return soap_in_PointerTo_delegation__DelegationException(soap, NULL, NULL, "delegation:DelegationException");
	case SOAP_TYPE_fts3_PointerTolog__Log:
		return soap_in_PointerTolog__Log(soap, NULL, NULL, "log:Log");
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus2:
		return soap_in_PointerTotns3__FileTransferStatus2(soap, NULL, NULL, "tns3:FileTransferStatus2");
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus:
		return soap_in_PointerTotns3__FileTransferStatus(soap, NULL, NULL, "tns3:FileTransferStatus");
	case SOAP_TYPE_fts3_PointerTotns3__StringPair:
		return soap_in_PointerTotns3__StringPair(soap, NULL, NULL, "tns3:StringPair");
	case SOAP_TYPE_fts3_PointerTotns3__JobStatus:
		return soap_in_PointerTotns3__JobStatus(soap, NULL, NULL, "tns3:JobStatus");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement3:
		return soap_in_PointerTotns3__TransferJobElement3(soap, NULL, NULL, "tns3:TransferJobElement3");
	case SOAP_TYPE_fts3_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement2:
		return soap_in_PointerTotns3__TransferJobElement2(soap, NULL, NULL, "tns3:TransferJobElement2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement:
		return soap_in_PointerTotns3__TransferJobElement(soap, NULL, NULL, "tns3:TransferJobElement");
	case SOAP_TYPE_fts3_PointerTotns3__TransferParams:
		return soap_in_PointerTotns3__TransferParams(soap, NULL, NULL, "tns3:TransferParams");
	case SOAP_TYPE_fts3_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_fts3_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_fts3__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_fts3_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_fts3_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:LogInternal"))
		{	*type = SOAP_TYPE_fts3_log__LogInternal;
			return soap_in_log__LogInternal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:Log"))
		{	*type = SOAP_TYPE_fts3_log__Log;
			return soap_in_log__Log(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:NewProxyReq"))
		{	*type = SOAP_TYPE_fts3_delegation__NewProxyReq;
			return soap_in_delegation__NewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:InternalException"))
		{	*type = SOAP_TYPE_fts3_config__InternalException;
			return soap_in_config__InternalException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:ServiceBusyException"))
		{	*type = SOAP_TYPE_fts3_config__ServiceBusyException;
			return soap_in_config__ServiceBusyException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:AuthorizationException"))
		{	*type = SOAP_TYPE_fts3_config__AuthorizationException;
			return soap_in_config__AuthorizationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:InvalidConfigurationException"))
		{	*type = SOAP_TYPE_fts3_config__InvalidConfigurationException;
			return soap_in_config__InvalidConfigurationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:ConfigurationException"))
		{	*type = SOAP_TYPE_fts3_config__ConfigurationException;
			return soap_in_config__ConfigurationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "config:Configuration"))
		{	*type = SOAP_TYPE_fts3_config__Configuration;
			return soap_in_config__Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:ArrayOf_tns3_FileTransferStatus2"))
		{	*type = SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2;
			return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:ArrayOf_tns3_FileTransferStatus"))
		{	*type = SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus;
			return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:ArrayOf_tns3_JobStatus"))
		{	*type = SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus;
			return soap_in_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:ArrayOf_soapenc_string"))
		{	*type = SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring;
			return soap_in_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:Roles"))
		{	*type = SOAP_TYPE_fts3_tns3__Roles;
			return soap_in_tns3__Roles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:StringPair"))
		{	*type = SOAP_TYPE_fts3_tns3__StringPair;
			return soap_in_tns3__StringPair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:ExistsException"))
		{	*type = SOAP_TYPE_fts3_tns3__ExistsException;
			return soap_in_tns3__ExistsException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:CannotCancelException"))
		{	*type = SOAP_TYPE_fts3_tns3__CannotCancelException;
			return soap_in_tns3__CannotCancelException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJobSummary2"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJobSummary2;
			return soap_in_tns3__TransferJobSummary2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJobSummary"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJobSummary;
			return soap_in_tns3__TransferJobSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:FileTransferStatus2"))
		{	*type = SOAP_TYPE_fts3_tns3__FileTransferStatus2;
			return soap_in_tns3__FileTransferStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:NotExistsException"))
		{	*type = SOAP_TYPE_fts3_tns3__NotExistsException;
			return soap_in_tns3__NotExistsException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:FileTransferStatus"))
		{	*type = SOAP_TYPE_fts3_tns3__FileTransferStatus;
			return soap_in_tns3__FileTransferStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:JobStatus"))
		{	*type = SOAP_TYPE_fts3_tns3__JobStatus;
			return soap_in_tns3__JobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJob3"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJob3;
			return soap_in_tns3__TransferJob3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJobElement3"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJobElement3;
			return soap_in_tns3__TransferJobElement3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJob2"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJob2;
			return soap_in_tns3__TransferJob2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJobElement2"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJobElement2;
			return soap_in_tns3__TransferJobElement2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJob"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJob;
			return soap_in_tns3__TransferJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferJobElement"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferJobElement;
			return soap_in_tns3__TransferJobElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:InternalException"))
		{	*type = SOAP_TYPE_fts3_tns3__InternalException;
			return soap_in_tns3__InternalException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:ServiceBusyException"))
		{	*type = SOAP_TYPE_fts3_tns3__ServiceBusyException;
			return soap_in_tns3__ServiceBusyException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:AuthorizationException"))
		{	*type = SOAP_TYPE_fts3_tns3__AuthorizationException;
			return soap_in_tns3__AuthorizationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:InvalidArgumentException"))
		{	*type = SOAP_TYPE_fts3_tns3__InvalidArgumentException;
			return soap_in_tns3__InvalidArgumentException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferException"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferException;
			return soap_in_tns3__TransferException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:PlacementJob"))
		{	*type = SOAP_TYPE_fts3_tns3__PlacementJob;
			return soap_in_tns3__PlacementJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns3:TransferParams"))
		{	*type = SOAP_TYPE_fts3_tns3__TransferParams;
			return soap_in_tns3__TransferParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_fts3_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_fts3_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_fts3_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_fts3_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_fts3_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_fts3_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_fts3_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:GetLogInternal"))
		{	*type = SOAP_TYPE_fts3_log__GetLogInternal;
			return soap_in_log__GetLogInternal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:GetLogInternalResponse"))
		{	*type = SOAP_TYPE_fts3_log__GetLogInternalResponse;
			return soap_in_log__GetLogInternalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:GetLog"))
		{	*type = SOAP_TYPE_fts3_log__GetLog;
			return soap_in_log__GetLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "log:GetLogResponse"))
		{	*type = SOAP_TYPE_fts3_log__GetLogResponse;
			return soap_in_log__GetLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getServiceMetadata"))
		{	*type = SOAP_TYPE_fts3_impltns__getServiceMetadata;
			return soap_in_impltns__getServiceMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getServiceMetadataResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getServiceMetadataResponse;
			return soap_in_impltns__getServiceMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getInterfaceVersion"))
		{	*type = SOAP_TYPE_fts3_impltns__getInterfaceVersion;
			return soap_in_impltns__getInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse;
			return soap_in_impltns__getInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getSchemaVersion"))
		{	*type = SOAP_TYPE_fts3_impltns__getSchemaVersion;
			return soap_in_impltns__getSchemaVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getSchemaVersionResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getSchemaVersionResponse;
			return soap_in_impltns__getSchemaVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getVersion"))
		{	*type = SOAP_TYPE_fts3_impltns__getVersion;
			return soap_in_impltns__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getVersionResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getVersionResponse;
			return soap_in_impltns__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getRolesOf"))
		{	*type = SOAP_TYPE_fts3_impltns__getRolesOf;
			return soap_in_impltns__getRolesOf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getRolesOfResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getRolesOfResponse;
			return soap_in_impltns__getRolesOfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getRoles"))
		{	*type = SOAP_TYPE_fts3_impltns__getRoles;
			return soap_in_impltns__getRoles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getRolesResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getRolesResponse;
			return soap_in_impltns__getRolesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listVOManagers"))
		{	*type = SOAP_TYPE_fts3_impltns__listVOManagers;
			return soap_in_impltns__listVOManagers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listVOManagersResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__listVOManagersResponse;
			return soap_in_impltns__listVOManagersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:removeVOManager"))
		{	*type = SOAP_TYPE_fts3_impltns__removeVOManager;
			return soap_in_impltns__removeVOManager(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:removeVOManagerResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__removeVOManagerResponse;
			return soap_in_impltns__removeVOManagerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:addVOManager"))
		{	*type = SOAP_TYPE_fts3_impltns__addVOManager;
			return soap_in_impltns__addVOManager(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:addVOManagerResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__addVOManagerResponse;
			return soap_in_impltns__addVOManagerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:setJobPriority"))
		{	*type = SOAP_TYPE_fts3_impltns__setJobPriority;
			return soap_in_impltns__setJobPriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:setJobPriorityResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__setJobPriorityResponse;
			return soap_in_impltns__setJobPriorityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:cancel"))
		{	*type = SOAP_TYPE_fts3_impltns__cancel;
			return soap_in_impltns__cancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:cancelResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__cancelResponse;
			return soap_in_impltns__cancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobSummary2"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobSummary2;
			return soap_in_impltns__getTransferJobSummary2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobSummary2Response"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response;
			return soap_in_impltns__getTransferJobSummary2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobSummary"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobSummary;
			return soap_in_impltns__getTransferJobSummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobSummaryResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse;
			return soap_in_impltns__getTransferJobSummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobStatus"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobStatus;
			return soap_in_impltns__getTransferJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getTransferJobStatusResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse;
			return soap_in_impltns__getTransferJobStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getFileStatus2"))
		{	*type = SOAP_TYPE_fts3_impltns__getFileStatus2;
			return soap_in_impltns__getFileStatus2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getFileStatus2Response"))
		{	*type = SOAP_TYPE_fts3_impltns__getFileStatus2Response;
			return soap_in_impltns__getFileStatus2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getFileStatus"))
		{	*type = SOAP_TYPE_fts3_impltns__getFileStatus;
			return soap_in_impltns__getFileStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:getFileStatusResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__getFileStatusResponse;
			return soap_in_impltns__getFileStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listRequests2"))
		{	*type = SOAP_TYPE_fts3_impltns__listRequests2;
			return soap_in_impltns__listRequests2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listRequests2Response"))
		{	*type = SOAP_TYPE_fts3_impltns__listRequests2Response;
			return soap_in_impltns__listRequests2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listRequests"))
		{	*type = SOAP_TYPE_fts3_impltns__listRequests;
			return soap_in_impltns__listRequests(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:listRequestsResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__listRequestsResponse;
			return soap_in_impltns__listRequestsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:blacklist"))
		{	*type = SOAP_TYPE_fts3_impltns__blacklist;
			return soap_in_impltns__blacklist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:blacklistResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__blacklistResponse;
			return soap_in_impltns__blacklistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:debugSet"))
		{	*type = SOAP_TYPE_fts3_impltns__debugSet;
			return soap_in_impltns__debugSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:debugSetResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__debugSetResponse;
			return soap_in_impltns__debugSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:prioritySet"))
		{	*type = SOAP_TYPE_fts3_impltns__prioritySet;
			return soap_in_impltns__prioritySet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:prioritySetResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__prioritySetResponse;
			return soap_in_impltns__prioritySetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit4"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit4;
			return soap_in_impltns__transferSubmit4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit4Response"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit4Response;
			return soap_in_impltns__transferSubmit4Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit3"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit3;
			return soap_in_impltns__transferSubmit3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit3Response"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit3Response;
			return soap_in_impltns__transferSubmit3Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit2"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit2;
			return soap_in_impltns__transferSubmit2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit2Response"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit2Response;
			return soap_in_impltns__transferSubmit2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmit"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmit;
			return soap_in_impltns__transferSubmit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "impltns:transferSubmitResponse"))
		{	*type = SOAP_TYPE_fts3_impltns__transferSubmitResponse;
			return soap_in_impltns__transferSubmitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setQueueTimeout"))
		{	*type = SOAP_TYPE_fts3_implcfg__setQueueTimeout;
			return soap_in_implcfg__setQueueTimeout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setQueueTimeoutResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse;
			return soap_in_implcfg__setQueueTimeoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setRetry"))
		{	*type = SOAP_TYPE_fts3_implcfg__setRetry;
			return soap_in_implcfg__setRetry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setRetryResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__setRetryResponse;
			return soap_in_implcfg__setRetryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:doDrain"))
		{	*type = SOAP_TYPE_fts3_implcfg__doDrain;
			return soap_in_implcfg__doDrain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:doDrainResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__doDrainResponse;
			return soap_in_implcfg__doDrainResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:getConfiguration"))
		{	*type = SOAP_TYPE_fts3_implcfg__getConfiguration;
			return soap_in_implcfg__getConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:getConfigurationResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__getConfigurationResponse;
			return soap_in_implcfg__getConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:delConfiguration"))
		{	*type = SOAP_TYPE_fts3_implcfg__delConfiguration;
			return soap_in_implcfg__delConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:delConfigurationResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__delConfigurationResponse;
			return soap_in_implcfg__delConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setConfiguration"))
		{	*type = SOAP_TYPE_fts3_implcfg__setConfiguration;
			return soap_in_implcfg__setConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "implcfg:setConfigurationResponse"))
		{	*type = SOAP_TYPE_fts3_implcfg__setConfigurationResponse;
			return soap_in_implcfg__setConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:destroy"))
		{	*type = SOAP_TYPE_fts3_delegation__destroy;
			return soap_in_delegation__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:destroyResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__destroyResponse;
			return soap_in_delegation__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getTerminationTime"))
		{	*type = SOAP_TYPE_fts3_delegation__getTerminationTime;
			return soap_in_delegation__getTerminationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getTerminationTimeResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getTerminationTimeResponse;
			return soap_in_delegation__getTerminationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:putProxy"))
		{	*type = SOAP_TYPE_fts3_delegation__putProxy;
			return soap_in_delegation__putProxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:putProxyResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__putProxyResponse;
			return soap_in_delegation__putProxyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:renewProxyReq"))
		{	*type = SOAP_TYPE_fts3_delegation__renewProxyReq;
			return soap_in_delegation__renewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:renewProxyReqResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__renewProxyReqResponse;
			return soap_in_delegation__renewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getNewProxyReq"))
		{	*type = SOAP_TYPE_fts3_delegation__getNewProxyReq;
			return soap_in_delegation__getNewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getNewProxyReqResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getNewProxyReqResponse;
			return soap_in_delegation__getNewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getProxyReq"))
		{	*type = SOAP_TYPE_fts3_delegation__getProxyReq;
			return soap_in_delegation__getProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getProxyReqResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getProxyReqResponse;
			return soap_in_delegation__getProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getServiceMetadata"))
		{	*type = SOAP_TYPE_fts3_delegation__getServiceMetadata;
			return soap_in_delegation__getServiceMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getServiceMetadataResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getServiceMetadataResponse;
			return soap_in_delegation__getServiceMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getInterfaceVersion"))
		{	*type = SOAP_TYPE_fts3_delegation__getInterfaceVersion;
			return soap_in_delegation__getInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse;
			return soap_in_delegation__getInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getVersion"))
		{	*type = SOAP_TYPE_fts3_delegation__getVersion;
			return soap_in_delegation__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation:getVersionResponse"))
		{	*type = SOAP_TYPE_fts3_delegation__getVersionResponse;
			return soap_in_delegation__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_fts3__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_fts3_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "delegation:DelegationException"))
		{	*type = SOAP_TYPE_fts3__delegation__DelegationException;
			return soap_in__delegation__DelegationException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE_fts3__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_fts3_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_fts3_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_fts3_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_fts3_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_fts3_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_fts3_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_fts3_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_fts3_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_fts3_log__LogInternal:
		return ((log__LogInternal *)ptr)->soap_out(soap, tag, id, "log:LogInternal");
	case SOAP_TYPE_fts3_log__Log:
		return ((log__Log *)ptr)->soap_out(soap, tag, id, "log:Log");
	case SOAP_TYPE_fts3__delegation__DelegationException:
		return ((_delegation__DelegationException *)ptr)->soap_out(soap, "delegation:DelegationException", id, NULL);
	case SOAP_TYPE_fts3_delegation__NewProxyReq:
		return ((delegation__NewProxyReq *)ptr)->soap_out(soap, tag, id, "delegation:NewProxyReq");
	case SOAP_TYPE_fts3_config__InternalException:
		return ((config__InternalException *)ptr)->soap_out(soap, tag, id, "config:InternalException");
	case SOAP_TYPE_fts3_config__ServiceBusyException:
		return ((config__ServiceBusyException *)ptr)->soap_out(soap, tag, id, "config:ServiceBusyException");
	case SOAP_TYPE_fts3_config__AuthorizationException:
		return ((config__AuthorizationException *)ptr)->soap_out(soap, tag, id, "config:AuthorizationException");
	case SOAP_TYPE_fts3_config__InvalidConfigurationException:
		return ((config__InvalidConfigurationException *)ptr)->soap_out(soap, tag, id, "config:InvalidConfigurationException");
	case SOAP_TYPE_fts3_config__ConfigurationException:
		return ((config__ConfigurationException *)ptr)->soap_out(soap, tag, id, "config:ConfigurationException");
	case SOAP_TYPE_fts3_config__Configuration:
		return ((config__Configuration *)ptr)->soap_out(soap, tag, id, "config:Configuration");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return ((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)ptr)->soap_out(soap, tag, id, "impltns:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return ((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)ptr)->soap_out(soap, tag, id, "impltns:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		return ((impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)ptr)->soap_out(soap, tag, id, "impltns:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring:
		return ((impltns__ArrayOf_USCOREsoapenc_USCOREstring *)ptr)->soap_out(soap, tag, id, "impltns:ArrayOf_soapenc_string");
	case SOAP_TYPE_fts3_tns3__Roles:
		return ((tns3__Roles *)ptr)->soap_out(soap, tag, id, "tns3:Roles");
	case SOAP_TYPE_fts3_tns3__StringPair:
		return ((tns3__StringPair *)ptr)->soap_out(soap, tag, id, "tns3:StringPair");
	case SOAP_TYPE_fts3_tns3__ExistsException:
		return ((tns3__ExistsException *)ptr)->soap_out(soap, tag, id, "tns3:ExistsException");
	case SOAP_TYPE_fts3_tns3__CannotCancelException:
		return ((tns3__CannotCancelException *)ptr)->soap_out(soap, tag, id, "tns3:CannotCancelException");
	case SOAP_TYPE_fts3_tns3__TransferJobSummary2:
		return ((tns3__TransferJobSummary2 *)ptr)->soap_out(soap, tag, id, "tns3:TransferJobSummary2");
	case SOAP_TYPE_fts3_tns3__TransferJobSummary:
		return ((tns3__TransferJobSummary *)ptr)->soap_out(soap, tag, id, "tns3:TransferJobSummary");
	case SOAP_TYPE_fts3_tns3__FileTransferStatus2:
		return ((tns3__FileTransferStatus2 *)ptr)->soap_out(soap, tag, id, "tns3:FileTransferStatus2");
	case SOAP_TYPE_fts3_tns3__NotExistsException:
		return ((tns3__NotExistsException *)ptr)->soap_out(soap, tag, id, "tns3:NotExistsException");
	case SOAP_TYPE_fts3_tns3__FileTransferStatus:
		return ((tns3__FileTransferStatus *)ptr)->soap_out(soap, tag, id, "tns3:FileTransferStatus");
	case SOAP_TYPE_fts3_tns3__JobStatus:
		return ((tns3__JobStatus *)ptr)->soap_out(soap, tag, id, "tns3:JobStatus");
	case SOAP_TYPE_fts3_tns3__TransferJob3:
		return ((tns3__TransferJob3 *)ptr)->soap_out(soap, tag, id, "tns3:TransferJob3");
	case SOAP_TYPE_fts3_tns3__TransferJobElement3:
		return ((tns3__TransferJobElement3 *)ptr)->soap_out(soap, tag, id, "tns3:TransferJobElement3");
	case SOAP_TYPE_fts3_tns3__TransferJob2:
		return ((tns3__TransferJob2 *)ptr)->soap_out(soap, tag, id, "tns3:TransferJob2");
	case SOAP_TYPE_fts3_tns3__TransferJobElement2:
		return ((tns3__TransferJobElement2 *)ptr)->soap_out(soap, tag, id, "tns3:TransferJobElement2");
	case SOAP_TYPE_fts3_tns3__TransferJob:
		return ((tns3__TransferJob *)ptr)->soap_out(soap, tag, id, "tns3:TransferJob");
	case SOAP_TYPE_fts3_tns3__TransferJobElement:
		return ((tns3__TransferJobElement *)ptr)->soap_out(soap, tag, id, "tns3:TransferJobElement");
	case SOAP_TYPE_fts3_tns3__InternalException:
		return ((tns3__InternalException *)ptr)->soap_out(soap, tag, id, "tns3:InternalException");
	case SOAP_TYPE_fts3_tns3__ServiceBusyException:
		return ((tns3__ServiceBusyException *)ptr)->soap_out(soap, tag, id, "tns3:ServiceBusyException");
	case SOAP_TYPE_fts3_tns3__AuthorizationException:
		return ((tns3__AuthorizationException *)ptr)->soap_out(soap, tag, id, "tns3:AuthorizationException");
	case SOAP_TYPE_fts3_tns3__InvalidArgumentException:
		return ((tns3__InvalidArgumentException *)ptr)->soap_out(soap, tag, id, "tns3:InvalidArgumentException");
	case SOAP_TYPE_fts3_tns3__TransferException:
		return ((tns3__TransferException *)ptr)->soap_out(soap, tag, id, "tns3:TransferException");
	case SOAP_TYPE_fts3_tns3__PlacementJob:
		return ((tns3__PlacementJob *)ptr)->soap_out(soap, tag, id, "tns3:PlacementJob");
	case SOAP_TYPE_fts3_tns3__TransferParams:
		return ((tns3__TransferParams *)ptr)->soap_out(soap, tag, id, "tns3:TransferParams");
	case SOAP_TYPE_fts3_log__GetLogInternal:
		return soap_out_log__GetLogInternal(soap, tag, id, (const struct log__GetLogInternal *)ptr, "log:GetLogInternal");
	case SOAP_TYPE_fts3_log__GetLogInternalResponse:
		return soap_out_log__GetLogInternalResponse(soap, tag, id, (const struct log__GetLogInternalResponse *)ptr, "log:GetLogInternalResponse");
	case SOAP_TYPE_fts3_log__GetLog:
		return soap_out_log__GetLog(soap, tag, id, (const struct log__GetLog *)ptr, "log:GetLog");
	case SOAP_TYPE_fts3_log__GetLogResponse:
		return soap_out_log__GetLogResponse(soap, tag, id, (const struct log__GetLogResponse *)ptr, "log:GetLogResponse");
	case SOAP_TYPE_fts3_impltns__getServiceMetadata:
		return soap_out_impltns__getServiceMetadata(soap, tag, id, (const struct impltns__getServiceMetadata *)ptr, "impltns:getServiceMetadata");
	case SOAP_TYPE_fts3_impltns__getServiceMetadataResponse:
		return soap_out_impltns__getServiceMetadataResponse(soap, tag, id, (const struct impltns__getServiceMetadataResponse *)ptr, "impltns:getServiceMetadataResponse");
	case SOAP_TYPE_fts3_impltns__getInterfaceVersion:
		return soap_out_impltns__getInterfaceVersion(soap, tag, id, (const struct impltns__getInterfaceVersion *)ptr, "impltns:getInterfaceVersion");
	case SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse:
		return soap_out_impltns__getInterfaceVersionResponse(soap, tag, id, (const struct impltns__getInterfaceVersionResponse *)ptr, "impltns:getInterfaceVersionResponse");
	case SOAP_TYPE_fts3_impltns__getSchemaVersion:
		return soap_out_impltns__getSchemaVersion(soap, tag, id, (const struct impltns__getSchemaVersion *)ptr, "impltns:getSchemaVersion");
	case SOAP_TYPE_fts3_impltns__getSchemaVersionResponse:
		return soap_out_impltns__getSchemaVersionResponse(soap, tag, id, (const struct impltns__getSchemaVersionResponse *)ptr, "impltns:getSchemaVersionResponse");
	case SOAP_TYPE_fts3_impltns__getVersion:
		return soap_out_impltns__getVersion(soap, tag, id, (const struct impltns__getVersion *)ptr, "impltns:getVersion");
	case SOAP_TYPE_fts3_impltns__getVersionResponse:
		return soap_out_impltns__getVersionResponse(soap, tag, id, (const struct impltns__getVersionResponse *)ptr, "impltns:getVersionResponse");
	case SOAP_TYPE_fts3_impltns__getRolesOf:
		return soap_out_impltns__getRolesOf(soap, tag, id, (const struct impltns__getRolesOf *)ptr, "impltns:getRolesOf");
	case SOAP_TYPE_fts3_impltns__getRolesOfResponse:
		return soap_out_impltns__getRolesOfResponse(soap, tag, id, (const struct impltns__getRolesOfResponse *)ptr, "impltns:getRolesOfResponse");
	case SOAP_TYPE_fts3_impltns__getRoles:
		return soap_out_impltns__getRoles(soap, tag, id, (const struct impltns__getRoles *)ptr, "impltns:getRoles");
	case SOAP_TYPE_fts3_impltns__getRolesResponse:
		return soap_out_impltns__getRolesResponse(soap, tag, id, (const struct impltns__getRolesResponse *)ptr, "impltns:getRolesResponse");
	case SOAP_TYPE_fts3_impltns__listVOManagers:
		return soap_out_impltns__listVOManagers(soap, tag, id, (const struct impltns__listVOManagers *)ptr, "impltns:listVOManagers");
	case SOAP_TYPE_fts3_impltns__listVOManagersResponse:
		return soap_out_impltns__listVOManagersResponse(soap, tag, id, (const struct impltns__listVOManagersResponse *)ptr, "impltns:listVOManagersResponse");
	case SOAP_TYPE_fts3_impltns__removeVOManager:
		return soap_out_impltns__removeVOManager(soap, tag, id, (const struct impltns__removeVOManager *)ptr, "impltns:removeVOManager");
	case SOAP_TYPE_fts3_impltns__removeVOManagerResponse:
		return soap_out_impltns__removeVOManagerResponse(soap, tag, id, (const struct impltns__removeVOManagerResponse *)ptr, "impltns:removeVOManagerResponse");
	case SOAP_TYPE_fts3_impltns__addVOManager:
		return soap_out_impltns__addVOManager(soap, tag, id, (const struct impltns__addVOManager *)ptr, "impltns:addVOManager");
	case SOAP_TYPE_fts3_impltns__addVOManagerResponse:
		return soap_out_impltns__addVOManagerResponse(soap, tag, id, (const struct impltns__addVOManagerResponse *)ptr, "impltns:addVOManagerResponse");
	case SOAP_TYPE_fts3_impltns__setJobPriority:
		return soap_out_impltns__setJobPriority(soap, tag, id, (const struct impltns__setJobPriority *)ptr, "impltns:setJobPriority");
	case SOAP_TYPE_fts3_impltns__setJobPriorityResponse:
		return soap_out_impltns__setJobPriorityResponse(soap, tag, id, (const struct impltns__setJobPriorityResponse *)ptr, "impltns:setJobPriorityResponse");
	case SOAP_TYPE_fts3_impltns__cancel:
		return soap_out_impltns__cancel(soap, tag, id, (const struct impltns__cancel *)ptr, "impltns:cancel");
	case SOAP_TYPE_fts3_impltns__cancelResponse:
		return soap_out_impltns__cancelResponse(soap, tag, id, (const struct impltns__cancelResponse *)ptr, "impltns:cancelResponse");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2:
		return soap_out_impltns__getTransferJobSummary2(soap, tag, id, (const struct impltns__getTransferJobSummary2 *)ptr, "impltns:getTransferJobSummary2");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response:
		return soap_out_impltns__getTransferJobSummary2Response(soap, tag, id, (const struct impltns__getTransferJobSummary2Response *)ptr, "impltns:getTransferJobSummary2Response");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary:
		return soap_out_impltns__getTransferJobSummary(soap, tag, id, (const struct impltns__getTransferJobSummary *)ptr, "impltns:getTransferJobSummary");
	case SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse:
		return soap_out_impltns__getTransferJobSummaryResponse(soap, tag, id, (const struct impltns__getTransferJobSummaryResponse *)ptr, "impltns:getTransferJobSummaryResponse");
	case SOAP_TYPE_fts3_impltns__getTransferJobStatus:
		return soap_out_impltns__getTransferJobStatus(soap, tag, id, (const struct impltns__getTransferJobStatus *)ptr, "impltns:getTransferJobStatus");
	case SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse:
		return soap_out_impltns__getTransferJobStatusResponse(soap, tag, id, (const struct impltns__getTransferJobStatusResponse *)ptr, "impltns:getTransferJobStatusResponse");
	case SOAP_TYPE_fts3_impltns__getFileStatus2:
		return soap_out_impltns__getFileStatus2(soap, tag, id, (const struct impltns__getFileStatus2 *)ptr, "impltns:getFileStatus2");
	case SOAP_TYPE_fts3_impltns__getFileStatus2Response:
		return soap_out_impltns__getFileStatus2Response(soap, tag, id, (const struct impltns__getFileStatus2Response *)ptr, "impltns:getFileStatus2Response");
	case SOAP_TYPE_fts3_impltns__getFileStatus:
		return soap_out_impltns__getFileStatus(soap, tag, id, (const struct impltns__getFileStatus *)ptr, "impltns:getFileStatus");
	case SOAP_TYPE_fts3_impltns__getFileStatusResponse:
		return soap_out_impltns__getFileStatusResponse(soap, tag, id, (const struct impltns__getFileStatusResponse *)ptr, "impltns:getFileStatusResponse");
	case SOAP_TYPE_fts3_impltns__listRequests2:
		return soap_out_impltns__listRequests2(soap, tag, id, (const struct impltns__listRequests2 *)ptr, "impltns:listRequests2");
	case SOAP_TYPE_fts3_impltns__listRequests2Response:
		return soap_out_impltns__listRequests2Response(soap, tag, id, (const struct impltns__listRequests2Response *)ptr, "impltns:listRequests2Response");
	case SOAP_TYPE_fts3_impltns__listRequests:
		return soap_out_impltns__listRequests(soap, tag, id, (const struct impltns__listRequests *)ptr, "impltns:listRequests");
	case SOAP_TYPE_fts3_impltns__listRequestsResponse:
		return soap_out_impltns__listRequestsResponse(soap, tag, id, (const struct impltns__listRequestsResponse *)ptr, "impltns:listRequestsResponse");
	case SOAP_TYPE_fts3_impltns__blacklist:
		return soap_out_impltns__blacklist(soap, tag, id, (const struct impltns__blacklist *)ptr, "impltns:blacklist");
	case SOAP_TYPE_fts3_impltns__blacklistResponse:
		return soap_out_impltns__blacklistResponse(soap, tag, id, (const struct impltns__blacklistResponse *)ptr, "impltns:blacklistResponse");
	case SOAP_TYPE_fts3_impltns__debugSet:
		return soap_out_impltns__debugSet(soap, tag, id, (const struct impltns__debugSet *)ptr, "impltns:debugSet");
	case SOAP_TYPE_fts3_impltns__debugSetResponse:
		return soap_out_impltns__debugSetResponse(soap, tag, id, (const struct impltns__debugSetResponse *)ptr, "impltns:debugSetResponse");
	case SOAP_TYPE_fts3_impltns__prioritySet:
		return soap_out_impltns__prioritySet(soap, tag, id, (const struct impltns__prioritySet *)ptr, "impltns:prioritySet");
	case SOAP_TYPE_fts3_impltns__prioritySetResponse:
		return soap_out_impltns__prioritySetResponse(soap, tag, id, (const struct impltns__prioritySetResponse *)ptr, "impltns:prioritySetResponse");
	case SOAP_TYPE_fts3_impltns__transferSubmit4:
		return soap_out_impltns__transferSubmit4(soap, tag, id, (const struct impltns__transferSubmit4 *)ptr, "impltns:transferSubmit4");
	case SOAP_TYPE_fts3_impltns__transferSubmit4Response:
		return soap_out_impltns__transferSubmit4Response(soap, tag, id, (const struct impltns__transferSubmit4Response *)ptr, "impltns:transferSubmit4Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit3:
		return soap_out_impltns__transferSubmit3(soap, tag, id, (const struct impltns__transferSubmit3 *)ptr, "impltns:transferSubmit3");
	case SOAP_TYPE_fts3_impltns__transferSubmit3Response:
		return soap_out_impltns__transferSubmit3Response(soap, tag, id, (const struct impltns__transferSubmit3Response *)ptr, "impltns:transferSubmit3Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit2:
		return soap_out_impltns__transferSubmit2(soap, tag, id, (const struct impltns__transferSubmit2 *)ptr, "impltns:transferSubmit2");
	case SOAP_TYPE_fts3_impltns__transferSubmit2Response:
		return soap_out_impltns__transferSubmit2Response(soap, tag, id, (const struct impltns__transferSubmit2Response *)ptr, "impltns:transferSubmit2Response");
	case SOAP_TYPE_fts3_impltns__transferSubmit:
		return soap_out_impltns__transferSubmit(soap, tag, id, (const struct impltns__transferSubmit *)ptr, "impltns:transferSubmit");
	case SOAP_TYPE_fts3_impltns__transferSubmitResponse:
		return soap_out_impltns__transferSubmitResponse(soap, tag, id, (const struct impltns__transferSubmitResponse *)ptr, "impltns:transferSubmitResponse");
	case SOAP_TYPE_fts3_implcfg__setQueueTimeout:
		return soap_out_implcfg__setQueueTimeout(soap, tag, id, (const struct implcfg__setQueueTimeout *)ptr, "implcfg:setQueueTimeout");
	case SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse:
		return soap_out_implcfg__setQueueTimeoutResponse(soap, tag, id, (const struct implcfg__setQueueTimeoutResponse *)ptr, "implcfg:setQueueTimeoutResponse");
	case SOAP_TYPE_fts3_implcfg__setRetry:
		return soap_out_implcfg__setRetry(soap, tag, id, (const struct implcfg__setRetry *)ptr, "implcfg:setRetry");
	case SOAP_TYPE_fts3_implcfg__setRetryResponse:
		return soap_out_implcfg__setRetryResponse(soap, tag, id, (const struct implcfg__setRetryResponse *)ptr, "implcfg:setRetryResponse");
	case SOAP_TYPE_fts3_implcfg__doDrain:
		return soap_out_implcfg__doDrain(soap, tag, id, (const struct implcfg__doDrain *)ptr, "implcfg:doDrain");
	case SOAP_TYPE_fts3_implcfg__doDrainResponse:
		return soap_out_implcfg__doDrainResponse(soap, tag, id, (const struct implcfg__doDrainResponse *)ptr, "implcfg:doDrainResponse");
	case SOAP_TYPE_fts3_implcfg__getConfiguration:
		return soap_out_implcfg__getConfiguration(soap, tag, id, (const struct implcfg__getConfiguration *)ptr, "implcfg:getConfiguration");
	case SOAP_TYPE_fts3_implcfg__getConfigurationResponse:
		return soap_out_implcfg__getConfigurationResponse(soap, tag, id, (const struct implcfg__getConfigurationResponse *)ptr, "implcfg:getConfigurationResponse");
	case SOAP_TYPE_fts3_implcfg__delConfiguration:
		return soap_out_implcfg__delConfiguration(soap, tag, id, (const struct implcfg__delConfiguration *)ptr, "implcfg:delConfiguration");
	case SOAP_TYPE_fts3_implcfg__delConfigurationResponse:
		return soap_out_implcfg__delConfigurationResponse(soap, tag, id, (const struct implcfg__delConfigurationResponse *)ptr, "implcfg:delConfigurationResponse");
	case SOAP_TYPE_fts3_implcfg__setConfiguration:
		return soap_out_implcfg__setConfiguration(soap, tag, id, (const struct implcfg__setConfiguration *)ptr, "implcfg:setConfiguration");
	case SOAP_TYPE_fts3_implcfg__setConfigurationResponse:
		return soap_out_implcfg__setConfigurationResponse(soap, tag, id, (const struct implcfg__setConfigurationResponse *)ptr, "implcfg:setConfigurationResponse");
	case SOAP_TYPE_fts3_delegation__destroy:
		return soap_out_delegation__destroy(soap, tag, id, (const struct delegation__destroy *)ptr, "delegation:destroy");
	case SOAP_TYPE_fts3_delegation__destroyResponse:
		return soap_out_delegation__destroyResponse(soap, tag, id, (const struct delegation__destroyResponse *)ptr, "delegation:destroyResponse");
	case SOAP_TYPE_fts3_delegation__getTerminationTime:
		return soap_out_delegation__getTerminationTime(soap, tag, id, (const struct delegation__getTerminationTime *)ptr, "delegation:getTerminationTime");
	case SOAP_TYPE_fts3_delegation__getTerminationTimeResponse:
		return soap_out_delegation__getTerminationTimeResponse(soap, tag, id, (const struct delegation__getTerminationTimeResponse *)ptr, "delegation:getTerminationTimeResponse");
	case SOAP_TYPE_fts3_delegation__putProxy:
		return soap_out_delegation__putProxy(soap, tag, id, (const struct delegation__putProxy *)ptr, "delegation:putProxy");
	case SOAP_TYPE_fts3_delegation__putProxyResponse:
		return soap_out_delegation__putProxyResponse(soap, tag, id, (const struct delegation__putProxyResponse *)ptr, "delegation:putProxyResponse");
	case SOAP_TYPE_fts3_delegation__renewProxyReq:
		return soap_out_delegation__renewProxyReq(soap, tag, id, (const struct delegation__renewProxyReq *)ptr, "delegation:renewProxyReq");
	case SOAP_TYPE_fts3_delegation__renewProxyReqResponse:
		return soap_out_delegation__renewProxyReqResponse(soap, tag, id, (const struct delegation__renewProxyReqResponse *)ptr, "delegation:renewProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getNewProxyReq:
		return soap_out_delegation__getNewProxyReq(soap, tag, id, (const struct delegation__getNewProxyReq *)ptr, "delegation:getNewProxyReq");
	case SOAP_TYPE_fts3_delegation__getNewProxyReqResponse:
		return soap_out_delegation__getNewProxyReqResponse(soap, tag, id, (const struct delegation__getNewProxyReqResponse *)ptr, "delegation:getNewProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getProxyReq:
		return soap_out_delegation__getProxyReq(soap, tag, id, (const struct delegation__getProxyReq *)ptr, "delegation:getProxyReq");
	case SOAP_TYPE_fts3_delegation__getProxyReqResponse:
		return soap_out_delegation__getProxyReqResponse(soap, tag, id, (const struct delegation__getProxyReqResponse *)ptr, "delegation:getProxyReqResponse");
	case SOAP_TYPE_fts3_delegation__getServiceMetadata:
		return soap_out_delegation__getServiceMetadata(soap, tag, id, (const struct delegation__getServiceMetadata *)ptr, "delegation:getServiceMetadata");
	case SOAP_TYPE_fts3_delegation__getServiceMetadataResponse:
		return soap_out_delegation__getServiceMetadataResponse(soap, tag, id, (const struct delegation__getServiceMetadataResponse *)ptr, "delegation:getServiceMetadataResponse");
	case SOAP_TYPE_fts3_delegation__getInterfaceVersion:
		return soap_out_delegation__getInterfaceVersion(soap, tag, id, (const struct delegation__getInterfaceVersion *)ptr, "delegation:getInterfaceVersion");
	case SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse:
		return soap_out_delegation__getInterfaceVersionResponse(soap, tag, id, (const struct delegation__getInterfaceVersionResponse *)ptr, "delegation:getInterfaceVersionResponse");
	case SOAP_TYPE_fts3_delegation__getVersion:
		return soap_out_delegation__getVersion(soap, tag, id, (const struct delegation__getVersion *)ptr, "delegation:getVersion");
	case SOAP_TYPE_fts3_delegation__getVersionResponse:
		return soap_out_delegation__getVersionResponse(soap, tag, id, (const struct delegation__getVersionResponse *)ptr, "delegation:getVersionResponse");
	case SOAP_TYPE_fts3__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
	case SOAP_TYPE_fts3_PointerTolog__LogInternal:
		return soap_out_PointerTolog__LogInternal(soap, tag, id, (log__LogInternal *const*)ptr, "log:LogInternal");
	case SOAP_TYPE_fts3_PointerTotns3__Roles:
		return soap_out_PointerTotns3__Roles(soap, tag, id, (tns3__Roles *const*)ptr, "tns3:Roles");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary2:
		return soap_out_PointerTotns3__TransferJobSummary2(soap, tag, id, (tns3__TransferJobSummary2 *const*)ptr, "tns3:TransferJobSummary2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary:
		return soap_out_PointerTotns3__TransferJobSummary(soap, tag, id, (tns3__TransferJobSummary *const*)ptr, "tns3:TransferJobSummary");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, id, (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*)ptr, "impltns:ArrayOf_tns3_FileTransferStatus2");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, id, (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*)ptr, "impltns:ArrayOf_tns3_FileTransferStatus");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring:
		return soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, id, (impltns__ArrayOf_USCOREsoapenc_USCOREstring *const*)ptr, "impltns:ArrayOf_soapenc_string");
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		return soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, id, (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *const*)ptr, "impltns:ArrayOf_tns3_JobStatus");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob3:
		return soap_out_PointerTotns3__TransferJob3(soap, tag, id, (tns3__TransferJob3 *const*)ptr, "tns3:TransferJob3");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob2:
		return soap_out_PointerTotns3__TransferJob2(soap, tag, id, (tns3__TransferJob2 *const*)ptr, "tns3:TransferJob2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob:
		return soap_out_PointerTotns3__TransferJob(soap, tag, id, (tns3__TransferJob *const*)ptr, "tns3:TransferJob");
	case SOAP_TYPE_fts3_PointerToconfig__Configuration:
		return soap_out_PointerToconfig__Configuration(soap, tag, id, (config__Configuration *const*)ptr, "config:Configuration");
	case SOAP_TYPE_fts3_PointerTodelegation__NewProxyReq:
		return soap_out_PointerTodelegation__NewProxyReq(soap, tag, id, (delegation__NewProxyReq *const*)ptr, "delegation:NewProxyReq");
	case SOAP_TYPE_fts3_PointerTotns3__ServiceBusyException:
		return soap_out_PointerTotns3__ServiceBusyException(soap, tag, id, (tns3__ServiceBusyException *const*)ptr, "tns3:ServiceBusyException");
	case SOAP_TYPE_fts3_PointerTotns3__NotExistsException:
		return soap_out_PointerTotns3__NotExistsException(soap, tag, id, (tns3__NotExistsException *const*)ptr, "tns3:NotExistsException");
	case SOAP_TYPE_fts3_PointerTotns3__InvalidArgumentException:
		return soap_out_PointerTotns3__InvalidArgumentException(soap, tag, id, (tns3__InvalidArgumentException *const*)ptr, "tns3:InvalidArgumentException");
	case SOAP_TYPE_fts3_PointerTotns3__InternalException:
		return soap_out_PointerTotns3__InternalException(soap, tag, id, (tns3__InternalException *const*)ptr, "tns3:InternalException");
	case SOAP_TYPE_fts3_PointerTotns3__ExistsException:
		return soap_out_PointerTotns3__ExistsException(soap, tag, id, (tns3__ExistsException *const*)ptr, "tns3:ExistsException");
	case SOAP_TYPE_fts3_PointerTotns3__CannotCancelException:
		return soap_out_PointerTotns3__CannotCancelException(soap, tag, id, (tns3__CannotCancelException *const*)ptr, "tns3:CannotCancelException");
	case SOAP_TYPE_fts3_PointerTotns3__AuthorizationException:
		return soap_out_PointerTotns3__AuthorizationException(soap, tag, id, (tns3__AuthorizationException *const*)ptr, "tns3:AuthorizationException");
	case SOAP_TYPE_fts3_PointerToconfig__ServiceBusyException:
		return soap_out_PointerToconfig__ServiceBusyException(soap, tag, id, (config__ServiceBusyException *const*)ptr, "config:ServiceBusyException");
	case SOAP_TYPE_fts3_PointerToconfig__InvalidConfigurationException:
		return soap_out_PointerToconfig__InvalidConfigurationException(soap, tag, id, (config__InvalidConfigurationException *const*)ptr, "config:InvalidConfigurationException");
	case SOAP_TYPE_fts3_PointerToconfig__InternalException:
		return soap_out_PointerToconfig__InternalException(soap, tag, id, (config__InternalException *const*)ptr, "config:InternalException");
	case SOAP_TYPE_fts3_PointerToconfig__AuthorizationException:
		return soap_out_PointerToconfig__AuthorizationException(soap, tag, id, (config__AuthorizationException *const*)ptr, "config:AuthorizationException");
	case SOAP_TYPE_fts3_PointerTo_delegation__DelegationException:
		return soap_out_PointerTo_delegation__DelegationException(soap, tag, id, (_delegation__DelegationException *const*)ptr, "delegation:DelegationException");
	case SOAP_TYPE_fts3_PointerTolog__Log:
		return soap_out_PointerTolog__Log(soap, tag, id, (log__Log *const*)ptr, "log:Log");
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus2:
		return soap_out_PointerTotns3__FileTransferStatus2(soap, tag, id, (tns3__FileTransferStatus2 *const*)ptr, "tns3:FileTransferStatus2");
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus:
		return soap_out_PointerTotns3__FileTransferStatus(soap, tag, id, (tns3__FileTransferStatus *const*)ptr, "tns3:FileTransferStatus");
	case SOAP_TYPE_fts3_PointerTotns3__StringPair:
		return soap_out_PointerTotns3__StringPair(soap, tag, id, (tns3__StringPair *const*)ptr, "tns3:StringPair");
	case SOAP_TYPE_fts3_PointerTotns3__JobStatus:
		return soap_out_PointerTotns3__JobStatus(soap, tag, id, (tns3__JobStatus *const*)ptr, "tns3:JobStatus");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement3:
		return soap_out_PointerTotns3__TransferJobElement3(soap, tag, id, (tns3__TransferJobElement3 *const*)ptr, "tns3:TransferJobElement3");
	case SOAP_TYPE_fts3_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement2:
		return soap_out_PointerTotns3__TransferJobElement2(soap, tag, id, (tns3__TransferJobElement2 *const*)ptr, "tns3:TransferJobElement2");
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement:
		return soap_out_PointerTotns3__TransferJobElement(soap, tag, id, (tns3__TransferJobElement *const*)ptr, "tns3:TransferJobElement");
	case SOAP_TYPE_fts3_PointerTotns3__TransferParams:
		return soap_out_PointerTotns3__TransferParams(soap, tag, id, (tns3__TransferParams *const*)ptr, "tns3:TransferParams");
	case SOAP_TYPE_fts3_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_fts3_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_fts3__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_fts3_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_fts3_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_fts3_log__LogInternal:
		((log__LogInternal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_log__Log:
		((log__Log *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3__delegation__DelegationException:
		((_delegation__DelegationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_delegation__NewProxyReq:
		((delegation__NewProxyReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__InternalException:
		((config__InternalException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__ServiceBusyException:
		((config__ServiceBusyException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__AuthorizationException:
		((config__AuthorizationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__InvalidConfigurationException:
		((config__InvalidConfigurationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__ConfigurationException:
		((config__ConfigurationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_config__Configuration:
		((config__Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		((impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring:
		((impltns__ArrayOf_USCOREsoapenc_USCOREstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__Roles:
		((tns3__Roles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__StringPair:
		((tns3__StringPair *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__ExistsException:
		((tns3__ExistsException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__CannotCancelException:
		((tns3__CannotCancelException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobSummary2:
		((tns3__TransferJobSummary2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobSummary:
		((tns3__TransferJobSummary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__FileTransferStatus2:
		((tns3__FileTransferStatus2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__NotExistsException:
		((tns3__NotExistsException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__FileTransferStatus:
		((tns3__FileTransferStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__JobStatus:
		((tns3__JobStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob3:
		((tns3__TransferJob3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement3:
		((tns3__TransferJobElement3 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob2:
		((tns3__TransferJob2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement2:
		((tns3__TransferJobElement2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob:
		((tns3__TransferJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement:
		((tns3__TransferJobElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__InternalException:
		((tns3__InternalException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__ServiceBusyException:
		((tns3__ServiceBusyException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__AuthorizationException:
		((tns3__AuthorizationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__InvalidArgumentException:
		((tns3__InvalidArgumentException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferException:
		((tns3__TransferException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__PlacementJob:
		((tns3__PlacementJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_tns3__TransferParams:
		((tns3__TransferParams *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fts3_log__GetLogInternal:
		soap_serialize_log__GetLogInternal(soap, (const struct log__GetLogInternal *)ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLogInternalResponse:
		soap_serialize_log__GetLogInternalResponse(soap, (const struct log__GetLogInternalResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLog:
		soap_serialize_log__GetLog(soap, (const struct log__GetLog *)ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLogResponse:
		soap_serialize_log__GetLogResponse(soap, (const struct log__GetLogResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getServiceMetadata:
		soap_serialize_impltns__getServiceMetadata(soap, (const struct impltns__getServiceMetadata *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getServiceMetadataResponse:
		soap_serialize_impltns__getServiceMetadataResponse(soap, (const struct impltns__getServiceMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getInterfaceVersion:
		soap_serialize_impltns__getInterfaceVersion(soap, (const struct impltns__getInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse:
		soap_serialize_impltns__getInterfaceVersionResponse(soap, (const struct impltns__getInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getSchemaVersion:
		soap_serialize_impltns__getSchemaVersion(soap, (const struct impltns__getSchemaVersion *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getSchemaVersionResponse:
		soap_serialize_impltns__getSchemaVersionResponse(soap, (const struct impltns__getSchemaVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getVersion:
		soap_serialize_impltns__getVersion(soap, (const struct impltns__getVersion *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getVersionResponse:
		soap_serialize_impltns__getVersionResponse(soap, (const struct impltns__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesOf:
		soap_serialize_impltns__getRolesOf(soap, (const struct impltns__getRolesOf *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesOfResponse:
		soap_serialize_impltns__getRolesOfResponse(soap, (const struct impltns__getRolesOfResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRoles:
		soap_serialize_impltns__getRoles(soap, (const struct impltns__getRoles *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesResponse:
		soap_serialize_impltns__getRolesResponse(soap, (const struct impltns__getRolesResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listVOManagers:
		soap_serialize_impltns__listVOManagers(soap, (const struct impltns__listVOManagers *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listVOManagersResponse:
		soap_serialize_impltns__listVOManagersResponse(soap, (const struct impltns__listVOManagersResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__removeVOManager:
		soap_serialize_impltns__removeVOManager(soap, (const struct impltns__removeVOManager *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__removeVOManagerResponse:
		soap_serialize_impltns__removeVOManagerResponse(soap, (const struct impltns__removeVOManagerResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__addVOManager:
		soap_serialize_impltns__addVOManager(soap, (const struct impltns__addVOManager *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__addVOManagerResponse:
		soap_serialize_impltns__addVOManagerResponse(soap, (const struct impltns__addVOManagerResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__setJobPriority:
		soap_serialize_impltns__setJobPriority(soap, (const struct impltns__setJobPriority *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__setJobPriorityResponse:
		soap_serialize_impltns__setJobPriorityResponse(soap, (const struct impltns__setJobPriorityResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__cancel:
		soap_serialize_impltns__cancel(soap, (const struct impltns__cancel *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__cancelResponse:
		soap_serialize_impltns__cancelResponse(soap, (const struct impltns__cancelResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2:
		soap_serialize_impltns__getTransferJobSummary2(soap, (const struct impltns__getTransferJobSummary2 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response:
		soap_serialize_impltns__getTransferJobSummary2Response(soap, (const struct impltns__getTransferJobSummary2Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary:
		soap_serialize_impltns__getTransferJobSummary(soap, (const struct impltns__getTransferJobSummary *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse:
		soap_serialize_impltns__getTransferJobSummaryResponse(soap, (const struct impltns__getTransferJobSummaryResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobStatus:
		soap_serialize_impltns__getTransferJobStatus(soap, (const struct impltns__getTransferJobStatus *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse:
		soap_serialize_impltns__getTransferJobStatusResponse(soap, (const struct impltns__getTransferJobStatusResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus2:
		soap_serialize_impltns__getFileStatus2(soap, (const struct impltns__getFileStatus2 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus2Response:
		soap_serialize_impltns__getFileStatus2Response(soap, (const struct impltns__getFileStatus2Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus:
		soap_serialize_impltns__getFileStatus(soap, (const struct impltns__getFileStatus *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatusResponse:
		soap_serialize_impltns__getFileStatusResponse(soap, (const struct impltns__getFileStatusResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests2:
		soap_serialize_impltns__listRequests2(soap, (const struct impltns__listRequests2 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests2Response:
		soap_serialize_impltns__listRequests2Response(soap, (const struct impltns__listRequests2Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests:
		soap_serialize_impltns__listRequests(soap, (const struct impltns__listRequests *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequestsResponse:
		soap_serialize_impltns__listRequestsResponse(soap, (const struct impltns__listRequestsResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__blacklist:
		soap_serialize_impltns__blacklist(soap, (const struct impltns__blacklist *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__blacklistResponse:
		soap_serialize_impltns__blacklistResponse(soap, (const struct impltns__blacklistResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__debugSet:
		soap_serialize_impltns__debugSet(soap, (const struct impltns__debugSet *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__debugSetResponse:
		soap_serialize_impltns__debugSetResponse(soap, (const struct impltns__debugSetResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__prioritySet:
		soap_serialize_impltns__prioritySet(soap, (const struct impltns__prioritySet *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__prioritySetResponse:
		soap_serialize_impltns__prioritySetResponse(soap, (const struct impltns__prioritySetResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit4:
		soap_serialize_impltns__transferSubmit4(soap, (const struct impltns__transferSubmit4 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit4Response:
		soap_serialize_impltns__transferSubmit4Response(soap, (const struct impltns__transferSubmit4Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit3:
		soap_serialize_impltns__transferSubmit3(soap, (const struct impltns__transferSubmit3 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit3Response:
		soap_serialize_impltns__transferSubmit3Response(soap, (const struct impltns__transferSubmit3Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit2:
		soap_serialize_impltns__transferSubmit2(soap, (const struct impltns__transferSubmit2 *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit2Response:
		soap_serialize_impltns__transferSubmit2Response(soap, (const struct impltns__transferSubmit2Response *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit:
		soap_serialize_impltns__transferSubmit(soap, (const struct impltns__transferSubmit *)ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmitResponse:
		soap_serialize_impltns__transferSubmitResponse(soap, (const struct impltns__transferSubmitResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setQueueTimeout:
		soap_serialize_implcfg__setQueueTimeout(soap, (const struct implcfg__setQueueTimeout *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse:
		soap_serialize_implcfg__setQueueTimeoutResponse(soap, (const struct implcfg__setQueueTimeoutResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setRetry:
		soap_serialize_implcfg__setRetry(soap, (const struct implcfg__setRetry *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setRetryResponse:
		soap_serialize_implcfg__setRetryResponse(soap, (const struct implcfg__setRetryResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__doDrain:
		soap_serialize_implcfg__doDrain(soap, (const struct implcfg__doDrain *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__doDrainResponse:
		soap_serialize_implcfg__doDrainResponse(soap, (const struct implcfg__doDrainResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__getConfiguration:
		soap_serialize_implcfg__getConfiguration(soap, (const struct implcfg__getConfiguration *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__getConfigurationResponse:
		soap_serialize_implcfg__getConfigurationResponse(soap, (const struct implcfg__getConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__delConfiguration:
		soap_serialize_implcfg__delConfiguration(soap, (const struct implcfg__delConfiguration *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__delConfigurationResponse:
		soap_serialize_implcfg__delConfigurationResponse(soap, (const struct implcfg__delConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setConfiguration:
		soap_serialize_implcfg__setConfiguration(soap, (const struct implcfg__setConfiguration *)ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setConfigurationResponse:
		soap_serialize_implcfg__setConfigurationResponse(soap, (const struct implcfg__setConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__destroy:
		soap_serialize_delegation__destroy(soap, (const struct delegation__destroy *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__destroyResponse:
		soap_serialize_delegation__destroyResponse(soap, (const struct delegation__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getTerminationTime:
		soap_serialize_delegation__getTerminationTime(soap, (const struct delegation__getTerminationTime *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getTerminationTimeResponse:
		soap_serialize_delegation__getTerminationTimeResponse(soap, (const struct delegation__getTerminationTimeResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__putProxy:
		soap_serialize_delegation__putProxy(soap, (const struct delegation__putProxy *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__putProxyResponse:
		soap_serialize_delegation__putProxyResponse(soap, (const struct delegation__putProxyResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__renewProxyReq:
		soap_serialize_delegation__renewProxyReq(soap, (const struct delegation__renewProxyReq *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__renewProxyReqResponse:
		soap_serialize_delegation__renewProxyReqResponse(soap, (const struct delegation__renewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getNewProxyReq:
		soap_serialize_delegation__getNewProxyReq(soap, (const struct delegation__getNewProxyReq *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getNewProxyReqResponse:
		soap_serialize_delegation__getNewProxyReqResponse(soap, (const struct delegation__getNewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getProxyReq:
		soap_serialize_delegation__getProxyReq(soap, (const struct delegation__getProxyReq *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getProxyReqResponse:
		soap_serialize_delegation__getProxyReqResponse(soap, (const struct delegation__getProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getServiceMetadata:
		soap_serialize_delegation__getServiceMetadata(soap, (const struct delegation__getServiceMetadata *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getServiceMetadataResponse:
		soap_serialize_delegation__getServiceMetadataResponse(soap, (const struct delegation__getServiceMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getInterfaceVersion:
		soap_serialize_delegation__getInterfaceVersion(soap, (const struct delegation__getInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse:
		soap_serialize_delegation__getInterfaceVersionResponse(soap, (const struct delegation__getInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getVersion:
		soap_serialize_delegation__getVersion(soap, (const struct delegation__getVersion *)ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getVersionResponse:
		soap_serialize_delegation__getVersionResponse(soap, (const struct delegation__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_fts3__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTolog__LogInternal:
		soap_serialize_PointerTolog__LogInternal(soap, (log__LogInternal *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__Roles:
		soap_serialize_PointerTotns3__Roles(soap, (tns3__Roles *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary2:
		soap_serialize_PointerTotns3__TransferJobSummary2(soap, (tns3__TransferJobSummary2 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary:
		soap_serialize_PointerTotns3__TransferJobSummary(soap, (tns3__TransferJobSummary *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring:
		soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, (impltns__ArrayOf_USCOREsoapenc_USCOREstring *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob3:
		soap_serialize_PointerTotns3__TransferJob3(soap, (tns3__TransferJob3 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob2:
		soap_serialize_PointerTotns3__TransferJob2(soap, (tns3__TransferJob2 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJob:
		soap_serialize_PointerTotns3__TransferJob(soap, (tns3__TransferJob *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToconfig__Configuration:
		soap_serialize_PointerToconfig__Configuration(soap, (config__Configuration *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTodelegation__NewProxyReq:
		soap_serialize_PointerTodelegation__NewProxyReq(soap, (delegation__NewProxyReq *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__ServiceBusyException:
		soap_serialize_PointerTotns3__ServiceBusyException(soap, (tns3__ServiceBusyException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__NotExistsException:
		soap_serialize_PointerTotns3__NotExistsException(soap, (tns3__NotExistsException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__InvalidArgumentException:
		soap_serialize_PointerTotns3__InvalidArgumentException(soap, (tns3__InvalidArgumentException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__InternalException:
		soap_serialize_PointerTotns3__InternalException(soap, (tns3__InternalException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__ExistsException:
		soap_serialize_PointerTotns3__ExistsException(soap, (tns3__ExistsException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__CannotCancelException:
		soap_serialize_PointerTotns3__CannotCancelException(soap, (tns3__CannotCancelException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__AuthorizationException:
		soap_serialize_PointerTotns3__AuthorizationException(soap, (tns3__AuthorizationException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToconfig__ServiceBusyException:
		soap_serialize_PointerToconfig__ServiceBusyException(soap, (config__ServiceBusyException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToconfig__InvalidConfigurationException:
		soap_serialize_PointerToconfig__InvalidConfigurationException(soap, (config__InvalidConfigurationException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToconfig__InternalException:
		soap_serialize_PointerToconfig__InternalException(soap, (config__InternalException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToconfig__AuthorizationException:
		soap_serialize_PointerToconfig__AuthorizationException(soap, (config__AuthorizationException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTo_delegation__DelegationException:
		soap_serialize_PointerTo_delegation__DelegationException(soap, (_delegation__DelegationException *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTolog__Log:
		soap_serialize_PointerTolog__Log(soap, (log__Log *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus2:
		soap_serialize_PointerTotns3__FileTransferStatus2(soap, (tns3__FileTransferStatus2 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus:
		soap_serialize_PointerTotns3__FileTransferStatus(soap, (tns3__FileTransferStatus *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__StringPair:
		soap_serialize_PointerTotns3__StringPair(soap, (tns3__StringPair *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__JobStatus:
		soap_serialize_PointerTotns3__JobStatus(soap, (tns3__JobStatus *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement3:
		soap_serialize_PointerTotns3__TransferJobElement3(soap, (tns3__TransferJobElement3 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement2:
		soap_serialize_PointerTotns3__TransferJobElement2(soap, (tns3__TransferJobElement2 *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferJobElement:
		soap_serialize_PointerTotns3__TransferJobElement(soap, (tns3__TransferJobElement *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTotns3__TransferParams:
		soap_serialize_PointerTotns3__TransferParams(soap, (tns3__TransferParams *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_fts3_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_fts3__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_fts3_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_fts3__xop__Include:
		return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferParams:
		return (void*)soap_instantiate_tns3__TransferParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__PlacementJob:
		return (void*)soap_instantiate_tns3__PlacementJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferException:
		return (void*)soap_instantiate_tns3__TransferException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJobElement:
		return (void*)soap_instantiate_tns3__TransferJobElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJob:
		return (void*)soap_instantiate_tns3__TransferJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJobElement2:
		return (void*)soap_instantiate_tns3__TransferJobElement2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJob2:
		return (void*)soap_instantiate_tns3__TransferJob2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJobElement3:
		return (void*)soap_instantiate_tns3__TransferJobElement3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJob3:
		return (void*)soap_instantiate_tns3__TransferJob3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__JobStatus:
		return (void*)soap_instantiate_tns3__JobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__FileTransferStatus:
		return (void*)soap_instantiate_tns3__FileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJobSummary:
		return (void*)soap_instantiate_tns3__TransferJobSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__StringPair:
		return (void*)soap_instantiate_tns3__StringPair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__Roles:
		return (void*)soap_instantiate_tns3__Roles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring:
		return (void*)soap_instantiate_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		return (void*)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		return (void*)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		return (void*)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__Configuration:
		return (void*)soap_instantiate_config__Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__ConfigurationException:
		return (void*)soap_instantiate_config__ConfigurationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__NewProxyReq:
		return (void*)soap_instantiate_delegation__NewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3__delegation__DelegationException:
		return (void*)soap_instantiate__delegation__DelegationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__Log:
		return (void*)soap_instantiate_log__Log(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__LogInternal:
		return (void*)soap_instantiate_log__LogInternal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__InvalidArgumentException:
		return (void*)soap_instantiate_tns3__InvalidArgumentException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__AuthorizationException:
		return (void*)soap_instantiate_tns3__AuthorizationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__ServiceBusyException:
		return (void*)soap_instantiate_tns3__ServiceBusyException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__InternalException:
		return (void*)soap_instantiate_tns3__InternalException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__NotExistsException:
		return (void*)soap_instantiate_tns3__NotExistsException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__FileTransferStatus2:
		return (void*)soap_instantiate_tns3__FileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__TransferJobSummary2:
		return (void*)soap_instantiate_tns3__TransferJobSummary2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__CannotCancelException:
		return (void*)soap_instantiate_tns3__CannotCancelException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_tns3__ExistsException:
		return (void*)soap_instantiate_tns3__ExistsException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__InvalidConfigurationException:
		return (void*)soap_instantiate_config__InvalidConfigurationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__AuthorizationException:
		return (void*)soap_instantiate_config__AuthorizationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__ServiceBusyException:
		return (void*)soap_instantiate_config__ServiceBusyException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_config__InternalException:
		return (void*)soap_instantiate_config__InternalException(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_fts3_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_fts3_delegation__getVersionResponse:
		return (void*)soap_instantiate_delegation__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getVersion:
		return (void*)soap_instantiate_delegation__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse:
		return (void*)soap_instantiate_delegation__getInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getInterfaceVersion:
		return (void*)soap_instantiate_delegation__getInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getServiceMetadataResponse:
		return (void*)soap_instantiate_delegation__getServiceMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getServiceMetadata:
		return (void*)soap_instantiate_delegation__getServiceMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getProxyReqResponse:
		return (void*)soap_instantiate_delegation__getProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getProxyReq:
		return (void*)soap_instantiate_delegation__getProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getNewProxyReqResponse:
		return (void*)soap_instantiate_delegation__getNewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getNewProxyReq:
		return (void*)soap_instantiate_delegation__getNewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__renewProxyReqResponse:
		return (void*)soap_instantiate_delegation__renewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__renewProxyReq:
		return (void*)soap_instantiate_delegation__renewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__putProxyResponse:
		return (void*)soap_instantiate_delegation__putProxyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__putProxy:
		return (void*)soap_instantiate_delegation__putProxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getTerminationTimeResponse:
		return (void*)soap_instantiate_delegation__getTerminationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__getTerminationTime:
		return (void*)soap_instantiate_delegation__getTerminationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__destroyResponse:
		return (void*)soap_instantiate_delegation__destroyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_delegation__destroy:
		return (void*)soap_instantiate_delegation__destroy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setConfigurationResponse:
		return (void*)soap_instantiate_implcfg__setConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setConfiguration:
		return (void*)soap_instantiate_implcfg__setConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__delConfigurationResponse:
		return (void*)soap_instantiate_implcfg__delConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__delConfiguration:
		return (void*)soap_instantiate_implcfg__delConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__getConfigurationResponse:
		return (void*)soap_instantiate_implcfg__getConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__getConfiguration:
		return (void*)soap_instantiate_implcfg__getConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__doDrainResponse:
		return (void*)soap_instantiate_implcfg__doDrainResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__doDrain:
		return (void*)soap_instantiate_implcfg__doDrain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setRetryResponse:
		return (void*)soap_instantiate_implcfg__setRetryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setRetry:
		return (void*)soap_instantiate_implcfg__setRetry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse:
		return (void*)soap_instantiate_implcfg__setQueueTimeoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_implcfg__setQueueTimeout:
		return (void*)soap_instantiate_implcfg__setQueueTimeout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmitResponse:
		return (void*)soap_instantiate_impltns__transferSubmitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit:
		return (void*)soap_instantiate_impltns__transferSubmit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit2Response:
		return (void*)soap_instantiate_impltns__transferSubmit2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit2:
		return (void*)soap_instantiate_impltns__transferSubmit2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit3Response:
		return (void*)soap_instantiate_impltns__transferSubmit3Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit3:
		return (void*)soap_instantiate_impltns__transferSubmit3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit4Response:
		return (void*)soap_instantiate_impltns__transferSubmit4Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__transferSubmit4:
		return (void*)soap_instantiate_impltns__transferSubmit4(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__prioritySetResponse:
		return (void*)soap_instantiate_impltns__prioritySetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__prioritySet:
		return (void*)soap_instantiate_impltns__prioritySet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__debugSetResponse:
		return (void*)soap_instantiate_impltns__debugSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__debugSet:
		return (void*)soap_instantiate_impltns__debugSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__blacklistResponse:
		return (void*)soap_instantiate_impltns__blacklistResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__blacklist:
		return (void*)soap_instantiate_impltns__blacklist(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listRequestsResponse:
		return (void*)soap_instantiate_impltns__listRequestsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listRequests:
		return (void*)soap_instantiate_impltns__listRequests(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listRequests2Response:
		return (void*)soap_instantiate_impltns__listRequests2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listRequests2:
		return (void*)soap_instantiate_impltns__listRequests2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getFileStatusResponse:
		return (void*)soap_instantiate_impltns__getFileStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getFileStatus:
		return (void*)soap_instantiate_impltns__getFileStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getFileStatus2Response:
		return (void*)soap_instantiate_impltns__getFileStatus2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getFileStatus2:
		return (void*)soap_instantiate_impltns__getFileStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse:
		return (void*)soap_instantiate_impltns__getTransferJobStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobStatus:
		return (void*)soap_instantiate_impltns__getTransferJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse:
		return (void*)soap_instantiate_impltns__getTransferJobSummaryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary:
		return (void*)soap_instantiate_impltns__getTransferJobSummary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response:
		return (void*)soap_instantiate_impltns__getTransferJobSummary2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2:
		return (void*)soap_instantiate_impltns__getTransferJobSummary2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__cancelResponse:
		return (void*)soap_instantiate_impltns__cancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__cancel:
		return (void*)soap_instantiate_impltns__cancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__setJobPriorityResponse:
		return (void*)soap_instantiate_impltns__setJobPriorityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__setJobPriority:
		return (void*)soap_instantiate_impltns__setJobPriority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__addVOManagerResponse:
		return (void*)soap_instantiate_impltns__addVOManagerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__addVOManager:
		return (void*)soap_instantiate_impltns__addVOManager(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__removeVOManagerResponse:
		return (void*)soap_instantiate_impltns__removeVOManagerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__removeVOManager:
		return (void*)soap_instantiate_impltns__removeVOManager(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listVOManagersResponse:
		return (void*)soap_instantiate_impltns__listVOManagersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__listVOManagers:
		return (void*)soap_instantiate_impltns__listVOManagers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getRolesResponse:
		return (void*)soap_instantiate_impltns__getRolesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getRoles:
		return (void*)soap_instantiate_impltns__getRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getRolesOfResponse:
		return (void*)soap_instantiate_impltns__getRolesOfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getRolesOf:
		return (void*)soap_instantiate_impltns__getRolesOf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getVersionResponse:
		return (void*)soap_instantiate_impltns__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getVersion:
		return (void*)soap_instantiate_impltns__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getSchemaVersionResponse:
		return (void*)soap_instantiate_impltns__getSchemaVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getSchemaVersion:
		return (void*)soap_instantiate_impltns__getSchemaVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse:
		return (void*)soap_instantiate_impltns__getInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getInterfaceVersion:
		return (void*)soap_instantiate_impltns__getInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getServiceMetadataResponse:
		return (void*)soap_instantiate_impltns__getServiceMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_impltns__getServiceMetadata:
		return (void*)soap_instantiate_impltns__getServiceMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__GetLogResponse:
		return (void*)soap_instantiate_log__GetLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__GetLog:
		return (void*)soap_instantiate_log__GetLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__GetLogInternalResponse:
		return (void*)soap_instantiate_log__GetLogInternalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_log__GetLogInternal:
		return (void*)soap_instantiate_log__GetLogInternal(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_fts3_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_fts3_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_fts3_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_fts3_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTolog__Log:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTolog__Log(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__JobStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__JobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__StringPair:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__StringPair(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement3:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement2:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fts3_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_fts3__xop__Include:
		if (p->size < 0)
			SOAP_DELETE((struct _xop__Include*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _xop__Include*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferParams:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferParams*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferParams*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__PlacementJob:
		if (p->size < 0)
			SOAP_DELETE((tns3__PlacementJob*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__PlacementJob*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferException:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJobElement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJobElement*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJob*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJob*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement2:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJobElement2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJobElement2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob2:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJob2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJob2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobElement3:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJobElement3*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJobElement3*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJob3:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJob3*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJob3*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__JobStatus:
		if (p->size < 0)
			SOAP_DELETE((tns3__JobStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__JobStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__FileTransferStatus:
		if (p->size < 0)
			SOAP_DELETE((tns3__FileTransferStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__FileTransferStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobSummary:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJobSummary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJobSummary*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__StringPair:
		if (p->size < 0)
			SOAP_DELETE((tns3__StringPair*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__StringPair*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__Roles:
		if (p->size < 0)
			SOAP_DELETE((tns3__Roles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__Roles*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring:
		if (p->size < 0)
			SOAP_DELETE((impltns__ArrayOf_USCOREsoapenc_USCOREstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((impltns__ArrayOf_USCOREsoapenc_USCOREstring*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus:
		if (p->size < 0)
			SOAP_DELETE((impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus:
		if (p->size < 0)
			SOAP_DELETE((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2:
		if (p->size < 0)
			SOAP_DELETE((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__Configuration:
		if (p->size < 0)
			SOAP_DELETE((config__Configuration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__Configuration*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__ConfigurationException:
		if (p->size < 0)
			SOAP_DELETE((config__ConfigurationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__ConfigurationException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__NewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((delegation__NewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((delegation__NewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_fts3__delegation__DelegationException:
		if (p->size < 0)
			SOAP_DELETE((_delegation__DelegationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_delegation__DelegationException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__Log:
		if (p->size < 0)
			SOAP_DELETE((log__Log*)p->ptr);
		else
			SOAP_DELETE_ARRAY((log__Log*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__LogInternal:
		if (p->size < 0)
			SOAP_DELETE((log__LogInternal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((log__LogInternal*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__InvalidArgumentException:
		if (p->size < 0)
			SOAP_DELETE((tns3__InvalidArgumentException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__InvalidArgumentException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__AuthorizationException:
		if (p->size < 0)
			SOAP_DELETE((tns3__AuthorizationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__AuthorizationException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__ServiceBusyException:
		if (p->size < 0)
			SOAP_DELETE((tns3__ServiceBusyException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__ServiceBusyException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__InternalException:
		if (p->size < 0)
			SOAP_DELETE((tns3__InternalException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__InternalException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__NotExistsException:
		if (p->size < 0)
			SOAP_DELETE((tns3__NotExistsException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__NotExistsException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__FileTransferStatus2:
		if (p->size < 0)
			SOAP_DELETE((tns3__FileTransferStatus2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__FileTransferStatus2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__TransferJobSummary2:
		if (p->size < 0)
			SOAP_DELETE((tns3__TransferJobSummary2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__TransferJobSummary2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__CannotCancelException:
		if (p->size < 0)
			SOAP_DELETE((tns3__CannotCancelException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__CannotCancelException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_tns3__ExistsException:
		if (p->size < 0)
			SOAP_DELETE((tns3__ExistsException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns3__ExistsException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__InvalidConfigurationException:
		if (p->size < 0)
			SOAP_DELETE((config__InvalidConfigurationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__InvalidConfigurationException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__AuthorizationException:
		if (p->size < 0)
			SOAP_DELETE((config__AuthorizationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__AuthorizationException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__ServiceBusyException:
		if (p->size < 0)
			SOAP_DELETE((config__ServiceBusyException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__ServiceBusyException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_config__InternalException:
		if (p->size < 0)
			SOAP_DELETE((config__InternalException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((config__InternalException*)p->ptr);
		break;
	case SOAP_TYPE_fts3_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getInterfaceVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getInterfaceVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getInterfaceVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getInterfaceVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getInterfaceVersion*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getServiceMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getServiceMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getServiceMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getServiceMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getServiceMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getServiceMetadata*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getNewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getNewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getNewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getNewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getNewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getNewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__renewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__renewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__renewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__renewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__renewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__renewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__putProxyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__putProxyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__putProxyResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__putProxy:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__putProxy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__putProxy*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getTerminationTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getTerminationTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getTerminationTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__getTerminationTime:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__getTerminationTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__getTerminationTime*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__destroyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__destroyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__destroyResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_delegation__destroy:
		if (p->size < 0)
			SOAP_DELETE((struct delegation__destroy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation__destroy*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setConfigurationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setConfigurationResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setConfiguration:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__delConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__delConfigurationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__delConfigurationResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__delConfiguration:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__delConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__delConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__getConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__getConfigurationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__getConfigurationResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__getConfiguration:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__getConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__getConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__doDrainResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__doDrainResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__doDrainResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__doDrain:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__doDrain*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__doDrain*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setRetryResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setRetryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setRetryResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setRetry:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setRetry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setRetry*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setQueueTimeoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setQueueTimeoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_implcfg__setQueueTimeout:
		if (p->size < 0)
			SOAP_DELETE((struct implcfg__setQueueTimeout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct implcfg__setQueueTimeout*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmitResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmitResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmitResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit2Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit2Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit2Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit2:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit3Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit3Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit3Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit3:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit3*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit3*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit4Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit4Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit4Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__transferSubmit4:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__transferSubmit4*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__transferSubmit4*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__prioritySetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__prioritySetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__prioritySetResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__prioritySet:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__prioritySet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__prioritySet*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__debugSetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__debugSetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__debugSetResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__debugSet:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__debugSet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__debugSet*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__blacklistResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__blacklistResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__blacklistResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__blacklist:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__blacklist*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__blacklist*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequestsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listRequestsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listRequestsResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listRequests*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listRequests*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests2Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listRequests2Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listRequests2Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listRequests2:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listRequests2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listRequests2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getFileStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getFileStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getFileStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getFileStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus2Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getFileStatus2Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getFileStatus2Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getFileStatus2:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getFileStatus2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getFileStatus2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobStatus:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobStatus*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobSummaryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobSummaryResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobSummary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobSummary*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobSummary2Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobSummary2Response*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getTransferJobSummary2:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getTransferJobSummary2*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getTransferJobSummary2*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__cancelResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__cancelResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__cancelResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__cancel:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__cancel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__cancel*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__setJobPriorityResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__setJobPriorityResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__setJobPriorityResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__setJobPriority:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__setJobPriority*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__setJobPriority*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__addVOManagerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__addVOManagerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__addVOManagerResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__addVOManager:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__addVOManager*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__addVOManager*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__removeVOManagerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__removeVOManagerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__removeVOManagerResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__removeVOManager:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__removeVOManager*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__removeVOManager*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listVOManagersResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listVOManagersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listVOManagersResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__listVOManagers:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__listVOManagers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__listVOManagers*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getRolesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getRolesResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRoles:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getRoles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getRoles*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesOfResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getRolesOfResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getRolesOfResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getRolesOf:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getRolesOf*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getRolesOf*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getSchemaVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getSchemaVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getSchemaVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getSchemaVersion:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getSchemaVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getSchemaVersion*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getInterfaceVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getInterfaceVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getInterfaceVersion:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getInterfaceVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getInterfaceVersion*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getServiceMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getServiceMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getServiceMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_impltns__getServiceMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct impltns__getServiceMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct impltns__getServiceMetadata*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLogResponse:
		if (p->size < 0)
			SOAP_DELETE((struct log__GetLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct log__GetLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLog:
		if (p->size < 0)
			SOAP_DELETE((struct log__GetLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct log__GetLog*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLogInternalResponse:
		if (p->size < 0)
			SOAP_DELETE((struct log__GetLogInternalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct log__GetLogInternalResponse*)p->ptr);
		break;
	case SOAP_TYPE_fts3_log__GetLogInternal:
		if (p->size < 0)
			SOAP_DELETE((struct log__GetLogInternal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct log__GetLogInternal*)p->ptr);
		break;
	case SOAP_TYPE_fts3_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_fts3_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_fts3_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_fts3_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTolog__Log:
		if (p->size < 0)
			SOAP_DELETE((std::vector<log__Log * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<log__Log * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus2:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__FileTransferStatus2 * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__FileTransferStatus2 * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__FileTransferStatus * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__FileTransferStatus * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__JobStatus:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__JobStatus * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__JobStatus * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__StringPair:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__StringPair * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__StringPair * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement3:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__TransferJobElement3 * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__TransferJobElement3 * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement2:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__TransferJobElement2 * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__TransferJobElement2 * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns3__TransferJobElement * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns3__TransferJobElement * >*)p->ptr);
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTolog__Log:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<log__Log * >*)p)[len] = *(log__Log **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__FileTransferStatus2 * >*)p)[len] = *(tns3__FileTransferStatus2 **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__FileTransferStatus * >*)p)[len] = *(tns3__FileTransferStatus **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__JobStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__JobStatus * >*)p)[len] = *(tns3__JobStatus **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__StringPair:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__StringPair * >*)p)[len] = *(tns3__StringPair **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement3:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__TransferJobElement3 * >*)p)[len] = *(tns3__TransferJobElement3 **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__TransferJobElement2 * >*)p)[len] = *(tns3__TransferJobElement2 **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns3__TransferJobElement * >*)p)[len] = *(tns3__TransferJobElement **)q;
		break;
	case SOAP_TYPE_fts3_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_fts3_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_fts3_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_fts3_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_fts3_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_fts3_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_fts3_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_fts3_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_fts3_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_fts3_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_fts3_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_fts3_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fts3_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fts3_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fts3_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_fts3_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void log__LogInternal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTolog__Log(soap, &this->log__LogInternal::logsdata);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->log__LogInternal::lognames);
	/* transient soap skipped */
}

void log__LogInternal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTolog__Log(soap, &this->log__LogInternal::logsdata);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->log__LogInternal::lognames);
	/* transient soap skipped */
}

int log__LogInternal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_log__LogInternal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__LogInternal(struct soap *soap, const char *tag, int id, const log__LogInternal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__LogInternal), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTolog__Log(soap, "logsdata", -1, &(a->log__LogInternal::logsdata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "lognames", -1, &(a->log__LogInternal::lognames), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *log__LogInternal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_log__LogInternal(soap, tag, this, type);
}

SOAP_FMAC3 log__LogInternal * SOAP_FMAC4 soap_in_log__LogInternal(struct soap *soap, const char *tag, log__LogInternal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (log__LogInternal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__LogInternal, sizeof(log__LogInternal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_log__LogInternal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (log__LogInternal *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTolog__Log(soap, "logsdata", &(a->log__LogInternal::logsdata), "log:Log"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "lognames", &(a->log__LogInternal::lognames), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (log__LogInternal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__LogInternal, 0, sizeof(log__LogInternal), 0, soap_copy_log__LogInternal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->log__LogInternal::logsdata.size() < 1 || a->log__LogInternal::lognames.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int log__LogInternal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_log__LogInternal);
	if (this->soap_out(soap, tag?tag:"log:LogInternal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *log__LogInternal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_log__LogInternal(soap, this, tag, type);
}

SOAP_FMAC3 log__LogInternal * SOAP_FMAC4 soap_get_log__LogInternal(struct soap *soap, log__LogInternal *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__LogInternal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 log__LogInternal * SOAP_FMAC2 soap_instantiate_log__LogInternal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__LogInternal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__LogInternal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(log__LogInternal);
		if (size)
			*size = sizeof(log__LogInternal);
		((log__LogInternal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(log__LogInternal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(log__LogInternal);
		for (int i = 0; i < n; i++)
			((log__LogInternal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (log__LogInternal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__LogInternal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying log__LogInternal %p -> %p\n", q, p));
	*(log__LogInternal*)p = *(log__LogInternal*)q;
}

void log__Log::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xop__Include(soap, &this->log__Log::xop__Include);
	/* transient soap skipped */
}

void log__Log::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__xop__Include(soap, &this->log__Log::xop__Include);
	/* transient soap skipped */
}

int log__Log::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_log__Log(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__Log(struct soap *soap, const char *tag, int id, const log__Log *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__Log), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &(a->log__Log::xop__Include), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *log__Log::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_log__Log(soap, tag, this, type);
}

SOAP_FMAC3 log__Log * SOAP_FMAC4 soap_in_log__Log(struct soap *soap, const char *tag, log__Log *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (log__Log *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__Log, sizeof(log__Log), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_log__Log)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (log__Log *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xop__Include1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__xop__Include(soap, "xop:Include", &(a->log__Log::xop__Include), ""))
				{	soap_flag_xop__Include1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (log__Log *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__Log, 0, sizeof(log__Log), 0, soap_copy_log__Log);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int log__Log::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_log__Log);
	if (this->soap_out(soap, tag?tag:"log:Log", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *log__Log::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_log__Log(soap, this, tag, type);
}

SOAP_FMAC3 log__Log * SOAP_FMAC4 soap_get_log__Log(struct soap *soap, log__Log *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__Log(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 log__Log * SOAP_FMAC2 soap_instantiate_log__Log(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__Log(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__Log, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(log__Log);
		if (size)
			*size = sizeof(log__Log);
		((log__Log*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(log__Log[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(log__Log);
		for (int i = 0; i < n; i++)
			((log__Log*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (log__Log*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__Log(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying log__Log %p -> %p\n", q, p));
	*(log__Log*)p = *(log__Log*)q;
}

void _delegation__DelegationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_delegation__DelegationException::msg = NULL;
	/* transient soap skipped */
}

void _delegation__DelegationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_delegation__DelegationException::msg);
	/* transient soap skipped */
}

int _delegation__DelegationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__delegation__DelegationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__delegation__DelegationException(struct soap *soap, const char *tag, int id, const _delegation__DelegationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3__delegation__DelegationException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_delegation__DelegationException::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_delegation__DelegationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__delegation__DelegationException(soap, tag, this, type);
}

SOAP_FMAC3 _delegation__DelegationException * SOAP_FMAC4 soap_in__delegation__DelegationException(struct soap *soap, const char *tag, _delegation__DelegationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_delegation__DelegationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3__delegation__DelegationException, sizeof(_delegation__DelegationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3__delegation__DelegationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_delegation__DelegationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_delegation__DelegationException::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_delegation__DelegationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3__delegation__DelegationException, 0, sizeof(_delegation__DelegationException), 0, soap_copy__delegation__DelegationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _delegation__DelegationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3__delegation__DelegationException);
	if (this->soap_out(soap, tag?tag:"delegation:DelegationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_delegation__DelegationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__delegation__DelegationException(soap, this, tag, type);
}

SOAP_FMAC3 _delegation__DelegationException * SOAP_FMAC4 soap_get__delegation__DelegationException(struct soap *soap, _delegation__DelegationException *p, const char *tag, const char *type)
{
	if ((p = soap_in__delegation__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _delegation__DelegationException * SOAP_FMAC2 soap_instantiate__delegation__DelegationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__delegation__DelegationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3__delegation__DelegationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_delegation__DelegationException);
		if (size)
			*size = sizeof(_delegation__DelegationException);
		((_delegation__DelegationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_delegation__DelegationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_delegation__DelegationException);
		for (int i = 0; i < n; i++)
			((_delegation__DelegationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_delegation__DelegationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__delegation__DelegationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _delegation__DelegationException %p -> %p\n", q, p));
	*(_delegation__DelegationException*)p = *(_delegation__DelegationException*)q;
}

void delegation__NewProxyReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->delegation__NewProxyReq::proxyRequest = NULL;
	this->delegation__NewProxyReq::delegationID = NULL;
	/* transient soap skipped */
}

void delegation__NewProxyReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->delegation__NewProxyReq::proxyRequest);
	soap_serialize_PointerTostd__string(soap, &this->delegation__NewProxyReq::delegationID);
	/* transient soap skipped */
}

int delegation__NewProxyReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_delegation__NewProxyReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__NewProxyReq(struct soap *soap, const char *tag, int id, const delegation__NewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__NewProxyReq), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "proxyRequest", -1, &(a->delegation__NewProxyReq::proxyRequest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "delegationID", -1, &(a->delegation__NewProxyReq::delegationID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *delegation__NewProxyReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_delegation__NewProxyReq(soap, tag, this, type);
}

SOAP_FMAC3 delegation__NewProxyReq * SOAP_FMAC4 soap_in_delegation__NewProxyReq(struct soap *soap, const char *tag, delegation__NewProxyReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (delegation__NewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__NewProxyReq, sizeof(delegation__NewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_delegation__NewProxyReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (delegation__NewProxyReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_proxyRequest1 = 1;
	size_t soap_flag_delegationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_proxyRequest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "proxyRequest", &(a->delegation__NewProxyReq::proxyRequest), "xsd:string"))
				{	soap_flag_proxyRequest1--;
					continue;
				}
			if (soap_flag_delegationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "delegationID", &(a->delegation__NewProxyReq::delegationID), "xsd:string"))
				{	soap_flag_delegationID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (delegation__NewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__NewProxyReq, 0, sizeof(delegation__NewProxyReq), 0, soap_copy_delegation__NewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int delegation__NewProxyReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_delegation__NewProxyReq);
	if (this->soap_out(soap, tag?tag:"delegation:NewProxyReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *delegation__NewProxyReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_delegation__NewProxyReq(soap, this, tag, type);
}

SOAP_FMAC3 delegation__NewProxyReq * SOAP_FMAC4 soap_get_delegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 delegation__NewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__NewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__NewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__NewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(delegation__NewProxyReq);
		if (size)
			*size = sizeof(delegation__NewProxyReq);
		((delegation__NewProxyReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(delegation__NewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(delegation__NewProxyReq);
		for (int i = 0; i < n; i++)
			((delegation__NewProxyReq*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (delegation__NewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__NewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying delegation__NewProxyReq %p -> %p\n", q, p));
	*(delegation__NewProxyReq*)p = *(delegation__NewProxyReq*)q;
}

void config__InternalException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->config__ConfigurationException::message = NULL;
	/* transient soap skipped */
}

void config__InternalException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->config__ConfigurationException::message);
	/* transient soap skipped */
}

int config__InternalException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__InternalException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__InternalException(struct soap *soap, const char *tag, int id, const config__InternalException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__InternalException), "config:InternalException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->config__ConfigurationException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__InternalException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__InternalException(soap, tag, this, type);
}

SOAP_FMAC3 config__InternalException * SOAP_FMAC4 soap_in_config__InternalException(struct soap *soap, const char *tag, config__InternalException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__InternalException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__InternalException, sizeof(config__InternalException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__InternalException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__InternalException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->config__ConfigurationException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__InternalException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__InternalException, 0, sizeof(config__InternalException), 0, soap_copy_config__InternalException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__InternalException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__InternalException);
	if (this->soap_out(soap, tag?tag:"config:InternalException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__InternalException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__InternalException(soap, this, tag, type);
}

SOAP_FMAC3 config__InternalException * SOAP_FMAC4 soap_get_config__InternalException(struct soap *soap, config__InternalException *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__InternalException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__InternalException * SOAP_FMAC2 soap_instantiate_config__InternalException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__InternalException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__InternalException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__InternalException);
		if (size)
			*size = sizeof(config__InternalException);
		((config__InternalException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__InternalException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__InternalException);
		for (int i = 0; i < n; i++)
			((config__InternalException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__InternalException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__InternalException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__InternalException %p -> %p\n", q, p));
	*(config__InternalException*)p = *(config__InternalException*)q;
}

void config__ServiceBusyException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->config__ConfigurationException::message = NULL;
	/* transient soap skipped */
}

void config__ServiceBusyException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->config__ConfigurationException::message);
	/* transient soap skipped */
}

int config__ServiceBusyException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__ServiceBusyException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__ServiceBusyException(struct soap *soap, const char *tag, int id, const config__ServiceBusyException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__ServiceBusyException), "config:ServiceBusyException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->config__ConfigurationException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__ServiceBusyException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__ServiceBusyException(soap, tag, this, type);
}

SOAP_FMAC3 config__ServiceBusyException * SOAP_FMAC4 soap_in_config__ServiceBusyException(struct soap *soap, const char *tag, config__ServiceBusyException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__ServiceBusyException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__ServiceBusyException, sizeof(config__ServiceBusyException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__ServiceBusyException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__ServiceBusyException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->config__ConfigurationException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__ServiceBusyException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__ServiceBusyException, 0, sizeof(config__ServiceBusyException), 0, soap_copy_config__ServiceBusyException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__ServiceBusyException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__ServiceBusyException);
	if (this->soap_out(soap, tag?tag:"config:ServiceBusyException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__ServiceBusyException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__ServiceBusyException(soap, this, tag, type);
}

SOAP_FMAC3 config__ServiceBusyException * SOAP_FMAC4 soap_get_config__ServiceBusyException(struct soap *soap, config__ServiceBusyException *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__ServiceBusyException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__ServiceBusyException * SOAP_FMAC2 soap_instantiate_config__ServiceBusyException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__ServiceBusyException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__ServiceBusyException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__ServiceBusyException);
		if (size)
			*size = sizeof(config__ServiceBusyException);
		((config__ServiceBusyException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__ServiceBusyException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__ServiceBusyException);
		for (int i = 0; i < n; i++)
			((config__ServiceBusyException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__ServiceBusyException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__ServiceBusyException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__ServiceBusyException %p -> %p\n", q, p));
	*(config__ServiceBusyException*)p = *(config__ServiceBusyException*)q;
}

void config__AuthorizationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->config__ConfigurationException::message = NULL;
	/* transient soap skipped */
}

void config__AuthorizationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->config__ConfigurationException::message);
	/* transient soap skipped */
}

int config__AuthorizationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__AuthorizationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__AuthorizationException(struct soap *soap, const char *tag, int id, const config__AuthorizationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__AuthorizationException), "config:AuthorizationException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->config__ConfigurationException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__AuthorizationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__AuthorizationException(soap, tag, this, type);
}

SOAP_FMAC3 config__AuthorizationException * SOAP_FMAC4 soap_in_config__AuthorizationException(struct soap *soap, const char *tag, config__AuthorizationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__AuthorizationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__AuthorizationException, sizeof(config__AuthorizationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__AuthorizationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__AuthorizationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->config__ConfigurationException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__AuthorizationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__AuthorizationException, 0, sizeof(config__AuthorizationException), 0, soap_copy_config__AuthorizationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__AuthorizationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__AuthorizationException);
	if (this->soap_out(soap, tag?tag:"config:AuthorizationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__AuthorizationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__AuthorizationException(soap, this, tag, type);
}

SOAP_FMAC3 config__AuthorizationException * SOAP_FMAC4 soap_get_config__AuthorizationException(struct soap *soap, config__AuthorizationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__AuthorizationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__AuthorizationException * SOAP_FMAC2 soap_instantiate_config__AuthorizationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__AuthorizationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__AuthorizationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__AuthorizationException);
		if (size)
			*size = sizeof(config__AuthorizationException);
		((config__AuthorizationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__AuthorizationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__AuthorizationException);
		for (int i = 0; i < n; i++)
			((config__AuthorizationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__AuthorizationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__AuthorizationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__AuthorizationException %p -> %p\n", q, p));
	*(config__AuthorizationException*)p = *(config__AuthorizationException*)q;
}

void config__InvalidConfigurationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->config__ConfigurationException::message = NULL;
	/* transient soap skipped */
}

void config__InvalidConfigurationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->config__ConfigurationException::message);
	/* transient soap skipped */
}

int config__InvalidConfigurationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__InvalidConfigurationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__InvalidConfigurationException(struct soap *soap, const char *tag, int id, const config__InvalidConfigurationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__InvalidConfigurationException), "config:InvalidConfigurationException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->config__ConfigurationException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__InvalidConfigurationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__InvalidConfigurationException(soap, tag, this, type);
}

SOAP_FMAC3 config__InvalidConfigurationException * SOAP_FMAC4 soap_in_config__InvalidConfigurationException(struct soap *soap, const char *tag, config__InvalidConfigurationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__InvalidConfigurationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__InvalidConfigurationException, sizeof(config__InvalidConfigurationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__InvalidConfigurationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__InvalidConfigurationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->config__ConfigurationException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__InvalidConfigurationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__InvalidConfigurationException, 0, sizeof(config__InvalidConfigurationException), 0, soap_copy_config__InvalidConfigurationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__InvalidConfigurationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__InvalidConfigurationException);
	if (this->soap_out(soap, tag?tag:"config:InvalidConfigurationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__InvalidConfigurationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__InvalidConfigurationException(soap, this, tag, type);
}

SOAP_FMAC3 config__InvalidConfigurationException * SOAP_FMAC4 soap_get_config__InvalidConfigurationException(struct soap *soap, config__InvalidConfigurationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__InvalidConfigurationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__InvalidConfigurationException * SOAP_FMAC2 soap_instantiate_config__InvalidConfigurationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__InvalidConfigurationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__InvalidConfigurationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__InvalidConfigurationException);
		if (size)
			*size = sizeof(config__InvalidConfigurationException);
		((config__InvalidConfigurationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__InvalidConfigurationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__InvalidConfigurationException);
		for (int i = 0; i < n; i++)
			((config__InvalidConfigurationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__InvalidConfigurationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__InvalidConfigurationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__InvalidConfigurationException %p -> %p\n", q, p));
	*(config__InvalidConfigurationException*)p = *(config__InvalidConfigurationException*)q;
}

void config__ConfigurationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->config__ConfigurationException::message = NULL;
	/* transient soap skipped */
}

void config__ConfigurationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->config__ConfigurationException::message);
	/* transient soap skipped */
}

int config__ConfigurationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__ConfigurationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__ConfigurationException(struct soap *soap, const char *tag, int id, const config__ConfigurationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__ConfigurationException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->config__ConfigurationException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__ConfigurationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__ConfigurationException(soap, tag, this, type);
}

SOAP_FMAC3 config__ConfigurationException * SOAP_FMAC4 soap_in_config__ConfigurationException(struct soap *soap, const char *tag, config__ConfigurationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__ConfigurationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__ConfigurationException, sizeof(config__ConfigurationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__ConfigurationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__ConfigurationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->config__ConfigurationException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__ConfigurationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__ConfigurationException, 0, sizeof(config__ConfigurationException), 0, soap_copy_config__ConfigurationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__ConfigurationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__ConfigurationException);
	if (this->soap_out(soap, tag?tag:"config:ConfigurationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__ConfigurationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__ConfigurationException(soap, this, tag, type);
}

SOAP_FMAC3 config__ConfigurationException * SOAP_FMAC4 soap_get_config__ConfigurationException(struct soap *soap, config__ConfigurationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__ConfigurationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__ConfigurationException * SOAP_FMAC2 soap_instantiate_config__ConfigurationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__ConfigurationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__ConfigurationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "config:InvalidConfigurationException"))
	{	cp->type = SOAP_TYPE_fts3_config__InvalidConfigurationException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(config__InvalidConfigurationException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(config__InvalidConfigurationException);
			((config__InvalidConfigurationException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(config__InvalidConfigurationException[n]);
			if (size)
				*size = n * sizeof(config__InvalidConfigurationException);
			for (int i = 0; i < n; i++)
				((config__InvalidConfigurationException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (config__InvalidConfigurationException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "config:AuthorizationException"))
	{	cp->type = SOAP_TYPE_fts3_config__AuthorizationException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(config__AuthorizationException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(config__AuthorizationException);
			((config__AuthorizationException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(config__AuthorizationException[n]);
			if (size)
				*size = n * sizeof(config__AuthorizationException);
			for (int i = 0; i < n; i++)
				((config__AuthorizationException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (config__AuthorizationException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "config:ServiceBusyException"))
	{	cp->type = SOAP_TYPE_fts3_config__ServiceBusyException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(config__ServiceBusyException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(config__ServiceBusyException);
			((config__ServiceBusyException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(config__ServiceBusyException[n]);
			if (size)
				*size = n * sizeof(config__ServiceBusyException);
			for (int i = 0; i < n; i++)
				((config__ServiceBusyException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (config__ServiceBusyException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "config:InternalException"))
	{	cp->type = SOAP_TYPE_fts3_config__InternalException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(config__InternalException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(config__InternalException);
			((config__InternalException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(config__InternalException[n]);
			if (size)
				*size = n * sizeof(config__InternalException);
			for (int i = 0; i < n; i++)
				((config__InternalException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (config__InternalException*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__ConfigurationException);
		if (size)
			*size = sizeof(config__ConfigurationException);
		((config__ConfigurationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__ConfigurationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__ConfigurationException);
		for (int i = 0; i < n; i++)
			((config__ConfigurationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__ConfigurationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__ConfigurationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__ConfigurationException %p -> %p\n", q, p));
	*(config__ConfigurationException*)p = *(config__ConfigurationException*)q;
}

void config__Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->config__Configuration::cfg);
	/* transient soap skipped */
}

void config__Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->config__Configuration::cfg);
	/* transient soap skipped */
}

int config__Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_config__Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_config__Configuration(struct soap *soap, const char *tag, int id, const config__Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_config__Configuration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "cfg", -1, &(a->config__Configuration::cfg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *config__Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_config__Configuration(soap, tag, this, type);
}

SOAP_FMAC3 config__Configuration * SOAP_FMAC4 soap_in_config__Configuration(struct soap *soap, const char *tag, config__Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (config__Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_config__Configuration, sizeof(config__Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_config__Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (config__Configuration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "cfg", &(a->config__Configuration::cfg), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (config__Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_config__Configuration, 0, sizeof(config__Configuration), 0, soap_copy_config__Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int config__Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_config__Configuration);
	if (this->soap_out(soap, tag?tag:"config:Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *config__Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_config__Configuration(soap, this, tag, type);
}

SOAP_FMAC3 config__Configuration * SOAP_FMAC4 soap_get_config__Configuration(struct soap *soap, config__Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_config__Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 config__Configuration * SOAP_FMAC2 soap_instantiate_config__Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_config__Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_config__Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(config__Configuration);
		if (size)
			*size = sizeof(config__Configuration);
		((config__Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(config__Configuration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(config__Configuration);
		for (int i = 0; i < n; i++)
			((config__Configuration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (config__Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_config__Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying config__Configuration %p -> %p\n", q, p));
	*(config__Configuration*)p = *(config__Configuration*)q;
}

void impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item);
	/* transient soap skipped */
}

void impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item);
	/* transient soap skipped */
}

int impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, int id, const impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, "item", -1, &(a->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, this, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC4 soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, "item", &(a->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::item), "tns3:FileTransferStatus2"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, 0, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), 0, soap_copy_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (this->soap_out(soap, tag?tag:"impltns:ArrayOf_tns3_FileTransferStatus2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, this, tag, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC4 soap_get_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 * SOAP_FMAC2 soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		if (size)
			*size = sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
		for (int i = 0; i < n; i++)
			((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 %p -> %p\n", q, p));
	*(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)p = *(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2*)q;
}

void impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item);
	/* transient soap skipped */
}

void impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item);
	/* transient soap skipped */
}

int impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, int id, const impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, "item", -1, &(a->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, this, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC4 soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, "item", &(a->impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::item), "tns3:FileTransferStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus, 0, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus), 0, soap_copy_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (this->soap_out(soap, tag?tag:"impltns:ArrayOf_tns3_FileTransferStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, this, tag, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC4 soap_get_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus * SOAP_FMAC2 soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		if (size)
			*size = sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
		for (int i = 0; i < n; i++)
			((impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus %p -> %p\n", q, p));
	*(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)p = *(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus*)q;
}

void impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__JobStatus(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREJobStatus::item);
	/* transient soap skipped */
}

void impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__JobStatus(soap, &this->impltns__ArrayOf_USCOREtns3_USCOREJobStatus::item);
	/* transient soap skipped */
}

int impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, int id, const impltns__ArrayOf_USCOREtns3_USCOREJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__JobStatus(soap, "item", -1, &(a->impltns__ArrayOf_USCOREtns3_USCOREJobStatus::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, this, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC4 soap_in_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREJobStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus, sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__JobStatus(soap, "item", &(a->impltns__ArrayOf_USCOREtns3_USCOREJobStatus::item), "tns3:JobStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus, 0, sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus), 0, soap_copy_impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (this->soap_out(soap, tag?tag:"impltns:ArrayOf_tns3_JobStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *impltns__ArrayOf_USCOREtns3_USCOREJobStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, this, tag, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC4 soap_get_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 impltns__ArrayOf_USCOREtns3_USCOREJobStatus * SOAP_FMAC2 soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
		if (size)
			*size = sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
		((impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREtns3_USCOREJobStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
		for (int i = 0; i < n; i++)
			((impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying impltns__ArrayOf_USCOREtns3_USCOREJobStatus %p -> %p\n", q, p));
	*(impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)p = *(impltns__ArrayOf_USCOREtns3_USCOREJobStatus*)q;
}

void impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->impltns__ArrayOf_USCOREsoapenc_USCOREstring::item);
	/* transient soap skipped */
}

void impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->impltns__ArrayOf_USCOREsoapenc_USCOREstring::item);
	/* transient soap skipped */
}

int impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, int id, const impltns__ArrayOf_USCOREsoapenc_USCOREstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "item", -1, &(a->impltns__ArrayOf_USCOREsoapenc_USCOREstring::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC4 soap_in_impltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREsoapenc_USCOREstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (impltns__ArrayOf_USCOREsoapenc_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring, sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (impltns__ArrayOf_USCOREsoapenc_USCOREstring *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "item", &(a->impltns__ArrayOf_USCOREsoapenc_USCOREstring::item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (impltns__ArrayOf_USCOREsoapenc_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring, 0, sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring), 0, soap_copy_impltns__ArrayOf_USCOREsoapenc_USCOREstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring);
	if (this->soap_out(soap, tag?tag:"impltns:ArrayOf_soapenc_string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *impltns__ArrayOf_USCOREsoapenc_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC4 soap_get_impltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, impltns__ArrayOf_USCOREsoapenc_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 impltns__ArrayOf_USCOREsoapenc_USCOREstring * SOAP_FMAC2 soap_instantiate_impltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__ArrayOf_USCOREsoapenc_USCOREstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREsoapenc_USCOREstring);
		if (size)
			*size = sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring);
		((impltns__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(impltns__ArrayOf_USCOREsoapenc_USCOREstring[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring);
		for (int i = 0; i < n; i++)
			((impltns__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (impltns__ArrayOf_USCOREsoapenc_USCOREstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying impltns__ArrayOf_USCOREsoapenc_USCOREstring %p -> %p\n", q, p));
	*(impltns__ArrayOf_USCOREsoapenc_USCOREstring*)p = *(impltns__ArrayOf_USCOREsoapenc_USCOREstring*)q;
}

void tns3__Roles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__Roles::clientDN = NULL;
	this->tns3__Roles::serviceAdmin = NULL;
	this->tns3__Roles::submitter = NULL;
	soap_default_std__vectorTemplateOfPointerTotns3__StringPair(soap, &this->tns3__Roles::VOManager);
	/* transient soap skipped */
}

void tns3__Roles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__Roles::clientDN);
	soap_serialize_PointerTostd__string(soap, &this->tns3__Roles::serviceAdmin);
	soap_serialize_PointerTostd__string(soap, &this->tns3__Roles::submitter);
	soap_serialize_std__vectorTemplateOfPointerTotns3__StringPair(soap, &this->tns3__Roles::VOManager);
	/* transient soap skipped */
}

int tns3__Roles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__Roles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__Roles(struct soap *soap, const char *tag, int id, const tns3__Roles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__Roles), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientDN", -1, &(a->tns3__Roles::clientDN), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "serviceAdmin", -1, &(a->tns3__Roles::serviceAdmin), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "submitter", -1, &(a->tns3__Roles::submitter), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__StringPair(soap, "VOManager", -1, &(a->tns3__Roles::VOManager), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__Roles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__Roles(soap, tag, this, type);
}

SOAP_FMAC3 tns3__Roles * SOAP_FMAC4 soap_in_tns3__Roles(struct soap *soap, const char *tag, tns3__Roles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__Roles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__Roles, sizeof(tns3__Roles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__Roles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__Roles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_clientDN1 = 1;
	size_t soap_flag_serviceAdmin1 = 1;
	size_t soap_flag_submitter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clientDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "clientDN", &(a->tns3__Roles::clientDN), "xsd:string"))
				{	soap_flag_clientDN1--;
					continue;
				}
			if (soap_flag_serviceAdmin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "serviceAdmin", &(a->tns3__Roles::serviceAdmin), "xsd:string"))
				{	soap_flag_serviceAdmin1--;
					continue;
				}
			if (soap_flag_submitter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "submitter", &(a->tns3__Roles::submitter), "xsd:string"))
				{	soap_flag_submitter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__StringPair(soap, "VOManager", &(a->tns3__Roles::VOManager), "tns3:StringPair"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__Roles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__Roles, 0, sizeof(tns3__Roles), 0, soap_copy_tns3__Roles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__Roles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__Roles);
	if (this->soap_out(soap, tag?tag:"tns3:Roles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__Roles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__Roles(soap, this, tag, type);
}

SOAP_FMAC3 tns3__Roles * SOAP_FMAC4 soap_get_tns3__Roles(struct soap *soap, tns3__Roles *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__Roles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__Roles * SOAP_FMAC2 soap_instantiate_tns3__Roles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__Roles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__Roles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__Roles);
		if (size)
			*size = sizeof(tns3__Roles);
		((tns3__Roles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__Roles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__Roles);
		for (int i = 0; i < n; i++)
			((tns3__Roles*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__Roles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__Roles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__Roles %p -> %p\n", q, p));
	*(tns3__Roles*)p = *(tns3__Roles*)q;
}

void tns3__StringPair::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__StringPair::string1 = NULL;
	this->tns3__StringPair::string2 = NULL;
	/* transient soap skipped */
}

void tns3__StringPair::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__StringPair::string1);
	soap_serialize_PointerTostd__string(soap, &this->tns3__StringPair::string2);
	/* transient soap skipped */
}

int tns3__StringPair::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__StringPair(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__StringPair(struct soap *soap, const char *tag, int id, const tns3__StringPair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__StringPair), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "string1", -1, &(a->tns3__StringPair::string1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "string2", -1, &(a->tns3__StringPair::string2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__StringPair::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__StringPair(soap, tag, this, type);
}

SOAP_FMAC3 tns3__StringPair * SOAP_FMAC4 soap_in_tns3__StringPair(struct soap *soap, const char *tag, tns3__StringPair *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__StringPair *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__StringPair, sizeof(tns3__StringPair), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__StringPair)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__StringPair *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_string11 = 1;
	size_t soap_flag_string21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "string1", &(a->tns3__StringPair::string1), "xsd:string"))
				{	soap_flag_string11--;
					continue;
				}
			if (soap_flag_string21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "string2", &(a->tns3__StringPair::string2), "xsd:string"))
				{	soap_flag_string21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__StringPair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__StringPair, 0, sizeof(tns3__StringPair), 0, soap_copy_tns3__StringPair);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__StringPair::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__StringPair);
	if (this->soap_out(soap, tag?tag:"tns3:StringPair", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__StringPair::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__StringPair(soap, this, tag, type);
}

SOAP_FMAC3 tns3__StringPair * SOAP_FMAC4 soap_get_tns3__StringPair(struct soap *soap, tns3__StringPair *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__StringPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__StringPair * SOAP_FMAC2 soap_instantiate_tns3__StringPair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__StringPair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__StringPair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__StringPair);
		if (size)
			*size = sizeof(tns3__StringPair);
		((tns3__StringPair*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__StringPair[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__StringPair);
		for (int i = 0; i < n; i++)
			((tns3__StringPair*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__StringPair*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__StringPair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__StringPair %p -> %p\n", q, p));
	*(tns3__StringPair*)p = *(tns3__StringPair*)q;
}

void tns3__ExistsException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__ExistsException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__ExistsException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__ExistsException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__ExistsException(struct soap *soap, const char *tag, int id, const tns3__ExistsException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__ExistsException), "tns3:ExistsException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__ExistsException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__ExistsException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__ExistsException * SOAP_FMAC4 soap_in_tns3__ExistsException(struct soap *soap, const char *tag, tns3__ExistsException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__ExistsException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__ExistsException, sizeof(tns3__ExistsException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__ExistsException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__ExistsException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__ExistsException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__ExistsException, 0, sizeof(tns3__ExistsException), 0, soap_copy_tns3__ExistsException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__ExistsException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__ExistsException);
	if (this->soap_out(soap, tag?tag:"tns3:ExistsException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__ExistsException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__ExistsException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__ExistsException * SOAP_FMAC4 soap_get_tns3__ExistsException(struct soap *soap, tns3__ExistsException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__ExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__ExistsException * SOAP_FMAC2 soap_instantiate_tns3__ExistsException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__ExistsException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__ExistsException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__ExistsException);
		if (size)
			*size = sizeof(tns3__ExistsException);
		((tns3__ExistsException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__ExistsException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__ExistsException);
		for (int i = 0; i < n; i++)
			((tns3__ExistsException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__ExistsException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__ExistsException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__ExistsException %p -> %p\n", q, p));
	*(tns3__ExistsException*)p = *(tns3__ExistsException*)q;
}

void tns3__CannotCancelException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__CannotCancelException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__CannotCancelException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__CannotCancelException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__CannotCancelException(struct soap *soap, const char *tag, int id, const tns3__CannotCancelException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__CannotCancelException), "tns3:CannotCancelException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__CannotCancelException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__CannotCancelException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__CannotCancelException * SOAP_FMAC4 soap_in_tns3__CannotCancelException(struct soap *soap, const char *tag, tns3__CannotCancelException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__CannotCancelException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__CannotCancelException, sizeof(tns3__CannotCancelException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__CannotCancelException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__CannotCancelException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__CannotCancelException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__CannotCancelException, 0, sizeof(tns3__CannotCancelException), 0, soap_copy_tns3__CannotCancelException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__CannotCancelException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__CannotCancelException);
	if (this->soap_out(soap, tag?tag:"tns3:CannotCancelException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__CannotCancelException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__CannotCancelException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__CannotCancelException * SOAP_FMAC4 soap_get_tns3__CannotCancelException(struct soap *soap, tns3__CannotCancelException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__CannotCancelException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__CannotCancelException * SOAP_FMAC2 soap_instantiate_tns3__CannotCancelException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__CannotCancelException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__CannotCancelException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__CannotCancelException);
		if (size)
			*size = sizeof(tns3__CannotCancelException);
		((tns3__CannotCancelException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__CannotCancelException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__CannotCancelException);
		for (int i = 0; i < n; i++)
			((tns3__CannotCancelException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__CannotCancelException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__CannotCancelException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__CannotCancelException %p -> %p\n", q, p));
	*(tns3__CannotCancelException*)p = *(tns3__CannotCancelException*)q;
}

void tns3__TransferJobSummary2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numReady);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numFinishing);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numAwaitingPrestage);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numPrestaging);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numWaitingCatalogRegistration);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numWaitingCatalogResolution);
	soap_default_int(soap, &this->tns3__TransferJobSummary2::numWaitingPrestage);
	this->tns3__TransferJobSummary::jobStatus = NULL;
	soap_default_int(soap, &this->tns3__TransferJobSummary::numDone);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numActive);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numPending);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCanceled);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCanceling);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numFailed);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numFinished);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numSubmitted);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numHold);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numWaiting);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCatalogFailed);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numRestarted);
	/* transient soap skipped */
}

void tns3__TransferJobSummary2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numReady, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numFinishing, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numAwaitingPrestage, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numPrestaging, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numWaitingCatalogRegistration, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numWaitingCatalogResolution, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary2::numWaitingPrestage, SOAP_TYPE_fts3_int);
	soap_serialize_PointerTotns3__JobStatus(soap, &this->tns3__TransferJobSummary::jobStatus);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numDone, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numActive, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numPending, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCanceled, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCanceling, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numFailed, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numFinished, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numSubmitted, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numHold, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numWaiting, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCatalogFailed, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numRestarted, SOAP_TYPE_fts3_int);
	/* transient soap skipped */
}

int tns3__TransferJobSummary2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJobSummary2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJobSummary2(struct soap *soap, const char *tag, int id, const tns3__TransferJobSummary2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJobSummary2), "tns3:TransferJobSummary2"))
		return soap->error;
	if (soap_out_PointerTotns3__JobStatus(soap, "jobStatus", -1, &(a->tns3__TransferJobSummary::jobStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "numDone", -1, &(a->tns3__TransferJobSummary::numDone), ""))
		return soap->error;
	if (soap_out_int(soap, "numActive", -1, &(a->tns3__TransferJobSummary::numActive), ""))
		return soap->error;
	if (soap_out_int(soap, "numPending", -1, &(a->tns3__TransferJobSummary::numPending), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceled", -1, &(a->tns3__TransferJobSummary::numCanceled), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceling", -1, &(a->tns3__TransferJobSummary::numCanceling), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailed", -1, &(a->tns3__TransferJobSummary::numFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinished", -1, &(a->tns3__TransferJobSummary::numFinished), ""))
		return soap->error;
	if (soap_out_int(soap, "numSubmitted", -1, &(a->tns3__TransferJobSummary::numSubmitted), ""))
		return soap->error;
	if (soap_out_int(soap, "numHold", -1, &(a->tns3__TransferJobSummary::numHold), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaiting", -1, &(a->tns3__TransferJobSummary::numWaiting), ""))
		return soap->error;
	if (soap_out_int(soap, "numCatalogFailed", -1, &(a->tns3__TransferJobSummary::numCatalogFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numRestarted", -1, &(a->tns3__TransferJobSummary::numRestarted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "numReady", -1, &(a->tns3__TransferJobSummary2::numReady), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinishing", -1, &(a->tns3__TransferJobSummary2::numFinishing), ""))
		return soap->error;
	if (soap_out_int(soap, "numAwaitingPrestage", -1, &(a->tns3__TransferJobSummary2::numAwaitingPrestage), ""))
		return soap->error;
	if (soap_out_int(soap, "numPrestaging", -1, &(a->tns3__TransferJobSummary2::numPrestaging), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingCatalogRegistration", -1, &(a->tns3__TransferJobSummary2::numWaitingCatalogRegistration), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingCatalogResolution", -1, &(a->tns3__TransferJobSummary2::numWaitingCatalogResolution), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaitingPrestage", -1, &(a->tns3__TransferJobSummary2::numWaitingPrestage), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJobSummary2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJobSummary2(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJobSummary2 * SOAP_FMAC4 soap_in_tns3__TransferJobSummary2(struct soap *soap, const char *tag, tns3__TransferJobSummary2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJobSummary2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJobSummary2, sizeof(tns3__TransferJobSummary2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJobSummary2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJobSummary2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobStatus2 = 1;
	size_t soap_flag_numDone2 = 1;
	size_t soap_flag_numActive2 = 1;
	size_t soap_flag_numPending2 = 1;
	size_t soap_flag_numCanceled2 = 1;
	size_t soap_flag_numCanceling2 = 1;
	size_t soap_flag_numFailed2 = 1;
	size_t soap_flag_numFinished2 = 1;
	size_t soap_flag_numSubmitted2 = 1;
	size_t soap_flag_numHold2 = 1;
	size_t soap_flag_numWaiting2 = 1;
	size_t soap_flag_numCatalogFailed2 = 1;
	size_t soap_flag_numRestarted2 = 1;
	size_t soap_flag_numReady1 = 1;
	size_t soap_flag_numFinishing1 = 1;
	size_t soap_flag_numAwaitingPrestage1 = 1;
	size_t soap_flag_numPrestaging1 = 1;
	size_t soap_flag_numWaitingCatalogRegistration1 = 1;
	size_t soap_flag_numWaitingCatalogResolution1 = 1;
	size_t soap_flag_numWaitingPrestage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobStatus2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__JobStatus(soap, "jobStatus", &(a->tns3__TransferJobSummary::jobStatus), "tns3:JobStatus"))
				{	soap_flag_jobStatus2--;
					continue;
				}
			if (soap_flag_numDone2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numDone", &(a->tns3__TransferJobSummary::numDone), "xsd:int"))
				{	soap_flag_numDone2--;
					continue;
				}
			if (soap_flag_numActive2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numActive", &(a->tns3__TransferJobSummary::numActive), "xsd:int"))
				{	soap_flag_numActive2--;
					continue;
				}
			if (soap_flag_numPending2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPending", &(a->tns3__TransferJobSummary::numPending), "xsd:int"))
				{	soap_flag_numPending2--;
					continue;
				}
			if (soap_flag_numCanceled2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceled", &(a->tns3__TransferJobSummary::numCanceled), "xsd:int"))
				{	soap_flag_numCanceled2--;
					continue;
				}
			if (soap_flag_numCanceling2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceling", &(a->tns3__TransferJobSummary::numCanceling), "xsd:int"))
				{	soap_flag_numCanceling2--;
					continue;
				}
			if (soap_flag_numFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailed", &(a->tns3__TransferJobSummary::numFailed), "xsd:int"))
				{	soap_flag_numFailed2--;
					continue;
				}
			if (soap_flag_numFinished2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinished", &(a->tns3__TransferJobSummary::numFinished), "xsd:int"))
				{	soap_flag_numFinished2--;
					continue;
				}
			if (soap_flag_numSubmitted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numSubmitted", &(a->tns3__TransferJobSummary::numSubmitted), "xsd:int"))
				{	soap_flag_numSubmitted2--;
					continue;
				}
			if (soap_flag_numHold2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numHold", &(a->tns3__TransferJobSummary::numHold), "xsd:int"))
				{	soap_flag_numHold2--;
					continue;
				}
			if (soap_flag_numWaiting2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaiting", &(a->tns3__TransferJobSummary::numWaiting), "xsd:int"))
				{	soap_flag_numWaiting2--;
					continue;
				}
			if (soap_flag_numCatalogFailed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCatalogFailed", &(a->tns3__TransferJobSummary::numCatalogFailed), "xsd:int"))
				{	soap_flag_numCatalogFailed2--;
					continue;
				}
			if (soap_flag_numRestarted2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numRestarted", &(a->tns3__TransferJobSummary::numRestarted), "xsd:int"))
				{	soap_flag_numRestarted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_numReady1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numReady", &(a->tns3__TransferJobSummary2::numReady), "xsd:int"))
				{	soap_flag_numReady1--;
					continue;
				}
			if (soap_flag_numFinishing1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinishing", &(a->tns3__TransferJobSummary2::numFinishing), "xsd:int"))
				{	soap_flag_numFinishing1--;
					continue;
				}
			if (soap_flag_numAwaitingPrestage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numAwaitingPrestage", &(a->tns3__TransferJobSummary2::numAwaitingPrestage), "xsd:int"))
				{	soap_flag_numAwaitingPrestage1--;
					continue;
				}
			if (soap_flag_numPrestaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPrestaging", &(a->tns3__TransferJobSummary2::numPrestaging), "xsd:int"))
				{	soap_flag_numPrestaging1--;
					continue;
				}
			if (soap_flag_numWaitingCatalogRegistration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingCatalogRegistration", &(a->tns3__TransferJobSummary2::numWaitingCatalogRegistration), "xsd:int"))
				{	soap_flag_numWaitingCatalogRegistration1--;
					continue;
				}
			if (soap_flag_numWaitingCatalogResolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingCatalogResolution", &(a->tns3__TransferJobSummary2::numWaitingCatalogResolution), "xsd:int"))
				{	soap_flag_numWaitingCatalogResolution1--;
					continue;
				}
			if (soap_flag_numWaitingPrestage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaitingPrestage", &(a->tns3__TransferJobSummary2::numWaitingPrestage), "xsd:int"))
				{	soap_flag_numWaitingPrestage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJobSummary2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJobSummary2, 0, sizeof(tns3__TransferJobSummary2), 0, soap_copy_tns3__TransferJobSummary2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numDone2 > 0 || soap_flag_numActive2 > 0 || soap_flag_numPending2 > 0 || soap_flag_numCanceled2 > 0 || soap_flag_numCanceling2 > 0 || soap_flag_numFailed2 > 0 || soap_flag_numFinished2 > 0 || soap_flag_numSubmitted2 > 0 || soap_flag_numHold2 > 0 || soap_flag_numWaiting2 > 0 || soap_flag_numCatalogFailed2 > 0 || soap_flag_numRestarted2 > 0 || soap_flag_numReady1 > 0 || soap_flag_numFinishing1 > 0 || soap_flag_numAwaitingPrestage1 > 0 || soap_flag_numPrestaging1 > 0 || soap_flag_numWaitingCatalogRegistration1 > 0 || soap_flag_numWaitingCatalogResolution1 > 0 || soap_flag_numWaitingPrestage1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__TransferJobSummary2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJobSummary2);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJobSummary2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJobSummary2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJobSummary2(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJobSummary2 * SOAP_FMAC4 soap_get_tns3__TransferJobSummary2(struct soap *soap, tns3__TransferJobSummary2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJobSummary2 * SOAP_FMAC2 soap_instantiate_tns3__TransferJobSummary2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJobSummary2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJobSummary2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary2);
		if (size)
			*size = sizeof(tns3__TransferJobSummary2);
		((tns3__TransferJobSummary2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJobSummary2);
		for (int i = 0; i < n; i++)
			((tns3__TransferJobSummary2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJobSummary2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJobSummary2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJobSummary2 %p -> %p\n", q, p));
	*(tns3__TransferJobSummary2*)p = *(tns3__TransferJobSummary2*)q;
}

void tns3__TransferJobSummary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferJobSummary::jobStatus = NULL;
	soap_default_int(soap, &this->tns3__TransferJobSummary::numDone);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numActive);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numPending);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCanceled);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCanceling);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numFailed);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numFinished);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numSubmitted);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numHold);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numWaiting);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numCatalogFailed);
	soap_default_int(soap, &this->tns3__TransferJobSummary::numRestarted);
	/* transient soap skipped */
}

void tns3__TransferJobSummary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__JobStatus(soap, &this->tns3__TransferJobSummary::jobStatus);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numDone, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numActive, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numPending, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCanceled, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCanceling, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numFailed, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numFinished, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numSubmitted, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numHold, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numWaiting, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numCatalogFailed, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__TransferJobSummary::numRestarted, SOAP_TYPE_fts3_int);
	/* transient soap skipped */
}

int tns3__TransferJobSummary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJobSummary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJobSummary(struct soap *soap, const char *tag, int id, const tns3__TransferJobSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJobSummary), type))
		return soap->error;
	if (soap_out_PointerTotns3__JobStatus(soap, "jobStatus", -1, &(a->tns3__TransferJobSummary::jobStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "numDone", -1, &(a->tns3__TransferJobSummary::numDone), ""))
		return soap->error;
	if (soap_out_int(soap, "numActive", -1, &(a->tns3__TransferJobSummary::numActive), ""))
		return soap->error;
	if (soap_out_int(soap, "numPending", -1, &(a->tns3__TransferJobSummary::numPending), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceled", -1, &(a->tns3__TransferJobSummary::numCanceled), ""))
		return soap->error;
	if (soap_out_int(soap, "numCanceling", -1, &(a->tns3__TransferJobSummary::numCanceling), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailed", -1, &(a->tns3__TransferJobSummary::numFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numFinished", -1, &(a->tns3__TransferJobSummary::numFinished), ""))
		return soap->error;
	if (soap_out_int(soap, "numSubmitted", -1, &(a->tns3__TransferJobSummary::numSubmitted), ""))
		return soap->error;
	if (soap_out_int(soap, "numHold", -1, &(a->tns3__TransferJobSummary::numHold), ""))
		return soap->error;
	if (soap_out_int(soap, "numWaiting", -1, &(a->tns3__TransferJobSummary::numWaiting), ""))
		return soap->error;
	if (soap_out_int(soap, "numCatalogFailed", -1, &(a->tns3__TransferJobSummary::numCatalogFailed), ""))
		return soap->error;
	if (soap_out_int(soap, "numRestarted", -1, &(a->tns3__TransferJobSummary::numRestarted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJobSummary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJobSummary(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJobSummary * SOAP_FMAC4 soap_in_tns3__TransferJobSummary(struct soap *soap, const char *tag, tns3__TransferJobSummary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJobSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJobSummary, sizeof(tns3__TransferJobSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJobSummary)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJobSummary *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobStatus1 = 1;
	size_t soap_flag_numDone1 = 1;
	size_t soap_flag_numActive1 = 1;
	size_t soap_flag_numPending1 = 1;
	size_t soap_flag_numCanceled1 = 1;
	size_t soap_flag_numCanceling1 = 1;
	size_t soap_flag_numFailed1 = 1;
	size_t soap_flag_numFinished1 = 1;
	size_t soap_flag_numSubmitted1 = 1;
	size_t soap_flag_numHold1 = 1;
	size_t soap_flag_numWaiting1 = 1;
	size_t soap_flag_numCatalogFailed1 = 1;
	size_t soap_flag_numRestarted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__JobStatus(soap, "jobStatus", &(a->tns3__TransferJobSummary::jobStatus), "tns3:JobStatus"))
				{	soap_flag_jobStatus1--;
					continue;
				}
			if (soap_flag_numDone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numDone", &(a->tns3__TransferJobSummary::numDone), "xsd:int"))
				{	soap_flag_numDone1--;
					continue;
				}
			if (soap_flag_numActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numActive", &(a->tns3__TransferJobSummary::numActive), "xsd:int"))
				{	soap_flag_numActive1--;
					continue;
				}
			if (soap_flag_numPending1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numPending", &(a->tns3__TransferJobSummary::numPending), "xsd:int"))
				{	soap_flag_numPending1--;
					continue;
				}
			if (soap_flag_numCanceled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceled", &(a->tns3__TransferJobSummary::numCanceled), "xsd:int"))
				{	soap_flag_numCanceled1--;
					continue;
				}
			if (soap_flag_numCanceling1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCanceling", &(a->tns3__TransferJobSummary::numCanceling), "xsd:int"))
				{	soap_flag_numCanceling1--;
					continue;
				}
			if (soap_flag_numFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailed", &(a->tns3__TransferJobSummary::numFailed), "xsd:int"))
				{	soap_flag_numFailed1--;
					continue;
				}
			if (soap_flag_numFinished1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFinished", &(a->tns3__TransferJobSummary::numFinished), "xsd:int"))
				{	soap_flag_numFinished1--;
					continue;
				}
			if (soap_flag_numSubmitted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numSubmitted", &(a->tns3__TransferJobSummary::numSubmitted), "xsd:int"))
				{	soap_flag_numSubmitted1--;
					continue;
				}
			if (soap_flag_numHold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numHold", &(a->tns3__TransferJobSummary::numHold), "xsd:int"))
				{	soap_flag_numHold1--;
					continue;
				}
			if (soap_flag_numWaiting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numWaiting", &(a->tns3__TransferJobSummary::numWaiting), "xsd:int"))
				{	soap_flag_numWaiting1--;
					continue;
				}
			if (soap_flag_numCatalogFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numCatalogFailed", &(a->tns3__TransferJobSummary::numCatalogFailed), "xsd:int"))
				{	soap_flag_numCatalogFailed1--;
					continue;
				}
			if (soap_flag_numRestarted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numRestarted", &(a->tns3__TransferJobSummary::numRestarted), "xsd:int"))
				{	soap_flag_numRestarted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJobSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJobSummary, 0, sizeof(tns3__TransferJobSummary), 0, soap_copy_tns3__TransferJobSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numDone1 > 0 || soap_flag_numActive1 > 0 || soap_flag_numPending1 > 0 || soap_flag_numCanceled1 > 0 || soap_flag_numCanceling1 > 0 || soap_flag_numFailed1 > 0 || soap_flag_numFinished1 > 0 || soap_flag_numSubmitted1 > 0 || soap_flag_numHold1 > 0 || soap_flag_numWaiting1 > 0 || soap_flag_numCatalogFailed1 > 0 || soap_flag_numRestarted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__TransferJobSummary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJobSummary);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJobSummary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJobSummary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJobSummary(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJobSummary * SOAP_FMAC4 soap_get_tns3__TransferJobSummary(struct soap *soap, tns3__TransferJobSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJobSummary * SOAP_FMAC2 soap_instantiate_tns3__TransferJobSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJobSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJobSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tns3:TransferJobSummary2"))
	{	cp->type = SOAP_TYPE_fts3_tns3__TransferJobSummary2;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary2);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__TransferJobSummary2);
			((tns3__TransferJobSummary2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary2[n]);
			if (size)
				*size = n * sizeof(tns3__TransferJobSummary2);
			for (int i = 0; i < n; i++)
				((tns3__TransferJobSummary2*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__TransferJobSummary2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary);
		if (size)
			*size = sizeof(tns3__TransferJobSummary);
		((tns3__TransferJobSummary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobSummary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJobSummary);
		for (int i = 0; i < n; i++)
			((tns3__TransferJobSummary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJobSummary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJobSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJobSummary %p -> %p\n", q, p));
	*(tns3__TransferJobSummary*)p = *(tns3__TransferJobSummary*)q;
}

void tns3__FileTransferStatus2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__FileTransferStatus2::error_USCOREscope = NULL;
	this->tns3__FileTransferStatus2::error_USCOREphase = NULL;
	this->tns3__FileTransferStatus::logicalName = NULL;
	this->tns3__FileTransferStatus::sourceSURL = NULL;
	this->tns3__FileTransferStatus::destSURL = NULL;
	this->tns3__FileTransferStatus::transferFileState = NULL;
	soap_default_int(soap, &this->tns3__FileTransferStatus::numFailures);
	this->tns3__FileTransferStatus::reason = NULL;
	this->tns3__FileTransferStatus::reason_USCOREclass = NULL;
	soap_default_LONG64(soap, &this->tns3__FileTransferStatus::duration);
	/* transient soap skipped */
}

void tns3__FileTransferStatus2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus2::error_USCOREscope);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus2::error_USCOREphase);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::logicalName);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::sourceSURL);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::destSURL);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::transferFileState);
	soap_embedded(soap, &this->tns3__FileTransferStatus::numFailures, SOAP_TYPE_fts3_int);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::reason_USCOREclass);
	/* transient soap skipped */
}

int tns3__FileTransferStatus2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__FileTransferStatus2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__FileTransferStatus2(struct soap *soap, const char *tag, int id, const tns3__FileTransferStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__FileTransferStatus2), "tns3:FileTransferStatus2"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "logicalName", -1, &(a->tns3__FileTransferStatus::logicalName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSURL", -1, &(a->tns3__FileTransferStatus::sourceSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSURL", -1, &(a->tns3__FileTransferStatus::destSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "transferFileState", -1, &(a->tns3__FileTransferStatus::transferFileState), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailures", -1, &(a->tns3__FileTransferStatus::numFailures), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->tns3__FileTransferStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason_class", -1, &(a->tns3__FileTransferStatus::reason_USCOREclass), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "duration", -1, &(a->tns3__FileTransferStatus::duration), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "error_scope", -1, &(a->tns3__FileTransferStatus2::error_USCOREscope), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "error_phase", -1, &(a->tns3__FileTransferStatus2::error_USCOREphase), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tns3__FileTransferStatus2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__FileTransferStatus2(soap, tag, this, type);
}

SOAP_FMAC3 tns3__FileTransferStatus2 * SOAP_FMAC4 soap_in_tns3__FileTransferStatus2(struct soap *soap, const char *tag, tns3__FileTransferStatus2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__FileTransferStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__FileTransferStatus2, sizeof(tns3__FileTransferStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__FileTransferStatus2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__FileTransferStatus2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_logicalName2 = 1;
	size_t soap_flag_sourceSURL2 = 1;
	size_t soap_flag_destSURL2 = 1;
	size_t soap_flag_transferFileState2 = 1;
	size_t soap_flag_numFailures2 = 1;
	size_t soap_flag_reason2 = 1;
	size_t soap_flag_reason_USCOREclass2 = 1;
	size_t soap_flag_duration2 = 1;
	size_t soap_flag_error_USCOREscope1 = 1;
	size_t soap_flag_error_USCOREphase1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logicalName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "logicalName", &(a->tns3__FileTransferStatus::logicalName), "xsd:string"))
				{	soap_flag_logicalName2--;
					continue;
				}
			if (soap_flag_sourceSURL2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSURL", &(a->tns3__FileTransferStatus::sourceSURL), "xsd:string"))
				{	soap_flag_sourceSURL2--;
					continue;
				}
			if (soap_flag_destSURL2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSURL", &(a->tns3__FileTransferStatus::destSURL), "xsd:string"))
				{	soap_flag_destSURL2--;
					continue;
				}
			if (soap_flag_transferFileState2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "transferFileState", &(a->tns3__FileTransferStatus::transferFileState), "xsd:string"))
				{	soap_flag_transferFileState2--;
					continue;
				}
			if (soap_flag_numFailures2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailures", &(a->tns3__FileTransferStatus::numFailures), "xsd:int"))
				{	soap_flag_numFailures2--;
					continue;
				}
			if (soap_flag_reason2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->tns3__FileTransferStatus::reason), "xsd:string"))
				{	soap_flag_reason2--;
					continue;
				}
			if (soap_flag_reason_USCOREclass2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason_class", &(a->tns3__FileTransferStatus::reason_USCOREclass), "xsd:string"))
				{	soap_flag_reason_USCOREclass2--;
					continue;
				}
			if (soap_flag_duration2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "duration", &(a->tns3__FileTransferStatus::duration), "xsd:long"))
				{	soap_flag_duration2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_error_USCOREscope1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error_scope", &(a->tns3__FileTransferStatus2::error_USCOREscope), "xsd:string"))
				{	soap_flag_error_USCOREscope1--;
					continue;
				}
			if (soap_flag_error_USCOREphase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "error_phase", &(a->tns3__FileTransferStatus2::error_USCOREphase), "xsd:string"))
				{	soap_flag_error_USCOREphase1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__FileTransferStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__FileTransferStatus2, 0, sizeof(tns3__FileTransferStatus2), 0, soap_copy_tns3__FileTransferStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numFailures2 > 0 || soap_flag_duration2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__FileTransferStatus2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__FileTransferStatus2);
	if (this->soap_out(soap, tag?tag:"tns3:FileTransferStatus2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__FileTransferStatus2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__FileTransferStatus2(soap, this, tag, type);
}

SOAP_FMAC3 tns3__FileTransferStatus2 * SOAP_FMAC4 soap_get_tns3__FileTransferStatus2(struct soap *soap, tns3__FileTransferStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__FileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__FileTransferStatus2 * SOAP_FMAC2 soap_instantiate_tns3__FileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__FileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__FileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus2);
		if (size)
			*size = sizeof(tns3__FileTransferStatus2);
		((tns3__FileTransferStatus2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__FileTransferStatus2);
		for (int i = 0; i < n; i++)
			((tns3__FileTransferStatus2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__FileTransferStatus2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__FileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__FileTransferStatus2 %p -> %p\n", q, p));
	*(tns3__FileTransferStatus2*)p = *(tns3__FileTransferStatus2*)q;
}

void tns3__NotExistsException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__NotExistsException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__NotExistsException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__NotExistsException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__NotExistsException(struct soap *soap, const char *tag, int id, const tns3__NotExistsException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__NotExistsException), "tns3:NotExistsException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__NotExistsException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__NotExistsException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__NotExistsException * SOAP_FMAC4 soap_in_tns3__NotExistsException(struct soap *soap, const char *tag, tns3__NotExistsException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__NotExistsException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__NotExistsException, sizeof(tns3__NotExistsException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__NotExistsException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__NotExistsException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__NotExistsException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__NotExistsException, 0, sizeof(tns3__NotExistsException), 0, soap_copy_tns3__NotExistsException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__NotExistsException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__NotExistsException);
	if (this->soap_out(soap, tag?tag:"tns3:NotExistsException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__NotExistsException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__NotExistsException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__NotExistsException * SOAP_FMAC4 soap_get_tns3__NotExistsException(struct soap *soap, tns3__NotExistsException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__NotExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__NotExistsException * SOAP_FMAC2 soap_instantiate_tns3__NotExistsException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__NotExistsException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__NotExistsException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__NotExistsException);
		if (size)
			*size = sizeof(tns3__NotExistsException);
		((tns3__NotExistsException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__NotExistsException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__NotExistsException);
		for (int i = 0; i < n; i++)
			((tns3__NotExistsException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__NotExistsException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__NotExistsException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__NotExistsException %p -> %p\n", q, p));
	*(tns3__NotExistsException*)p = *(tns3__NotExistsException*)q;
}

void tns3__FileTransferStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__FileTransferStatus::logicalName = NULL;
	this->tns3__FileTransferStatus::sourceSURL = NULL;
	this->tns3__FileTransferStatus::destSURL = NULL;
	this->tns3__FileTransferStatus::transferFileState = NULL;
	soap_default_int(soap, &this->tns3__FileTransferStatus::numFailures);
	this->tns3__FileTransferStatus::reason = NULL;
	this->tns3__FileTransferStatus::reason_USCOREclass = NULL;
	soap_default_LONG64(soap, &this->tns3__FileTransferStatus::duration);
	/* transient soap skipped */
}

void tns3__FileTransferStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::logicalName);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::sourceSURL);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::destSURL);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::transferFileState);
	soap_embedded(soap, &this->tns3__FileTransferStatus::numFailures, SOAP_TYPE_fts3_int);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->tns3__FileTransferStatus::reason_USCOREclass);
	/* transient soap skipped */
}

int tns3__FileTransferStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__FileTransferStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__FileTransferStatus(struct soap *soap, const char *tag, int id, const tns3__FileTransferStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__FileTransferStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "logicalName", -1, &(a->tns3__FileTransferStatus::logicalName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSURL", -1, &(a->tns3__FileTransferStatus::sourceSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSURL", -1, &(a->tns3__FileTransferStatus::destSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "transferFileState", -1, &(a->tns3__FileTransferStatus::transferFileState), ""))
		return soap->error;
	if (soap_out_int(soap, "numFailures", -1, &(a->tns3__FileTransferStatus::numFailures), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->tns3__FileTransferStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason_class", -1, &(a->tns3__FileTransferStatus::reason_USCOREclass), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "duration", -1, &(a->tns3__FileTransferStatus::duration), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__FileTransferStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__FileTransferStatus(soap, tag, this, type);
}

SOAP_FMAC3 tns3__FileTransferStatus * SOAP_FMAC4 soap_in_tns3__FileTransferStatus(struct soap *soap, const char *tag, tns3__FileTransferStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__FileTransferStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__FileTransferStatus, sizeof(tns3__FileTransferStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__FileTransferStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__FileTransferStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_logicalName1 = 1;
	size_t soap_flag_sourceSURL1 = 1;
	size_t soap_flag_destSURL1 = 1;
	size_t soap_flag_transferFileState1 = 1;
	size_t soap_flag_numFailures1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_reason_USCOREclass1 = 1;
	size_t soap_flag_duration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logicalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "logicalName", &(a->tns3__FileTransferStatus::logicalName), "xsd:string"))
				{	soap_flag_logicalName1--;
					continue;
				}
			if (soap_flag_sourceSURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSURL", &(a->tns3__FileTransferStatus::sourceSURL), "xsd:string"))
				{	soap_flag_sourceSURL1--;
					continue;
				}
			if (soap_flag_destSURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSURL", &(a->tns3__FileTransferStatus::destSURL), "xsd:string"))
				{	soap_flag_destSURL1--;
					continue;
				}
			if (soap_flag_transferFileState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "transferFileState", &(a->tns3__FileTransferStatus::transferFileState), "xsd:string"))
				{	soap_flag_transferFileState1--;
					continue;
				}
			if (soap_flag_numFailures1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFailures", &(a->tns3__FileTransferStatus::numFailures), "xsd:int"))
				{	soap_flag_numFailures1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->tns3__FileTransferStatus::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_reason_USCOREclass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason_class", &(a->tns3__FileTransferStatus::reason_USCOREclass), "xsd:string"))
				{	soap_flag_reason_USCOREclass1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "duration", &(a->tns3__FileTransferStatus::duration), "xsd:long"))
				{	soap_flag_duration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__FileTransferStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__FileTransferStatus, 0, sizeof(tns3__FileTransferStatus), 0, soap_copy_tns3__FileTransferStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_numFailures1 > 0 || soap_flag_duration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__FileTransferStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__FileTransferStatus);
	if (this->soap_out(soap, tag?tag:"tns3:FileTransferStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__FileTransferStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__FileTransferStatus(soap, this, tag, type);
}

SOAP_FMAC3 tns3__FileTransferStatus * SOAP_FMAC4 soap_get_tns3__FileTransferStatus(struct soap *soap, tns3__FileTransferStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__FileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__FileTransferStatus * SOAP_FMAC2 soap_instantiate_tns3__FileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__FileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__FileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tns3:FileTransferStatus2"))
	{	cp->type = SOAP_TYPE_fts3_tns3__FileTransferStatus2;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus2);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__FileTransferStatus2);
			((tns3__FileTransferStatus2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus2[n]);
			if (size)
				*size = n * sizeof(tns3__FileTransferStatus2);
			for (int i = 0; i < n; i++)
				((tns3__FileTransferStatus2*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__FileTransferStatus2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus);
		if (size)
			*size = sizeof(tns3__FileTransferStatus);
		((tns3__FileTransferStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__FileTransferStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__FileTransferStatus);
		for (int i = 0; i < n; i++)
			((tns3__FileTransferStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__FileTransferStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__FileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__FileTransferStatus %p -> %p\n", q, p));
	*(tns3__FileTransferStatus*)p = *(tns3__FileTransferStatus*)q;
}

void tns3__JobStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__JobStatus::jobID = NULL;
	this->tns3__JobStatus::jobStatus = NULL;
	this->tns3__JobStatus::clientDN = NULL;
	this->tns3__JobStatus::reason = NULL;
	this->tns3__JobStatus::voName = NULL;
	soap_default_LONG64(soap, &this->tns3__JobStatus::submitTime);
	soap_default_int(soap, &this->tns3__JobStatus::numFiles);
	soap_default_int(soap, &this->tns3__JobStatus::priority);
	/* transient soap skipped */
}

void tns3__JobStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__JobStatus::jobID);
	soap_serialize_PointerTostd__string(soap, &this->tns3__JobStatus::jobStatus);
	soap_serialize_PointerTostd__string(soap, &this->tns3__JobStatus::clientDN);
	soap_serialize_PointerTostd__string(soap, &this->tns3__JobStatus::reason);
	soap_serialize_PointerTostd__string(soap, &this->tns3__JobStatus::voName);
	soap_embedded(soap, &this->tns3__JobStatus::numFiles, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &this->tns3__JobStatus::priority, SOAP_TYPE_fts3_int);
	/* transient soap skipped */
}

int tns3__JobStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__JobStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__JobStatus(struct soap *soap, const char *tag, int id, const tns3__JobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__JobStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jobID", -1, &(a->tns3__JobStatus::jobID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jobStatus", -1, &(a->tns3__JobStatus::jobStatus), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "clientDN", -1, &(a->tns3__JobStatus::clientDN), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "reason", -1, &(a->tns3__JobStatus::reason), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "voName", -1, &(a->tns3__JobStatus::voName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "submitTime", -1, &(a->tns3__JobStatus::submitTime), ""))
		return soap->error;
	if (soap_out_int(soap, "numFiles", -1, &(a->tns3__JobStatus::numFiles), ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &(a->tns3__JobStatus::priority), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__JobStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__JobStatus(soap, tag, this, type);
}

SOAP_FMAC3 tns3__JobStatus * SOAP_FMAC4 soap_in_tns3__JobStatus(struct soap *soap, const char *tag, tns3__JobStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__JobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__JobStatus, sizeof(tns3__JobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__JobStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__JobStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_jobStatus1 = 1;
	size_t soap_flag_clientDN1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_voName1 = 1;
	size_t soap_flag_submitTime1 = 1;
	size_t soap_flag_numFiles1 = 1;
	size_t soap_flag_priority1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jobID", &(a->tns3__JobStatus::jobID), "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_jobStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jobStatus", &(a->tns3__JobStatus::jobStatus), "xsd:string"))
				{	soap_flag_jobStatus1--;
					continue;
				}
			if (soap_flag_clientDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "clientDN", &(a->tns3__JobStatus::clientDN), "xsd:string"))
				{	soap_flag_clientDN1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "reason", &(a->tns3__JobStatus::reason), "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_voName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "voName", &(a->tns3__JobStatus::voName), "xsd:string"))
				{	soap_flag_voName1--;
					continue;
				}
			if (soap_flag_submitTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "submitTime", &(a->tns3__JobStatus::submitTime), "xsd:long"))
				{	soap_flag_submitTime1--;
					continue;
				}
			if (soap_flag_numFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numFiles", &(a->tns3__JobStatus::numFiles), "xsd:int"))
				{	soap_flag_numFiles1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "priority", &(a->tns3__JobStatus::priority), "xsd:int"))
				{	soap_flag_priority1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__JobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__JobStatus, 0, sizeof(tns3__JobStatus), 0, soap_copy_tns3__JobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_submitTime1 > 0 || soap_flag_numFiles1 > 0 || soap_flag_priority1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__JobStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__JobStatus);
	if (this->soap_out(soap, tag?tag:"tns3:JobStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__JobStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__JobStatus(soap, this, tag, type);
}

SOAP_FMAC3 tns3__JobStatus * SOAP_FMAC4 soap_get_tns3__JobStatus(struct soap *soap, tns3__JobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__JobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__JobStatus * SOAP_FMAC2 soap_instantiate_tns3__JobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__JobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__JobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__JobStatus);
		if (size)
			*size = sizeof(tns3__JobStatus);
		((tns3__JobStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__JobStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__JobStatus);
		for (int i = 0; i < n; i++)
			((tns3__JobStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__JobStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__JobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__JobStatus %p -> %p\n", q, p));
	*(tns3__JobStatus*)p = *(tns3__JobStatus*)q;
}

void tns3__TransferJob3::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, &this->tns3__TransferJob3::transferJobElements);
	this->tns3__TransferJob3::jobParams = NULL;
	/* transient soap skipped */
}

void tns3__TransferJob3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, &this->tns3__TransferJob3::transferJobElements);
	soap_serialize_PointerTotns3__TransferParams(soap, &this->tns3__TransferJob3::jobParams);
	/* transient soap skipped */
}

int tns3__TransferJob3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJob3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJob3(struct soap *soap, const char *tag, int id, const tns3__TransferJob3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJob3), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, "transferJobElements", -1, &(a->tns3__TransferJob3::transferJobElements), ""))
		return soap->error;
	if (soap_out_PointerTotns3__TransferParams(soap, "jobParams", -1, &(a->tns3__TransferJob3::jobParams), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJob3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJob3(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJob3 * SOAP_FMAC4 soap_in_tns3__TransferJob3(struct soap *soap, const char *tag, tns3__TransferJob3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJob3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJob3, sizeof(tns3__TransferJob3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJob3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJob3 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobParams1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, "transferJobElements", &(a->tns3__TransferJob3::transferJobElements), "tns3:TransferJobElement3"))
					continue;
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferParams(soap, "jobParams", &(a->tns3__TransferJob3::jobParams), "tns3:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJob3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJob3, 0, sizeof(tns3__TransferJob3), 0, soap_copy_tns3__TransferJob3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tns3__TransferJob3::transferJobElements.size() < 1 || soap_flag_jobParams1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__TransferJob3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJob3);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJob3", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJob3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJob3(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJob3 * SOAP_FMAC4 soap_get_tns3__TransferJob3(struct soap *soap, tns3__TransferJob3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJob3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJob3 * SOAP_FMAC2 soap_instantiate_tns3__TransferJob3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJob3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJob3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob3);
		if (size)
			*size = sizeof(tns3__TransferJob3);
		((tns3__TransferJob3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob3[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJob3);
		for (int i = 0; i < n; i++)
			((tns3__TransferJob3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJob3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJob3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJob3 %p -> %p\n", q, p));
	*(tns3__TransferJob3*)p = *(tns3__TransferJob3*)q;
}

void tns3__TransferJobElement3::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tns3__TransferJobElement3::source);
	soap_default_std__string(soap, &this->tns3__TransferJobElement3::dest);
	this->tns3__TransferJobElement3::checksum = NULL;
	this->tns3__TransferJobElement3::filesize = NULL;
	this->tns3__TransferJobElement3::metadata = NULL;
	/* transient soap skipped */
}

void tns3__TransferJobElement3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tns3__TransferJobElement3::source, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &this->tns3__TransferJobElement3::source);
	soap_embedded(soap, &this->tns3__TransferJobElement3::dest, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &this->tns3__TransferJobElement3::dest);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement3::checksum);
	soap_serialize_PointerToint(soap, &this->tns3__TransferJobElement3::filesize);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement3::metadata);
	/* transient soap skipped */
}

int tns3__TransferJobElement3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJobElement3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJobElement3(struct soap *soap, const char *tag, int id, const tns3__TransferJobElement3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJobElement3), type))
		return soap->error;
	if (soap_out_std__string(soap, "source", -1, &(a->tns3__TransferJobElement3::source), ""))
		return soap->error;
	if (soap_out_std__string(soap, "dest", -1, &(a->tns3__TransferJobElement3::dest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "checksum", -1, &(a->tns3__TransferJobElement3::checksum), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "filesize", -1, &(a->tns3__TransferJobElement3::filesize), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "metadata", -1, &(a->tns3__TransferJobElement3::metadata), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJobElement3::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJobElement3(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJobElement3 * SOAP_FMAC4 soap_in_tns3__TransferJobElement3(struct soap *soap, const char *tag, tns3__TransferJobElement3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJobElement3 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJobElement3, sizeof(tns3__TransferJobElement3), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJobElement3)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJobElement3 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_dest1 = 1;
	size_t soap_flag_checksum1 = 1;
	size_t soap_flag_filesize1 = 1;
	size_t soap_flag_metadata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "source", &(a->tns3__TransferJobElement3::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_dest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "dest", &(a->tns3__TransferJobElement3::dest), "xsd:string"))
				{	soap_flag_dest1--;
					continue;
				}
			if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "checksum", &(a->tns3__TransferJobElement3::checksum), "xsd:string"))
				{	soap_flag_checksum1--;
					continue;
				}
			if (soap_flag_filesize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "filesize", &(a->tns3__TransferJobElement3::filesize), "xsd:int"))
				{	soap_flag_filesize1--;
					continue;
				}
			if (soap_flag_metadata1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "metadata", &(a->tns3__TransferJobElement3::metadata), "xsd:string"))
				{	soap_flag_metadata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJobElement3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJobElement3, 0, sizeof(tns3__TransferJobElement3), 0, soap_copy_tns3__TransferJobElement3);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_source1 > 0 || soap_flag_dest1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns3__TransferJobElement3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJobElement3);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJobElement3", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJobElement3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJobElement3(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJobElement3 * SOAP_FMAC4 soap_get_tns3__TransferJobElement3(struct soap *soap, tns3__TransferJobElement3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJobElement3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJobElement3 * SOAP_FMAC2 soap_instantiate_tns3__TransferJobElement3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJobElement3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJobElement3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement3);
		if (size)
			*size = sizeof(tns3__TransferJobElement3);
		((tns3__TransferJobElement3*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement3[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJobElement3);
		for (int i = 0; i < n; i++)
			((tns3__TransferJobElement3*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJobElement3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJobElement3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJobElement3 %p -> %p\n", q, p));
	*(tns3__TransferJobElement3*)p = *(tns3__TransferJobElement3*)q;
}

void tns3__TransferJob2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, &this->tns3__TransferJob2::transferJobElements);
	this->tns3__TransferJob2::jobParams = NULL;
	this->tns3__TransferJob2::credential = NULL;
	/* transient soap skipped */
}

void tns3__TransferJob2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, &this->tns3__TransferJob2::transferJobElements);
	soap_serialize_PointerTotns3__TransferParams(soap, &this->tns3__TransferJob2::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJob2::credential);
	/* transient soap skipped */
}

int tns3__TransferJob2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJob2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJob2(struct soap *soap, const char *tag, int id, const tns3__TransferJob2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJob2), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, "transferJobElements", -1, &(a->tns3__TransferJob2::transferJobElements), ""))
		return soap->error;
	if (soap_out_PointerTotns3__TransferParams(soap, "jobParams", -1, &(a->tns3__TransferJob2::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->tns3__TransferJob2::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJob2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJob2(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJob2 * SOAP_FMAC4 soap_in_tns3__TransferJob2(struct soap *soap, const char *tag, tns3__TransferJob2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJob2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJob2, sizeof(tns3__TransferJob2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJob2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJob2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, "transferJobElements", &(a->tns3__TransferJob2::transferJobElements), "tns3:TransferJobElement2"))
					continue;
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferParams(soap, "jobParams", &(a->tns3__TransferJob2::jobParams), "tns3:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->tns3__TransferJob2::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJob2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJob2, 0, sizeof(tns3__TransferJob2), 0, soap_copy_tns3__TransferJob2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferJob2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJob2);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJob2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJob2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJob2(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJob2 * SOAP_FMAC4 soap_get_tns3__TransferJob2(struct soap *soap, tns3__TransferJob2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJob2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJob2 * SOAP_FMAC2 soap_instantiate_tns3__TransferJob2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJob2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJob2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob2);
		if (size)
			*size = sizeof(tns3__TransferJob2);
		((tns3__TransferJob2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJob2);
		for (int i = 0; i < n; i++)
			((tns3__TransferJob2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJob2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJob2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJob2 %p -> %p\n", q, p));
	*(tns3__TransferJob2*)p = *(tns3__TransferJob2*)q;
}

void tns3__TransferJobElement2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferJobElement2::source = NULL;
	this->tns3__TransferJobElement2::dest = NULL;
	this->tns3__TransferJobElement2::checksum = NULL;
	/* transient soap skipped */
}

void tns3__TransferJobElement2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement2::source);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement2::dest);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement2::checksum);
	/* transient soap skipped */
}

int tns3__TransferJobElement2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJobElement2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJobElement2(struct soap *soap, const char *tag, int id, const tns3__TransferJobElement2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJobElement2), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "source", -1, &(a->tns3__TransferJobElement2::source), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dest", -1, &(a->tns3__TransferJobElement2::dest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "checksum", -1, &(a->tns3__TransferJobElement2::checksum), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJobElement2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJobElement2(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJobElement2 * SOAP_FMAC4 soap_in_tns3__TransferJobElement2(struct soap *soap, const char *tag, tns3__TransferJobElement2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJobElement2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJobElement2, sizeof(tns3__TransferJobElement2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJobElement2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJobElement2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_dest1 = 1;
	size_t soap_flag_checksum1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "source", &(a->tns3__TransferJobElement2::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_dest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "dest", &(a->tns3__TransferJobElement2::dest), "xsd:string"))
				{	soap_flag_dest1--;
					continue;
				}
			if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "checksum", &(a->tns3__TransferJobElement2::checksum), "xsd:string"))
				{	soap_flag_checksum1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJobElement2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJobElement2, 0, sizeof(tns3__TransferJobElement2), 0, soap_copy_tns3__TransferJobElement2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferJobElement2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJobElement2);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJobElement2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJobElement2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJobElement2(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJobElement2 * SOAP_FMAC4 soap_get_tns3__TransferJobElement2(struct soap *soap, tns3__TransferJobElement2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJobElement2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJobElement2 * SOAP_FMAC2 soap_instantiate_tns3__TransferJobElement2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJobElement2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJobElement2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement2);
		if (size)
			*size = sizeof(tns3__TransferJobElement2);
		((tns3__TransferJobElement2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJobElement2);
		for (int i = 0; i < n; i++)
			((tns3__TransferJobElement2*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJobElement2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJobElement2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJobElement2 %p -> %p\n", q, p));
	*(tns3__TransferJobElement2*)p = *(tns3__TransferJobElement2*)q;
}

void tns3__TransferJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, &this->tns3__TransferJob::transferJobElements);
	this->tns3__TransferJob::jobParams = NULL;
	this->tns3__TransferJob::credential = NULL;
	/* transient soap skipped */
}

void tns3__TransferJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, &this->tns3__TransferJob::transferJobElements);
	soap_serialize_PointerTotns3__TransferParams(soap, &this->tns3__TransferJob::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJob::credential);
	/* transient soap skipped */
}

int tns3__TransferJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJob(struct soap *soap, const char *tag, int id, const tns3__TransferJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, "transferJobElements", -1, &(a->tns3__TransferJob::transferJobElements), ""))
		return soap->error;
	if (soap_out_PointerTotns3__TransferParams(soap, "jobParams", -1, &(a->tns3__TransferJob::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->tns3__TransferJob::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJob(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJob * SOAP_FMAC4 soap_in_tns3__TransferJob(struct soap *soap, const char *tag, tns3__TransferJob *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJob, sizeof(tns3__TransferJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, "transferJobElements", &(a->tns3__TransferJob::transferJobElements), "tns3:TransferJobElement"))
					continue;
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferParams(soap, "jobParams", &(a->tns3__TransferJob::jobParams), "tns3:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->tns3__TransferJob::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJob, 0, sizeof(tns3__TransferJob), 0, soap_copy_tns3__TransferJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJob);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJob(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJob * SOAP_FMAC4 soap_get_tns3__TransferJob(struct soap *soap, tns3__TransferJob *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJob * SOAP_FMAC2 soap_instantiate_tns3__TransferJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob);
		if (size)
			*size = sizeof(tns3__TransferJob);
		((tns3__TransferJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJob);
		for (int i = 0; i < n; i++)
			((tns3__TransferJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJob %p -> %p\n", q, p));
	*(tns3__TransferJob*)p = *(tns3__TransferJob*)q;
}

void tns3__TransferJobElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferJobElement::source = NULL;
	this->tns3__TransferJobElement::dest = NULL;
	/* transient soap skipped */
}

void tns3__TransferJobElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement::source);
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferJobElement::dest);
	/* transient soap skipped */
}

int tns3__TransferJobElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferJobElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferJobElement(struct soap *soap, const char *tag, int id, const tns3__TransferJobElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferJobElement), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "source", -1, &(a->tns3__TransferJobElement::source), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dest", -1, &(a->tns3__TransferJobElement::dest), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferJobElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferJobElement(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferJobElement * SOAP_FMAC4 soap_in_tns3__TransferJobElement(struct soap *soap, const char *tag, tns3__TransferJobElement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferJobElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferJobElement, sizeof(tns3__TransferJobElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferJobElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferJobElement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_dest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "source", &(a->tns3__TransferJobElement::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_dest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "dest", &(a->tns3__TransferJobElement::dest), "xsd:string"))
				{	soap_flag_dest1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferJobElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferJobElement, 0, sizeof(tns3__TransferJobElement), 0, soap_copy_tns3__TransferJobElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferJobElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferJobElement);
	if (this->soap_out(soap, tag?tag:"tns3:TransferJobElement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferJobElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferJobElement(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferJobElement * SOAP_FMAC4 soap_get_tns3__TransferJobElement(struct soap *soap, tns3__TransferJobElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferJobElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferJobElement * SOAP_FMAC2 soap_instantiate_tns3__TransferJobElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferJobElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferJobElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement);
		if (size)
			*size = sizeof(tns3__TransferJobElement);
		((tns3__TransferJobElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferJobElement[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferJobElement);
		for (int i = 0; i < n; i++)
			((tns3__TransferJobElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferJobElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferJobElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferJobElement %p -> %p\n", q, p));
	*(tns3__TransferJobElement*)p = *(tns3__TransferJobElement*)q;
}

void tns3__InternalException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__InternalException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__InternalException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__InternalException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__InternalException(struct soap *soap, const char *tag, int id, const tns3__InternalException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__InternalException), "tns3:InternalException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__InternalException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__InternalException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__InternalException * SOAP_FMAC4 soap_in_tns3__InternalException(struct soap *soap, const char *tag, tns3__InternalException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__InternalException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__InternalException, sizeof(tns3__InternalException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__InternalException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__InternalException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__InternalException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__InternalException, 0, sizeof(tns3__InternalException), 0, soap_copy_tns3__InternalException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__InternalException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__InternalException);
	if (this->soap_out(soap, tag?tag:"tns3:InternalException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__InternalException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__InternalException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__InternalException * SOAP_FMAC4 soap_get_tns3__InternalException(struct soap *soap, tns3__InternalException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__InternalException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__InternalException * SOAP_FMAC2 soap_instantiate_tns3__InternalException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__InternalException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__InternalException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__InternalException);
		if (size)
			*size = sizeof(tns3__InternalException);
		((tns3__InternalException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__InternalException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__InternalException);
		for (int i = 0; i < n; i++)
			((tns3__InternalException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__InternalException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__InternalException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__InternalException %p -> %p\n", q, p));
	*(tns3__InternalException*)p = *(tns3__InternalException*)q;
}

void tns3__ServiceBusyException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__ServiceBusyException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__ServiceBusyException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__ServiceBusyException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__ServiceBusyException(struct soap *soap, const char *tag, int id, const tns3__ServiceBusyException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__ServiceBusyException), "tns3:ServiceBusyException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__ServiceBusyException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__ServiceBusyException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__ServiceBusyException * SOAP_FMAC4 soap_in_tns3__ServiceBusyException(struct soap *soap, const char *tag, tns3__ServiceBusyException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__ServiceBusyException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__ServiceBusyException, sizeof(tns3__ServiceBusyException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__ServiceBusyException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__ServiceBusyException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__ServiceBusyException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__ServiceBusyException, 0, sizeof(tns3__ServiceBusyException), 0, soap_copy_tns3__ServiceBusyException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__ServiceBusyException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__ServiceBusyException);
	if (this->soap_out(soap, tag?tag:"tns3:ServiceBusyException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__ServiceBusyException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__ServiceBusyException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__ServiceBusyException * SOAP_FMAC4 soap_get_tns3__ServiceBusyException(struct soap *soap, tns3__ServiceBusyException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__ServiceBusyException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__ServiceBusyException * SOAP_FMAC2 soap_instantiate_tns3__ServiceBusyException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__ServiceBusyException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__ServiceBusyException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__ServiceBusyException);
		if (size)
			*size = sizeof(tns3__ServiceBusyException);
		((tns3__ServiceBusyException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__ServiceBusyException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__ServiceBusyException);
		for (int i = 0; i < n; i++)
			((tns3__ServiceBusyException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__ServiceBusyException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__ServiceBusyException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__ServiceBusyException %p -> %p\n", q, p));
	*(tns3__ServiceBusyException*)p = *(tns3__ServiceBusyException*)q;
}

void tns3__AuthorizationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__AuthorizationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__AuthorizationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__AuthorizationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__AuthorizationException(struct soap *soap, const char *tag, int id, const tns3__AuthorizationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__AuthorizationException), "tns3:AuthorizationException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__AuthorizationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__AuthorizationException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__AuthorizationException * SOAP_FMAC4 soap_in_tns3__AuthorizationException(struct soap *soap, const char *tag, tns3__AuthorizationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__AuthorizationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__AuthorizationException, sizeof(tns3__AuthorizationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__AuthorizationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__AuthorizationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__AuthorizationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__AuthorizationException, 0, sizeof(tns3__AuthorizationException), 0, soap_copy_tns3__AuthorizationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__AuthorizationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__AuthorizationException);
	if (this->soap_out(soap, tag?tag:"tns3:AuthorizationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__AuthorizationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__AuthorizationException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__AuthorizationException * SOAP_FMAC4 soap_get_tns3__AuthorizationException(struct soap *soap, tns3__AuthorizationException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__AuthorizationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__AuthorizationException * SOAP_FMAC2 soap_instantiate_tns3__AuthorizationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__AuthorizationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__AuthorizationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__AuthorizationException);
		if (size)
			*size = sizeof(tns3__AuthorizationException);
		((tns3__AuthorizationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__AuthorizationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__AuthorizationException);
		for (int i = 0; i < n; i++)
			((tns3__AuthorizationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__AuthorizationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__AuthorizationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__AuthorizationException %p -> %p\n", q, p));
	*(tns3__AuthorizationException*)p = *(tns3__AuthorizationException*)q;
}

void tns3__InvalidArgumentException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__InvalidArgumentException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__InvalidArgumentException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__InvalidArgumentException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__InvalidArgumentException(struct soap *soap, const char *tag, int id, const tns3__InvalidArgumentException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__InvalidArgumentException), "tns3:InvalidArgumentException"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__InvalidArgumentException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__InvalidArgumentException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__InvalidArgumentException * SOAP_FMAC4 soap_in_tns3__InvalidArgumentException(struct soap *soap, const char *tag, tns3__InvalidArgumentException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__InvalidArgumentException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__InvalidArgumentException, sizeof(tns3__InvalidArgumentException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__InvalidArgumentException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__InvalidArgumentException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__InvalidArgumentException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__InvalidArgumentException, 0, sizeof(tns3__InvalidArgumentException), 0, soap_copy_tns3__InvalidArgumentException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__InvalidArgumentException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__InvalidArgumentException);
	if (this->soap_out(soap, tag?tag:"tns3:InvalidArgumentException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__InvalidArgumentException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__InvalidArgumentException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__InvalidArgumentException * SOAP_FMAC4 soap_get_tns3__InvalidArgumentException(struct soap *soap, tns3__InvalidArgumentException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__InvalidArgumentException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__InvalidArgumentException * SOAP_FMAC2 soap_instantiate_tns3__InvalidArgumentException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__InvalidArgumentException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__InvalidArgumentException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__InvalidArgumentException);
		if (size)
			*size = sizeof(tns3__InvalidArgumentException);
		((tns3__InvalidArgumentException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__InvalidArgumentException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__InvalidArgumentException);
		for (int i = 0; i < n; i++)
			((tns3__InvalidArgumentException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__InvalidArgumentException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__InvalidArgumentException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__InvalidArgumentException %p -> %p\n", q, p));
	*(tns3__InvalidArgumentException*)p = *(tns3__InvalidArgumentException*)q;
}

void tns3__TransferException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns3__TransferException::message = NULL;
	/* transient soap skipped */
}

void tns3__TransferException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns3__TransferException::message);
	/* transient soap skipped */
}

int tns3__TransferException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferException(struct soap *soap, const char *tag, int id, const tns3__TransferException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->tns3__TransferException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferException(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferException * SOAP_FMAC4 soap_in_tns3__TransferException(struct soap *soap, const char *tag, tns3__TransferException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferException, sizeof(tns3__TransferException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->tns3__TransferException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferException, 0, sizeof(tns3__TransferException), 0, soap_copy_tns3__TransferException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferException);
	if (this->soap_out(soap, tag?tag:"tns3:TransferException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferException(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferException * SOAP_FMAC4 soap_get_tns3__TransferException(struct soap *soap, tns3__TransferException *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferException * SOAP_FMAC2 soap_instantiate_tns3__TransferException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tns3:InvalidArgumentException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__InvalidArgumentException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__InvalidArgumentException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__InvalidArgumentException);
			((tns3__InvalidArgumentException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__InvalidArgumentException[n]);
			if (size)
				*size = n * sizeof(tns3__InvalidArgumentException);
			for (int i = 0; i < n; i++)
				((tns3__InvalidArgumentException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__InvalidArgumentException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:AuthorizationException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__AuthorizationException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__AuthorizationException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__AuthorizationException);
			((tns3__AuthorizationException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__AuthorizationException[n]);
			if (size)
				*size = n * sizeof(tns3__AuthorizationException);
			for (int i = 0; i < n; i++)
				((tns3__AuthorizationException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__AuthorizationException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:ServiceBusyException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__ServiceBusyException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__ServiceBusyException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__ServiceBusyException);
			((tns3__ServiceBusyException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__ServiceBusyException[n]);
			if (size)
				*size = n * sizeof(tns3__ServiceBusyException);
			for (int i = 0; i < n; i++)
				((tns3__ServiceBusyException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__ServiceBusyException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:InternalException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__InternalException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__InternalException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__InternalException);
			((tns3__InternalException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__InternalException[n]);
			if (size)
				*size = n * sizeof(tns3__InternalException);
			for (int i = 0; i < n; i++)
				((tns3__InternalException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__InternalException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:NotExistsException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__NotExistsException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__NotExistsException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__NotExistsException);
			((tns3__NotExistsException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__NotExistsException[n]);
			if (size)
				*size = n * sizeof(tns3__NotExistsException);
			for (int i = 0; i < n; i++)
				((tns3__NotExistsException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__NotExistsException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:CannotCancelException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__CannotCancelException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__CannotCancelException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__CannotCancelException);
			((tns3__CannotCancelException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__CannotCancelException[n]);
			if (size)
				*size = n * sizeof(tns3__CannotCancelException);
			for (int i = 0; i < n; i++)
				((tns3__CannotCancelException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__CannotCancelException*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tns3:ExistsException"))
	{	cp->type = SOAP_TYPE_fts3_tns3__ExistsException;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tns3__ExistsException);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tns3__ExistsException);
			((tns3__ExistsException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tns3__ExistsException[n]);
			if (size)
				*size = n * sizeof(tns3__ExistsException);
			for (int i = 0; i < n; i++)
				((tns3__ExistsException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tns3__ExistsException*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferException);
		if (size)
			*size = sizeof(tns3__TransferException);
		((tns3__TransferException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferException);
		for (int i = 0; i < n; i++)
			((tns3__TransferException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferException %p -> %p\n", q, p));
	*(tns3__TransferException*)p = *(tns3__TransferException*)q;
}

void tns3__PlacementJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tns3__PlacementJob::logicalFiles);
	this->tns3__PlacementJob::sourceSE = NULL;
	this->tns3__PlacementJob::destSE = NULL;
	this->tns3__PlacementJob::jobParams = NULL;
	this->tns3__PlacementJob::credential = NULL;
	/* transient soap skipped */
}

void tns3__PlacementJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tns3__PlacementJob::logicalFiles);
	soap_serialize_PointerTostd__string(soap, &this->tns3__PlacementJob::sourceSE);
	soap_serialize_PointerTostd__string(soap, &this->tns3__PlacementJob::destSE);
	soap_serialize_PointerTotns3__TransferParams(soap, &this->tns3__PlacementJob::jobParams);
	soap_serialize_PointerTostd__string(soap, &this->tns3__PlacementJob::credential);
	/* transient soap skipped */
}

int tns3__PlacementJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__PlacementJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__PlacementJob(struct soap *soap, const char *tag, int id, const tns3__PlacementJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__PlacementJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "logicalFiles", -1, &(a->tns3__PlacementJob::logicalFiles), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "sourceSE", -1, &(a->tns3__PlacementJob::sourceSE), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "destSE", -1, &(a->tns3__PlacementJob::destSE), ""))
		return soap->error;
	if (soap_out_PointerTotns3__TransferParams(soap, "jobParams", -1, &(a->tns3__PlacementJob::jobParams), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "credential", -1, &(a->tns3__PlacementJob::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__PlacementJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__PlacementJob(soap, tag, this, type);
}

SOAP_FMAC3 tns3__PlacementJob * SOAP_FMAC4 soap_in_tns3__PlacementJob(struct soap *soap, const char *tag, tns3__PlacementJob *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__PlacementJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__PlacementJob, sizeof(tns3__PlacementJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__PlacementJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__PlacementJob *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sourceSE1 = 1;
	size_t soap_flag_destSE1 = 1;
	size_t soap_flag_jobParams1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "logicalFiles", &(a->tns3__PlacementJob::logicalFiles), "xsd:string"))
					continue;
			if (soap_flag_sourceSE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "sourceSE", &(a->tns3__PlacementJob::sourceSE), "xsd:string"))
				{	soap_flag_sourceSE1--;
					continue;
				}
			if (soap_flag_destSE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "destSE", &(a->tns3__PlacementJob::destSE), "xsd:string"))
				{	soap_flag_destSE1--;
					continue;
				}
			if (soap_flag_jobParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferParams(soap, "jobParams", &(a->tns3__PlacementJob::jobParams), "tns3:TransferParams"))
				{	soap_flag_jobParams1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "credential", &(a->tns3__PlacementJob::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__PlacementJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__PlacementJob, 0, sizeof(tns3__PlacementJob), 0, soap_copy_tns3__PlacementJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__PlacementJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__PlacementJob);
	if (this->soap_out(soap, tag?tag:"tns3:PlacementJob", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__PlacementJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__PlacementJob(soap, this, tag, type);
}

SOAP_FMAC3 tns3__PlacementJob * SOAP_FMAC4 soap_get_tns3__PlacementJob(struct soap *soap, tns3__PlacementJob *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__PlacementJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__PlacementJob * SOAP_FMAC2 soap_instantiate_tns3__PlacementJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__PlacementJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__PlacementJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__PlacementJob);
		if (size)
			*size = sizeof(tns3__PlacementJob);
		((tns3__PlacementJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__PlacementJob[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__PlacementJob);
		for (int i = 0; i < n; i++)
			((tns3__PlacementJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__PlacementJob*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__PlacementJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__PlacementJob %p -> %p\n", q, p));
	*(tns3__PlacementJob*)p = *(tns3__PlacementJob*)q;
}

void tns3__TransferParams::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tns3__TransferParams::keys);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tns3__TransferParams::values);
	/* transient soap skipped */
}

void tns3__TransferParams::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tns3__TransferParams::keys);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tns3__TransferParams::values);
	/* transient soap skipped */
}

int tns3__TransferParams::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns3__TransferParams(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns3__TransferParams(struct soap *soap, const char *tag, int id, const tns3__TransferParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_tns3__TransferParams), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "keys", -1, &(a->tns3__TransferParams::keys), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "values", -1, &(a->tns3__TransferParams::values), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns3__TransferParams::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns3__TransferParams(soap, tag, this, type);
}

SOAP_FMAC3 tns3__TransferParams * SOAP_FMAC4 soap_in_tns3__TransferParams(struct soap *soap, const char *tag, tns3__TransferParams *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns3__TransferParams *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_tns3__TransferParams, sizeof(tns3__TransferParams), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fts3_tns3__TransferParams)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns3__TransferParams *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "keys", &(a->tns3__TransferParams::keys), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "values", &(a->tns3__TransferParams::values), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns3__TransferParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_tns3__TransferParams, 0, sizeof(tns3__TransferParams), 0, soap_copy_tns3__TransferParams);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns3__TransferParams::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fts3_tns3__TransferParams);
	if (this->soap_out(soap, tag?tag:"tns3:TransferParams", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns3__TransferParams::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns3__TransferParams(soap, this, tag, type);
}

SOAP_FMAC3 tns3__TransferParams * SOAP_FMAC4 soap_get_tns3__TransferParams(struct soap *soap, tns3__TransferParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns3__TransferParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns3__TransferParams * SOAP_FMAC2 soap_instantiate_tns3__TransferParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns3__TransferParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_tns3__TransferParams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferParams);
		if (size)
			*size = sizeof(tns3__TransferParams);
		((tns3__TransferParams*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns3__TransferParams[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns3__TransferParams);
		for (int i = 0; i < n; i++)
			((tns3__TransferParams*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns3__TransferParams*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns3__TransferParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns3__TransferParams %p -> %p\n", q, p));
	*(tns3__TransferParams*)p = *(tns3__TransferParams*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_log__GetLogInternal(struct soap *soap, struct log__GetLogInternal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_log__GetLogInternal(struct soap *soap, const struct log__GetLogInternal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->jobId, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__GetLogInternal(struct soap *soap, const char *tag, int id, const struct log__GetLogInternal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__GetLogInternal), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct log__GetLogInternal * SOAP_FMAC4 soap_in_log__GetLogInternal(struct soap *soap, const char *tag, struct log__GetLogInternal *a, const char *type)
{
	size_t soap_flag_jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct log__GetLogInternal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__GetLogInternal, sizeof(struct log__GetLogInternal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_log__GetLogInternal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jobId", &a->jobId, "xsd:string"))
				{	soap_flag_jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct log__GetLogInternal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__GetLogInternal, 0, sizeof(struct log__GetLogInternal), 0, soap_copy_log__GetLogInternal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_log__GetLogInternal(struct soap *soap, const struct log__GetLogInternal *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_log__GetLogInternal);
	if (soap_out_log__GetLogInternal(soap, tag?tag:"log:GetLogInternal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct log__GetLogInternal * SOAP_FMAC4 soap_get_log__GetLogInternal(struct soap *soap, struct log__GetLogInternal *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__GetLogInternal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct log__GetLogInternal * SOAP_FMAC2 soap_instantiate_log__GetLogInternal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__GetLogInternal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__GetLogInternal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogInternal);
		if (size)
			*size = sizeof(struct log__GetLogInternal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogInternal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct log__GetLogInternal);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct log__GetLogInternal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__GetLogInternal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct log__GetLogInternal %p -> %p\n", q, p));
	*(struct log__GetLogInternal*)p = *(struct log__GetLogInternal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_log__GetLogInternalResponse(struct soap *soap, struct log__GetLogInternalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->logs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_log__GetLogInternalResponse(struct soap *soap, const struct log__GetLogInternalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolog__LogInternal(soap, &a->logs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__GetLogInternalResponse(struct soap *soap, const char *tag, int id, const struct log__GetLogInternalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__GetLogInternalResponse), type))
		return soap->error;
	if (soap_out_PointerTolog__LogInternal(soap, "logs", -1, &a->logs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct log__GetLogInternalResponse * SOAP_FMAC4 soap_in_log__GetLogInternalResponse(struct soap *soap, const char *tag, struct log__GetLogInternalResponse *a, const char *type)
{
	size_t soap_flag_logs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct log__GetLogInternalResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__GetLogInternalResponse, sizeof(struct log__GetLogInternalResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_log__GetLogInternalResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolog__LogInternal(soap, "logs", &a->logs, "log:LogInternal"))
				{	soap_flag_logs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct log__GetLogInternalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__GetLogInternalResponse, 0, sizeof(struct log__GetLogInternalResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_log__GetLogInternalResponse(struct soap *soap, const struct log__GetLogInternalResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_log__GetLogInternalResponse);
	if (soap_out_log__GetLogInternalResponse(soap, tag?tag:"log:GetLogInternalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct log__GetLogInternalResponse * SOAP_FMAC4 soap_get_log__GetLogInternalResponse(struct soap *soap, struct log__GetLogInternalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__GetLogInternalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct log__GetLogInternalResponse * SOAP_FMAC2 soap_instantiate_log__GetLogInternalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__GetLogInternalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__GetLogInternalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogInternalResponse);
		if (size)
			*size = sizeof(struct log__GetLogInternalResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogInternalResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct log__GetLogInternalResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct log__GetLogInternalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__GetLogInternalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct log__GetLogInternalResponse %p -> %p\n", q, p));
	*(struct log__GetLogInternalResponse*)p = *(struct log__GetLogInternalResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_log__GetLog(struct soap *soap, struct log__GetLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_log__GetLog(struct soap *soap, const struct log__GetLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->jobId, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__GetLog(struct soap *soap, const char *tag, int id, const struct log__GetLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__GetLog), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct log__GetLog * SOAP_FMAC4 soap_in_log__GetLog(struct soap *soap, const char *tag, struct log__GetLog *a, const char *type)
{
	size_t soap_flag_jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct log__GetLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__GetLog, sizeof(struct log__GetLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_log__GetLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jobId", &a->jobId, "xsd:string"))
				{	soap_flag_jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct log__GetLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__GetLog, 0, sizeof(struct log__GetLog), 0, soap_copy_log__GetLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_log__GetLog(struct soap *soap, const struct log__GetLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_log__GetLog);
	if (soap_out_log__GetLog(soap, tag?tag:"log:GetLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct log__GetLog * SOAP_FMAC4 soap_get_log__GetLog(struct soap *soap, struct log__GetLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__GetLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct log__GetLog * SOAP_FMAC2 soap_instantiate_log__GetLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__GetLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__GetLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLog);
		if (size)
			*size = sizeof(struct log__GetLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLog[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct log__GetLog);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct log__GetLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__GetLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct log__GetLog %p -> %p\n", q, p));
	*(struct log__GetLog*)p = *(struct log__GetLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_log__GetLogResponse(struct soap *soap, struct log__GetLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->log = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_log__GetLogResponse(struct soap *soap, const struct log__GetLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolog__Log(soap, &a->log);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_log__GetLogResponse(struct soap *soap, const char *tag, int id, const struct log__GetLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_log__GetLogResponse), type))
		return soap->error;
	if (soap_out_PointerTolog__Log(soap, "log", -1, &a->log, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct log__GetLogResponse * SOAP_FMAC4 soap_in_log__GetLogResponse(struct soap *soap, const char *tag, struct log__GetLogResponse *a, const char *type)
{
	size_t soap_flag_log = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct log__GetLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_log__GetLogResponse, sizeof(struct log__GetLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_log__GetLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_log && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolog__Log(soap, "log", &a->log, "log:Log"))
				{	soap_flag_log--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct log__GetLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_log__GetLogResponse, 0, sizeof(struct log__GetLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_log__GetLogResponse(struct soap *soap, const struct log__GetLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_log__GetLogResponse);
	if (soap_out_log__GetLogResponse(soap, tag?tag:"log:GetLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct log__GetLogResponse * SOAP_FMAC4 soap_get_log__GetLogResponse(struct soap *soap, struct log__GetLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_log__GetLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct log__GetLogResponse * SOAP_FMAC2 soap_instantiate_log__GetLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_log__GetLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_log__GetLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogResponse);
		if (size)
			*size = sizeof(struct log__GetLogResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct log__GetLogResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct log__GetLogResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct log__GetLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_log__GetLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct log__GetLogResponse %p -> %p\n", q, p));
	*(struct log__GetLogResponse*)p = *(struct log__GetLogResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getServiceMetadata(struct soap *soap, struct impltns__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getServiceMetadata(struct soap *soap, const struct impltns__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_key, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getServiceMetadata(struct soap *soap, const char *tag, int id, const struct impltns__getServiceMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getServiceMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getServiceMetadata * SOAP_FMAC4 soap_in_impltns__getServiceMetadata(struct soap *soap, const char *tag, struct impltns__getServiceMetadata *a, const char *type)
{
	size_t soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getServiceMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getServiceMetadata, sizeof(struct impltns__getServiceMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getServiceMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getServiceMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getServiceMetadata, 0, sizeof(struct impltns__getServiceMetadata), 0, soap_copy_impltns__getServiceMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getServiceMetadata(struct soap *soap, const struct impltns__getServiceMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getServiceMetadata);
	if (soap_out_impltns__getServiceMetadata(soap, tag?tag:"impltns:getServiceMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getServiceMetadata * SOAP_FMAC4 soap_get_impltns__getServiceMetadata(struct soap *soap, struct impltns__getServiceMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getServiceMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getServiceMetadata * SOAP_FMAC2 soap_instantiate_impltns__getServiceMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getServiceMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getServiceMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getServiceMetadata);
		if (size)
			*size = sizeof(struct impltns__getServiceMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getServiceMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getServiceMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getServiceMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getServiceMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getServiceMetadata %p -> %p\n", q, p));
	*(struct impltns__getServiceMetadata*)p = *(struct impltns__getServiceMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getServiceMetadataResponse(struct soap *soap, struct impltns__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getServiceMetadataResponse(struct soap *soap, const struct impltns__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getServiceMetadataReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getServiceMetadataResponse(struct soap *soap, const char *tag, int id, const struct impltns__getServiceMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getServiceMetadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getServiceMetadataReturn", -1, &a->_getServiceMetadataReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getServiceMetadataResponse * SOAP_FMAC4 soap_in_impltns__getServiceMetadataResponse(struct soap *soap, const char *tag, struct impltns__getServiceMetadataResponse *a, const char *type)
{
	size_t soap_flag__getServiceMetadataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getServiceMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getServiceMetadataResponse, sizeof(struct impltns__getServiceMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getServiceMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getServiceMetadataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getServiceMetadataReturn, "xsd:string"))
				{	soap_flag__getServiceMetadataReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getServiceMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getServiceMetadataResponse, 0, sizeof(struct impltns__getServiceMetadataResponse), 0, soap_copy_impltns__getServiceMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getServiceMetadataReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getServiceMetadataResponse(struct soap *soap, const struct impltns__getServiceMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getServiceMetadataResponse);
	if (soap_out_impltns__getServiceMetadataResponse(soap, tag?tag:"impltns:getServiceMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getServiceMetadataResponse * SOAP_FMAC4 soap_get_impltns__getServiceMetadataResponse(struct soap *soap, struct impltns__getServiceMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getServiceMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getServiceMetadataResponse * SOAP_FMAC2 soap_instantiate_impltns__getServiceMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getServiceMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getServiceMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getServiceMetadataResponse);
		if (size)
			*size = sizeof(struct impltns__getServiceMetadataResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getServiceMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getServiceMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getServiceMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getServiceMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getServiceMetadataResponse %p -> %p\n", q, p));
	*(struct impltns__getServiceMetadataResponse*)p = *(struct impltns__getServiceMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getInterfaceVersion(struct soap *soap, struct impltns__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getInterfaceVersion(struct soap *soap, const struct impltns__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getInterfaceVersion(struct soap *soap, const char *tag, int id, const struct impltns__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getInterfaceVersion * SOAP_FMAC4 soap_in_impltns__getInterfaceVersion(struct soap *soap, const char *tag, struct impltns__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getInterfaceVersion, sizeof(struct impltns__getInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getInterfaceVersion, 0, sizeof(struct impltns__getInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getInterfaceVersion(struct soap *soap, const struct impltns__getInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getInterfaceVersion);
	if (soap_out_impltns__getInterfaceVersion(soap, tag?tag:"impltns:getInterfaceVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getInterfaceVersion * SOAP_FMAC4 soap_get_impltns__getInterfaceVersion(struct soap *soap, struct impltns__getInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getInterfaceVersion * SOAP_FMAC2 soap_instantiate_impltns__getInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getInterfaceVersion);
		if (size)
			*size = sizeof(struct impltns__getInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getInterfaceVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getInterfaceVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getInterfaceVersion %p -> %p\n", q, p));
	*(struct impltns__getInterfaceVersion*)p = *(struct impltns__getInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getInterfaceVersionResponse(struct soap *soap, struct impltns__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getInterfaceVersionResponse(struct soap *soap, const struct impltns__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getInterfaceVersionReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct impltns__getInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getInterfaceVersionReturn", -1, &a->getInterfaceVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getInterfaceVersionResponse * SOAP_FMAC4 soap_in_impltns__getInterfaceVersionResponse(struct soap *soap, const char *tag, struct impltns__getInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_getInterfaceVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getInterfaceVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse, sizeof(struct impltns__getInterfaceVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInterfaceVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getInterfaceVersionReturn", &a->getInterfaceVersionReturn, "xsd:string"))
				{	soap_flag_getInterfaceVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse, 0, sizeof(struct impltns__getInterfaceVersionResponse), 0, soap_copy_impltns__getInterfaceVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getInterfaceVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getInterfaceVersionResponse(struct soap *soap, const struct impltns__getInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse);
	if (soap_out_impltns__getInterfaceVersionResponse(soap, tag?tag:"impltns:getInterfaceVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getInterfaceVersionResponse * SOAP_FMAC4 soap_get_impltns__getInterfaceVersionResponse(struct soap *soap, struct impltns__getInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getInterfaceVersionResponse * SOAP_FMAC2 soap_instantiate_impltns__getInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getInterfaceVersionResponse);
		if (size)
			*size = sizeof(struct impltns__getInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getInterfaceVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getInterfaceVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct impltns__getInterfaceVersionResponse*)p = *(struct impltns__getInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getSchemaVersion(struct soap *soap, struct impltns__getSchemaVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getSchemaVersion(struct soap *soap, const struct impltns__getSchemaVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getSchemaVersion(struct soap *soap, const char *tag, int id, const struct impltns__getSchemaVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getSchemaVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getSchemaVersion * SOAP_FMAC4 soap_in_impltns__getSchemaVersion(struct soap *soap, const char *tag, struct impltns__getSchemaVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getSchemaVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getSchemaVersion, sizeof(struct impltns__getSchemaVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getSchemaVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getSchemaVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getSchemaVersion, 0, sizeof(struct impltns__getSchemaVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getSchemaVersion(struct soap *soap, const struct impltns__getSchemaVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getSchemaVersion);
	if (soap_out_impltns__getSchemaVersion(soap, tag?tag:"impltns:getSchemaVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getSchemaVersion * SOAP_FMAC4 soap_get_impltns__getSchemaVersion(struct soap *soap, struct impltns__getSchemaVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getSchemaVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getSchemaVersion * SOAP_FMAC2 soap_instantiate_impltns__getSchemaVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getSchemaVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getSchemaVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getSchemaVersion);
		if (size)
			*size = sizeof(struct impltns__getSchemaVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getSchemaVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getSchemaVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getSchemaVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getSchemaVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getSchemaVersion %p -> %p\n", q, p));
	*(struct impltns__getSchemaVersion*)p = *(struct impltns__getSchemaVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getSchemaVersionResponse(struct soap *soap, struct impltns__getSchemaVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getSchemaVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getSchemaVersionResponse(struct soap *soap, const struct impltns__getSchemaVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getSchemaVersionReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->getSchemaVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getSchemaVersionResponse(struct soap *soap, const char *tag, int id, const struct impltns__getSchemaVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getSchemaVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getSchemaVersionReturn", -1, &a->getSchemaVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getSchemaVersionResponse * SOAP_FMAC4 soap_in_impltns__getSchemaVersionResponse(struct soap *soap, const char *tag, struct impltns__getSchemaVersionResponse *a, const char *type)
{
	size_t soap_flag_getSchemaVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getSchemaVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getSchemaVersionResponse, sizeof(struct impltns__getSchemaVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getSchemaVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getSchemaVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getSchemaVersionReturn", &a->getSchemaVersionReturn, "xsd:string"))
				{	soap_flag_getSchemaVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getSchemaVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getSchemaVersionResponse, 0, sizeof(struct impltns__getSchemaVersionResponse), 0, soap_copy_impltns__getSchemaVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getSchemaVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getSchemaVersionResponse(struct soap *soap, const struct impltns__getSchemaVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getSchemaVersionResponse);
	if (soap_out_impltns__getSchemaVersionResponse(soap, tag?tag:"impltns:getSchemaVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getSchemaVersionResponse * SOAP_FMAC4 soap_get_impltns__getSchemaVersionResponse(struct soap *soap, struct impltns__getSchemaVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getSchemaVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getSchemaVersionResponse * SOAP_FMAC2 soap_instantiate_impltns__getSchemaVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getSchemaVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getSchemaVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getSchemaVersionResponse);
		if (size)
			*size = sizeof(struct impltns__getSchemaVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getSchemaVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getSchemaVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getSchemaVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getSchemaVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getSchemaVersionResponse %p -> %p\n", q, p));
	*(struct impltns__getSchemaVersionResponse*)p = *(struct impltns__getSchemaVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getVersion(struct soap *soap, struct impltns__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getVersion(struct soap *soap, const struct impltns__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getVersion(struct soap *soap, const char *tag, int id, const struct impltns__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getVersion * SOAP_FMAC4 soap_in_impltns__getVersion(struct soap *soap, const char *tag, struct impltns__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getVersion, sizeof(struct impltns__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getVersion, 0, sizeof(struct impltns__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getVersion(struct soap *soap, const struct impltns__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getVersion);
	if (soap_out_impltns__getVersion(soap, tag?tag:"impltns:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getVersion * SOAP_FMAC4 soap_get_impltns__getVersion(struct soap *soap, struct impltns__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getVersion * SOAP_FMAC2 soap_instantiate_impltns__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getVersion);
		if (size)
			*size = sizeof(struct impltns__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getVersion %p -> %p\n", q, p));
	*(struct impltns__getVersion*)p = *(struct impltns__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getVersionResponse(struct soap *soap, struct impltns__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getVersionResponse(struct soap *soap, const struct impltns__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getVersionReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getVersionResponse(struct soap *soap, const char *tag, int id, const struct impltns__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getVersionReturn", -1, &a->getVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getVersionResponse * SOAP_FMAC4 soap_in_impltns__getVersionResponse(struct soap *soap, const char *tag, struct impltns__getVersionResponse *a, const char *type)
{
	size_t soap_flag_getVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getVersionResponse, sizeof(struct impltns__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getVersionReturn", &a->getVersionReturn, "xsd:string"))
				{	soap_flag_getVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getVersionResponse, 0, sizeof(struct impltns__getVersionResponse), 0, soap_copy_impltns__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getVersionResponse(struct soap *soap, const struct impltns__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getVersionResponse);
	if (soap_out_impltns__getVersionResponse(soap, tag?tag:"impltns:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getVersionResponse * SOAP_FMAC4 soap_get_impltns__getVersionResponse(struct soap *soap, struct impltns__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getVersionResponse * SOAP_FMAC2 soap_instantiate_impltns__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getVersionResponse);
		if (size)
			*size = sizeof(struct impltns__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getVersionResponse %p -> %p\n", q, p));
	*(struct impltns__getVersionResponse*)p = *(struct impltns__getVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getRolesOf(struct soap *soap, struct impltns__getRolesOf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_otherDN);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getRolesOf(struct soap *soap, const struct impltns__getRolesOf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_otherDN, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_otherDN);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getRolesOf(struct soap *soap, const char *tag, int id, const struct impltns__getRolesOf *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getRolesOf), type))
		return soap->error;
	if (soap_out_std__string(soap, "otherDN", -1, &a->_otherDN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getRolesOf * SOAP_FMAC4 soap_in_impltns__getRolesOf(struct soap *soap, const char *tag, struct impltns__getRolesOf *a, const char *type)
{
	size_t soap_flag__otherDN = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getRolesOf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getRolesOf, sizeof(struct impltns__getRolesOf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getRolesOf(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__otherDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_otherDN, "xsd:string"))
				{	soap_flag__otherDN--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getRolesOf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getRolesOf, 0, sizeof(struct impltns__getRolesOf), 0, soap_copy_impltns__getRolesOf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__otherDN > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getRolesOf(struct soap *soap, const struct impltns__getRolesOf *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getRolesOf);
	if (soap_out_impltns__getRolesOf(soap, tag?tag:"impltns:getRolesOf", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getRolesOf * SOAP_FMAC4 soap_get_impltns__getRolesOf(struct soap *soap, struct impltns__getRolesOf *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getRolesOf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getRolesOf * SOAP_FMAC2 soap_instantiate_impltns__getRolesOf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getRolesOf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getRolesOf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesOf);
		if (size)
			*size = sizeof(struct impltns__getRolesOf);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesOf[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getRolesOf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getRolesOf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getRolesOf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getRolesOf %p -> %p\n", q, p));
	*(struct impltns__getRolesOf*)p = *(struct impltns__getRolesOf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getRolesOfResponse(struct soap *soap, struct impltns__getRolesOfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getRolesOfReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getRolesOfResponse(struct soap *soap, const struct impltns__getRolesOfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__Roles(soap, &a->_getRolesOfReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getRolesOfResponse(struct soap *soap, const char *tag, int id, const struct impltns__getRolesOfResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getRolesOfResponse), type))
		return soap->error;
	if (soap_out_PointerTotns3__Roles(soap, "getRolesOfReturn", -1, &a->_getRolesOfReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getRolesOfResponse * SOAP_FMAC4 soap_in_impltns__getRolesOfResponse(struct soap *soap, const char *tag, struct impltns__getRolesOfResponse *a, const char *type)
{
	size_t soap_flag__getRolesOfReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getRolesOfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getRolesOfResponse, sizeof(struct impltns__getRolesOfResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getRolesOfResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getRolesOfReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__Roles(soap, NULL, &a->_getRolesOfReturn, "tns3:Roles"))
				{	soap_flag__getRolesOfReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getRolesOfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getRolesOfResponse, 0, sizeof(struct impltns__getRolesOfResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getRolesOfResponse(struct soap *soap, const struct impltns__getRolesOfResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getRolesOfResponse);
	if (soap_out_impltns__getRolesOfResponse(soap, tag?tag:"impltns:getRolesOfResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getRolesOfResponse * SOAP_FMAC4 soap_get_impltns__getRolesOfResponse(struct soap *soap, struct impltns__getRolesOfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getRolesOfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getRolesOfResponse * SOAP_FMAC2 soap_instantiate_impltns__getRolesOfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getRolesOfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getRolesOfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesOfResponse);
		if (size)
			*size = sizeof(struct impltns__getRolesOfResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesOfResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getRolesOfResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getRolesOfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getRolesOfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getRolesOfResponse %p -> %p\n", q, p));
	*(struct impltns__getRolesOfResponse*)p = *(struct impltns__getRolesOfResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getRoles(struct soap *soap, struct impltns__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getRoles(struct soap *soap, const struct impltns__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getRoles(struct soap *soap, const char *tag, int id, const struct impltns__getRoles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getRoles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getRoles * SOAP_FMAC4 soap_in_impltns__getRoles(struct soap *soap, const char *tag, struct impltns__getRoles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getRoles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getRoles, sizeof(struct impltns__getRoles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getRoles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getRoles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getRoles, 0, sizeof(struct impltns__getRoles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getRoles(struct soap *soap, const struct impltns__getRoles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getRoles);
	if (soap_out_impltns__getRoles(soap, tag?tag:"impltns:getRoles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getRoles * SOAP_FMAC4 soap_get_impltns__getRoles(struct soap *soap, struct impltns__getRoles *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getRoles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getRoles * SOAP_FMAC2 soap_instantiate_impltns__getRoles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getRoles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getRoles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRoles);
		if (size)
			*size = sizeof(struct impltns__getRoles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRoles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getRoles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getRoles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getRoles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getRoles %p -> %p\n", q, p));
	*(struct impltns__getRoles*)p = *(struct impltns__getRoles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getRolesResponse(struct soap *soap, struct impltns__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getRolesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getRolesResponse(struct soap *soap, const struct impltns__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__Roles(soap, &a->getRolesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getRolesResponse(struct soap *soap, const char *tag, int id, const struct impltns__getRolesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getRolesResponse), type))
		return soap->error;
	if (soap_out_PointerTotns3__Roles(soap, "getRolesReturn", -1, &a->getRolesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getRolesResponse * SOAP_FMAC4 soap_in_impltns__getRolesResponse(struct soap *soap, const char *tag, struct impltns__getRolesResponse *a, const char *type)
{
	size_t soap_flag_getRolesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getRolesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getRolesResponse, sizeof(struct impltns__getRolesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getRolesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getRolesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__Roles(soap, "getRolesReturn", &a->getRolesReturn, "tns3:Roles"))
				{	soap_flag_getRolesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getRolesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getRolesResponse, 0, sizeof(struct impltns__getRolesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getRolesResponse(struct soap *soap, const struct impltns__getRolesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getRolesResponse);
	if (soap_out_impltns__getRolesResponse(soap, tag?tag:"impltns:getRolesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getRolesResponse * SOAP_FMAC4 soap_get_impltns__getRolesResponse(struct soap *soap, struct impltns__getRolesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getRolesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getRolesResponse * SOAP_FMAC2 soap_instantiate_impltns__getRolesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getRolesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getRolesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesResponse);
		if (size)
			*size = sizeof(struct impltns__getRolesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getRolesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getRolesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getRolesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getRolesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getRolesResponse %p -> %p\n", q, p));
	*(struct impltns__getRolesResponse*)p = *(struct impltns__getRolesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listVOManagers(struct soap *soap, struct impltns__listVOManagers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listVOManagers(struct soap *soap, const struct impltns__listVOManagers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listVOManagers(struct soap *soap, const char *tag, int id, const struct impltns__listVOManagers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listVOManagers), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listVOManagers * SOAP_FMAC4 soap_in_impltns__listVOManagers(struct soap *soap, const char *tag, struct impltns__listVOManagers *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listVOManagers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listVOManagers, sizeof(struct impltns__listVOManagers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__listVOManagers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listVOManagers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listVOManagers, 0, sizeof(struct impltns__listVOManagers), 0, soap_copy_impltns__listVOManagers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listVOManagers(struct soap *soap, const struct impltns__listVOManagers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listVOManagers);
	if (soap_out_impltns__listVOManagers(soap, tag?tag:"impltns:listVOManagers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listVOManagers * SOAP_FMAC4 soap_get_impltns__listVOManagers(struct soap *soap, struct impltns__listVOManagers *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listVOManagers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listVOManagers * SOAP_FMAC2 soap_instantiate_impltns__listVOManagers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listVOManagers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listVOManagers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listVOManagers);
		if (size)
			*size = sizeof(struct impltns__listVOManagers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listVOManagers[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listVOManagers);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listVOManagers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listVOManagers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listVOManagers %p -> %p\n", q, p));
	*(struct impltns__listVOManagers*)p = *(struct impltns__listVOManagers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listVOManagersResponse(struct soap *soap, struct impltns__listVOManagersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listVOManagersReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listVOManagersResponse(struct soap *soap, const struct impltns__listVOManagersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_listVOManagersReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listVOManagersResponse(struct soap *soap, const char *tag, int id, const struct impltns__listVOManagersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listVOManagersResponse), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, "listVOManagersReturn", -1, &a->_listVOManagersReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listVOManagersResponse * SOAP_FMAC4 soap_in_impltns__listVOManagersResponse(struct soap *soap, const char *tag, struct impltns__listVOManagersResponse *a, const char *type)
{
	size_t soap_flag__listVOManagersReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listVOManagersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listVOManagersResponse, sizeof(struct impltns__listVOManagersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__listVOManagersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listVOManagersReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_listVOManagersReturn, "impltns:ArrayOf_soapenc_string"))
				{	soap_flag__listVOManagersReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listVOManagersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listVOManagersResponse, 0, sizeof(struct impltns__listVOManagersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listVOManagersResponse(struct soap *soap, const struct impltns__listVOManagersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listVOManagersResponse);
	if (soap_out_impltns__listVOManagersResponse(soap, tag?tag:"impltns:listVOManagersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listVOManagersResponse * SOAP_FMAC4 soap_get_impltns__listVOManagersResponse(struct soap *soap, struct impltns__listVOManagersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listVOManagersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listVOManagersResponse * SOAP_FMAC2 soap_instantiate_impltns__listVOManagersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listVOManagersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listVOManagersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listVOManagersResponse);
		if (size)
			*size = sizeof(struct impltns__listVOManagersResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listVOManagersResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listVOManagersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listVOManagersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listVOManagersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listVOManagersResponse %p -> %p\n", q, p));
	*(struct impltns__listVOManagersResponse*)p = *(struct impltns__listVOManagersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__removeVOManager(struct soap *soap, struct impltns__removeVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
	soap_default_std__string(soap, &a->_principal);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__removeVOManager(struct soap *soap, const struct impltns__removeVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
	soap_embedded(soap, &a->_principal, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_principal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__removeVOManager(struct soap *soap, const char *tag, int id, const struct impltns__removeVOManager *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__removeVOManager), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "principal", -1, &a->_principal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__removeVOManager * SOAP_FMAC4 soap_in_impltns__removeVOManager(struct soap *soap, const char *tag, struct impltns__removeVOManager *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	size_t soap_flag__principal = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__removeVOManager *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__removeVOManager, sizeof(struct impltns__removeVOManager), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__removeVOManager(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap_flag__principal && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_principal, "xsd:string"))
				{	soap_flag__principal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__removeVOManager *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__removeVOManager, 0, sizeof(struct impltns__removeVOManager), 0, soap_copy_impltns__removeVOManager);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0 || soap_flag__principal > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__removeVOManager(struct soap *soap, const struct impltns__removeVOManager *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__removeVOManager);
	if (soap_out_impltns__removeVOManager(soap, tag?tag:"impltns:removeVOManager", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__removeVOManager * SOAP_FMAC4 soap_get_impltns__removeVOManager(struct soap *soap, struct impltns__removeVOManager *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__removeVOManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__removeVOManager * SOAP_FMAC2 soap_instantiate_impltns__removeVOManager(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__removeVOManager(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__removeVOManager, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__removeVOManager);
		if (size)
			*size = sizeof(struct impltns__removeVOManager);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__removeVOManager[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__removeVOManager);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__removeVOManager*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__removeVOManager(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__removeVOManager %p -> %p\n", q, p));
	*(struct impltns__removeVOManager*)p = *(struct impltns__removeVOManager*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__removeVOManagerResponse(struct soap *soap, struct impltns__removeVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__removeVOManagerResponse(struct soap *soap, const struct impltns__removeVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__removeVOManagerResponse(struct soap *soap, const char *tag, int id, const struct impltns__removeVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__removeVOManagerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__removeVOManagerResponse * SOAP_FMAC4 soap_in_impltns__removeVOManagerResponse(struct soap *soap, const char *tag, struct impltns__removeVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__removeVOManagerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__removeVOManagerResponse, sizeof(struct impltns__removeVOManagerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__removeVOManagerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__removeVOManagerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__removeVOManagerResponse, 0, sizeof(struct impltns__removeVOManagerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__removeVOManagerResponse(struct soap *soap, const struct impltns__removeVOManagerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__removeVOManagerResponse);
	if (soap_out_impltns__removeVOManagerResponse(soap, tag?tag:"impltns:removeVOManagerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__removeVOManagerResponse * SOAP_FMAC4 soap_get_impltns__removeVOManagerResponse(struct soap *soap, struct impltns__removeVOManagerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__removeVOManagerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__removeVOManagerResponse * SOAP_FMAC2 soap_instantiate_impltns__removeVOManagerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__removeVOManagerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__removeVOManagerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__removeVOManagerResponse);
		if (size)
			*size = sizeof(struct impltns__removeVOManagerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__removeVOManagerResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__removeVOManagerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__removeVOManagerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__removeVOManagerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__removeVOManagerResponse %p -> %p\n", q, p));
	*(struct impltns__removeVOManagerResponse*)p = *(struct impltns__removeVOManagerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__addVOManager(struct soap *soap, struct impltns__addVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_VOName);
	soap_default_std__string(soap, &a->_principal);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__addVOManager(struct soap *soap, const struct impltns__addVOManager *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_VOName, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_VOName);
	soap_embedded(soap, &a->_principal, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_principal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__addVOManager(struct soap *soap, const char *tag, int id, const struct impltns__addVOManager *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__addVOManager), type))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &a->_VOName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "principal", -1, &a->_principal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__addVOManager * SOAP_FMAC4 soap_in_impltns__addVOManager(struct soap *soap, const char *tag, struct impltns__addVOManager *a, const char *type)
{
	size_t soap_flag__VOName = 1;
	size_t soap_flag__principal = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__addVOManager *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__addVOManager, sizeof(struct impltns__addVOManager), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__addVOManager(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__VOName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_VOName, "xsd:string"))
				{	soap_flag__VOName--;
					continue;
				}
			if (soap_flag__principal && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_principal, "xsd:string"))
				{	soap_flag__principal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__addVOManager *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__addVOManager, 0, sizeof(struct impltns__addVOManager), 0, soap_copy_impltns__addVOManager);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__VOName > 0 || soap_flag__principal > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__addVOManager(struct soap *soap, const struct impltns__addVOManager *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__addVOManager);
	if (soap_out_impltns__addVOManager(soap, tag?tag:"impltns:addVOManager", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__addVOManager * SOAP_FMAC4 soap_get_impltns__addVOManager(struct soap *soap, struct impltns__addVOManager *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__addVOManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__addVOManager * SOAP_FMAC2 soap_instantiate_impltns__addVOManager(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__addVOManager(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__addVOManager, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__addVOManager);
		if (size)
			*size = sizeof(struct impltns__addVOManager);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__addVOManager[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__addVOManager);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__addVOManager*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__addVOManager(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__addVOManager %p -> %p\n", q, p));
	*(struct impltns__addVOManager*)p = *(struct impltns__addVOManager*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__addVOManagerResponse(struct soap *soap, struct impltns__addVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__addVOManagerResponse(struct soap *soap, const struct impltns__addVOManagerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__addVOManagerResponse(struct soap *soap, const char *tag, int id, const struct impltns__addVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__addVOManagerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__addVOManagerResponse * SOAP_FMAC4 soap_in_impltns__addVOManagerResponse(struct soap *soap, const char *tag, struct impltns__addVOManagerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__addVOManagerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__addVOManagerResponse, sizeof(struct impltns__addVOManagerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__addVOManagerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__addVOManagerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__addVOManagerResponse, 0, sizeof(struct impltns__addVOManagerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__addVOManagerResponse(struct soap *soap, const struct impltns__addVOManagerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__addVOManagerResponse);
	if (soap_out_impltns__addVOManagerResponse(soap, tag?tag:"impltns:addVOManagerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__addVOManagerResponse * SOAP_FMAC4 soap_get_impltns__addVOManagerResponse(struct soap *soap, struct impltns__addVOManagerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__addVOManagerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__addVOManagerResponse * SOAP_FMAC2 soap_instantiate_impltns__addVOManagerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__addVOManagerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__addVOManagerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__addVOManagerResponse);
		if (size)
			*size = sizeof(struct impltns__addVOManagerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__addVOManagerResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__addVOManagerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__addVOManagerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__addVOManagerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__addVOManagerResponse %p -> %p\n", q, p));
	*(struct impltns__addVOManagerResponse*)p = *(struct impltns__addVOManagerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__setJobPriority(struct soap *soap, struct impltns__setJobPriority *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_priority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__setJobPriority(struct soap *soap, const struct impltns__setJobPriority *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
	soap_embedded(soap, &a->_priority, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__setJobPriority(struct soap *soap, const char *tag, int id, const struct impltns__setJobPriority *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__setJobPriority), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &a->_priority, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__setJobPriority * SOAP_FMAC4 soap_in_impltns__setJobPriority(struct soap *soap, const char *tag, struct impltns__setJobPriority *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__priority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__setJobPriority *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__setJobPriority, sizeof(struct impltns__setJobPriority), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__setJobPriority(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_priority, "xsd:int"))
				{	soap_flag__priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__setJobPriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__setJobPriority, 0, sizeof(struct impltns__setJobPriority), 0, soap_copy_impltns__setJobPriority);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__priority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__setJobPriority(struct soap *soap, const struct impltns__setJobPriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__setJobPriority);
	if (soap_out_impltns__setJobPriority(soap, tag?tag:"impltns:setJobPriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__setJobPriority * SOAP_FMAC4 soap_get_impltns__setJobPriority(struct soap *soap, struct impltns__setJobPriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__setJobPriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__setJobPriority * SOAP_FMAC2 soap_instantiate_impltns__setJobPriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__setJobPriority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__setJobPriority, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__setJobPriority);
		if (size)
			*size = sizeof(struct impltns__setJobPriority);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__setJobPriority[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__setJobPriority);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__setJobPriority*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__setJobPriority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__setJobPriority %p -> %p\n", q, p));
	*(struct impltns__setJobPriority*)p = *(struct impltns__setJobPriority*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__setJobPriorityResponse(struct soap *soap, struct impltns__setJobPriorityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__setJobPriorityResponse(struct soap *soap, const struct impltns__setJobPriorityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__setJobPriorityResponse(struct soap *soap, const char *tag, int id, const struct impltns__setJobPriorityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__setJobPriorityResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__setJobPriorityResponse * SOAP_FMAC4 soap_in_impltns__setJobPriorityResponse(struct soap *soap, const char *tag, struct impltns__setJobPriorityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__setJobPriorityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__setJobPriorityResponse, sizeof(struct impltns__setJobPriorityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__setJobPriorityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__setJobPriorityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__setJobPriorityResponse, 0, sizeof(struct impltns__setJobPriorityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__setJobPriorityResponse(struct soap *soap, const struct impltns__setJobPriorityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__setJobPriorityResponse);
	if (soap_out_impltns__setJobPriorityResponse(soap, tag?tag:"impltns:setJobPriorityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__setJobPriorityResponse * SOAP_FMAC4 soap_get_impltns__setJobPriorityResponse(struct soap *soap, struct impltns__setJobPriorityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__setJobPriorityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__setJobPriorityResponse * SOAP_FMAC2 soap_instantiate_impltns__setJobPriorityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__setJobPriorityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__setJobPriorityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__setJobPriorityResponse);
		if (size)
			*size = sizeof(struct impltns__setJobPriorityResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__setJobPriorityResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__setJobPriorityResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__setJobPriorityResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__setJobPriorityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__setJobPriorityResponse %p -> %p\n", q, p));
	*(struct impltns__setJobPriorityResponse*)p = *(struct impltns__setJobPriorityResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__cancel(struct soap *soap, struct impltns__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_requestIDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__cancel(struct soap *soap, const struct impltns__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_requestIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__cancel(struct soap *soap, const char *tag, int id, const struct impltns__cancel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__cancel), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, "requestIDs", -1, &a->_requestIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__cancel * SOAP_FMAC4 soap_in_impltns__cancel(struct soap *soap, const char *tag, struct impltns__cancel *a, const char *type)
{
	size_t soap_flag__requestIDs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__cancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__cancel, sizeof(struct impltns__cancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__cancel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestIDs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_requestIDs, "impltns:ArrayOf_soapenc_string"))
				{	soap_flag__requestIDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__cancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__cancel, 0, sizeof(struct impltns__cancel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__cancel(struct soap *soap, const struct impltns__cancel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__cancel);
	if (soap_out_impltns__cancel(soap, tag?tag:"impltns:cancel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__cancel * SOAP_FMAC4 soap_get_impltns__cancel(struct soap *soap, struct impltns__cancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__cancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__cancel * SOAP_FMAC2 soap_instantiate_impltns__cancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__cancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__cancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__cancel);
		if (size)
			*size = sizeof(struct impltns__cancel);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__cancel[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__cancel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__cancel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__cancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__cancel %p -> %p\n", q, p));
	*(struct impltns__cancel*)p = *(struct impltns__cancel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__cancelResponse(struct soap *soap, struct impltns__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__cancelResponse(struct soap *soap, const struct impltns__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__cancelResponse(struct soap *soap, const char *tag, int id, const struct impltns__cancelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__cancelResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__cancelResponse * SOAP_FMAC4 soap_in_impltns__cancelResponse(struct soap *soap, const char *tag, struct impltns__cancelResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__cancelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__cancelResponse, sizeof(struct impltns__cancelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__cancelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__cancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__cancelResponse, 0, sizeof(struct impltns__cancelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__cancelResponse(struct soap *soap, const struct impltns__cancelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__cancelResponse);
	if (soap_out_impltns__cancelResponse(soap, tag?tag:"impltns:cancelResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__cancelResponse * SOAP_FMAC4 soap_get_impltns__cancelResponse(struct soap *soap, struct impltns__cancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__cancelResponse * SOAP_FMAC2 soap_instantiate_impltns__cancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__cancelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__cancelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__cancelResponse);
		if (size)
			*size = sizeof(struct impltns__cancelResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__cancelResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__cancelResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__cancelResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__cancelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__cancelResponse %p -> %p\n", q, p));
	*(struct impltns__cancelResponse*)p = *(struct impltns__cancelResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobSummary2(struct soap *soap, struct impltns__getTransferJobSummary2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobSummary2(struct soap *soap, const struct impltns__getTransferJobSummary2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobSummary2(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobSummary2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary2), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary2 * SOAP_FMAC4 soap_in_impltns__getTransferJobSummary2(struct soap *soap, const char *tag, struct impltns__getTransferJobSummary2 *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobSummary2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary2, sizeof(struct impltns__getTransferJobSummary2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobSummary2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobSummary2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobSummary2, 0, sizeof(struct impltns__getTransferJobSummary2), 0, soap_copy_impltns__getTransferJobSummary2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobSummary2(struct soap *soap, const struct impltns__getTransferJobSummary2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobSummary2);
	if (soap_out_impltns__getTransferJobSummary2(soap, tag?tag:"impltns:getTransferJobSummary2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary2 * SOAP_FMAC4 soap_get_impltns__getTransferJobSummary2(struct soap *soap, struct impltns__getTransferJobSummary2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobSummary2 * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobSummary2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobSummary2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobSummary2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary2);
		if (size)
			*size = sizeof(struct impltns__getTransferJobSummary2);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobSummary2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobSummary2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobSummary2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobSummary2 %p -> %p\n", q, p));
	*(struct impltns__getTransferJobSummary2*)p = *(struct impltns__getTransferJobSummary2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobSummary2Response(struct soap *soap, struct impltns__getTransferJobSummary2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobSummary2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobSummary2Response(struct soap *soap, const struct impltns__getTransferJobSummary2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJobSummary2(soap, &a->_getTransferJobSummary2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobSummary2Response(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobSummary2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJobSummary2(soap, "getTransferJobSummary2Return", -1, &a->_getTransferJobSummary2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary2Response * SOAP_FMAC4 soap_in_impltns__getTransferJobSummary2Response(struct soap *soap, const char *tag, struct impltns__getTransferJobSummary2Response *a, const char *type)
{
	size_t soap_flag__getTransferJobSummary2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobSummary2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response, sizeof(struct impltns__getTransferJobSummary2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobSummary2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobSummary2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJobSummary2(soap, NULL, &a->_getTransferJobSummary2Return, "tns3:TransferJobSummary2"))
				{	soap_flag__getTransferJobSummary2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobSummary2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response, 0, sizeof(struct impltns__getTransferJobSummary2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobSummary2Response(struct soap *soap, const struct impltns__getTransferJobSummary2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response);
	if (soap_out_impltns__getTransferJobSummary2Response(soap, tag?tag:"impltns:getTransferJobSummary2Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary2Response * SOAP_FMAC4 soap_get_impltns__getTransferJobSummary2Response(struct soap *soap, struct impltns__getTransferJobSummary2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobSummary2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobSummary2Response * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobSummary2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobSummary2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobSummary2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary2Response);
		if (size)
			*size = sizeof(struct impltns__getTransferJobSummary2Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary2Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobSummary2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobSummary2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobSummary2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobSummary2Response %p -> %p\n", q, p));
	*(struct impltns__getTransferJobSummary2Response*)p = *(struct impltns__getTransferJobSummary2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobSummary(struct soap *soap, struct impltns__getTransferJobSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobSummary(struct soap *soap, const struct impltns__getTransferJobSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobSummary(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobSummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary * SOAP_FMAC4 soap_in_impltns__getTransferJobSummary(struct soap *soap, const char *tag, struct impltns__getTransferJobSummary *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobSummary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummary, sizeof(struct impltns__getTransferJobSummary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobSummary, 0, sizeof(struct impltns__getTransferJobSummary), 0, soap_copy_impltns__getTransferJobSummary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobSummary(struct soap *soap, const struct impltns__getTransferJobSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobSummary);
	if (soap_out_impltns__getTransferJobSummary(soap, tag?tag:"impltns:getTransferJobSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobSummary * SOAP_FMAC4 soap_get_impltns__getTransferJobSummary(struct soap *soap, struct impltns__getTransferJobSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobSummary * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobSummary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobSummary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobSummary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary);
		if (size)
			*size = sizeof(struct impltns__getTransferJobSummary);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobSummary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobSummary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobSummary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobSummary %p -> %p\n", q, p));
	*(struct impltns__getTransferJobSummary*)p = *(struct impltns__getTransferJobSummary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobSummaryResponse(struct soap *soap, struct impltns__getTransferJobSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobSummaryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobSummaryResponse(struct soap *soap, const struct impltns__getTransferJobSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJobSummary(soap, &a->_getTransferJobSummaryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobSummaryResponse(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobSummaryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJobSummary(soap, "getTransferJobSummaryReturn", -1, &a->_getTransferJobSummaryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobSummaryResponse * SOAP_FMAC4 soap_in_impltns__getTransferJobSummaryResponse(struct soap *soap, const char *tag, struct impltns__getTransferJobSummaryResponse *a, const char *type)
{
	size_t soap_flag__getTransferJobSummaryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse, sizeof(struct impltns__getTransferJobSummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobSummaryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJobSummary(soap, NULL, &a->_getTransferJobSummaryReturn, "tns3:TransferJobSummary"))
				{	soap_flag__getTransferJobSummaryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse, 0, sizeof(struct impltns__getTransferJobSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobSummaryResponse(struct soap *soap, const struct impltns__getTransferJobSummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse);
	if (soap_out_impltns__getTransferJobSummaryResponse(soap, tag?tag:"impltns:getTransferJobSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobSummaryResponse * SOAP_FMAC4 soap_get_impltns__getTransferJobSummaryResponse(struct soap *soap, struct impltns__getTransferJobSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobSummaryResponse * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobSummaryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobSummaryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobSummaryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummaryResponse);
		if (size)
			*size = sizeof(struct impltns__getTransferJobSummaryResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobSummaryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobSummaryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobSummaryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobSummaryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobSummaryResponse %p -> %p\n", q, p));
	*(struct impltns__getTransferJobSummaryResponse*)p = *(struct impltns__getTransferJobSummaryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobStatus(struct soap *soap, struct impltns__getTransferJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobStatus(struct soap *soap, const struct impltns__getTransferJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobStatus(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobStatus * SOAP_FMAC4 soap_in_impltns__getTransferJobStatus(struct soap *soap, const char *tag, struct impltns__getTransferJobStatus *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobStatus, sizeof(struct impltns__getTransferJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobStatus, 0, sizeof(struct impltns__getTransferJobStatus), 0, soap_copy_impltns__getTransferJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobStatus(struct soap *soap, const struct impltns__getTransferJobStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobStatus);
	if (soap_out_impltns__getTransferJobStatus(soap, tag?tag:"impltns:getTransferJobStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobStatus * SOAP_FMAC4 soap_get_impltns__getTransferJobStatus(struct soap *soap, struct impltns__getTransferJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobStatus * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobStatus);
		if (size)
			*size = sizeof(struct impltns__getTransferJobStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobStatus %p -> %p\n", q, p));
	*(struct impltns__getTransferJobStatus*)p = *(struct impltns__getTransferJobStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getTransferJobStatusResponse(struct soap *soap, struct impltns__getTransferJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTransferJobStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getTransferJobStatusResponse(struct soap *soap, const struct impltns__getTransferJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__JobStatus(soap, &a->_getTransferJobStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getTransferJobStatusResponse(struct soap *soap, const char *tag, int id, const struct impltns__getTransferJobStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTotns3__JobStatus(soap, "getTransferJobStatusReturn", -1, &a->_getTransferJobStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getTransferJobStatusResponse * SOAP_FMAC4 soap_in_impltns__getTransferJobStatusResponse(struct soap *soap, const char *tag, struct impltns__getTransferJobStatusResponse *a, const char *type)
{
	size_t soap_flag__getTransferJobStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getTransferJobStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse, sizeof(struct impltns__getTransferJobStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getTransferJobStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTransferJobStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__JobStatus(soap, NULL, &a->_getTransferJobStatusReturn, "tns3:JobStatus"))
				{	soap_flag__getTransferJobStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getTransferJobStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse, 0, sizeof(struct impltns__getTransferJobStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getTransferJobStatusResponse(struct soap *soap, const struct impltns__getTransferJobStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse);
	if (soap_out_impltns__getTransferJobStatusResponse(soap, tag?tag:"impltns:getTransferJobStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getTransferJobStatusResponse * SOAP_FMAC4 soap_get_impltns__getTransferJobStatusResponse(struct soap *soap, struct impltns__getTransferJobStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getTransferJobStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getTransferJobStatusResponse * SOAP_FMAC2 soap_instantiate_impltns__getTransferJobStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getTransferJobStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getTransferJobStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobStatusResponse);
		if (size)
			*size = sizeof(struct impltns__getTransferJobStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getTransferJobStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getTransferJobStatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getTransferJobStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getTransferJobStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getTransferJobStatusResponse %p -> %p\n", q, p));
	*(struct impltns__getTransferJobStatusResponse*)p = *(struct impltns__getTransferJobStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getFileStatus2(struct soap *soap, struct impltns__getFileStatus2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_offset);
	soap_default_int(soap, &a->_limit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getFileStatus2(struct soap *soap, const struct impltns__getFileStatus2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
	soap_embedded(soap, &a->_offset, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &a->_limit, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getFileStatus2(struct soap *soap, const char *tag, int id, const struct impltns__getFileStatus2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getFileStatus2), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->_offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->_limit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getFileStatus2 * SOAP_FMAC4 soap_in_impltns__getFileStatus2(struct soap *soap, const char *tag, struct impltns__getFileStatus2 *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__offset = 1;
	size_t soap_flag__limit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getFileStatus2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getFileStatus2, sizeof(struct impltns__getFileStatus2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getFileStatus2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_offset, "xsd:int"))
				{	soap_flag__offset--;
					continue;
				}
			if (soap_flag__limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_limit, "xsd:int"))
				{	soap_flag__limit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getFileStatus2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getFileStatus2, 0, sizeof(struct impltns__getFileStatus2), 0, soap_copy_impltns__getFileStatus2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__offset > 0 || soap_flag__limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getFileStatus2(struct soap *soap, const struct impltns__getFileStatus2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getFileStatus2);
	if (soap_out_impltns__getFileStatus2(soap, tag?tag:"impltns:getFileStatus2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getFileStatus2 * SOAP_FMAC4 soap_get_impltns__getFileStatus2(struct soap *soap, struct impltns__getFileStatus2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getFileStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getFileStatus2 * SOAP_FMAC2 soap_instantiate_impltns__getFileStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getFileStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getFileStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus2);
		if (size)
			*size = sizeof(struct impltns__getFileStatus2);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getFileStatus2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getFileStatus2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getFileStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getFileStatus2 %p -> %p\n", q, p));
	*(struct impltns__getFileStatus2*)p = *(struct impltns__getFileStatus2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getFileStatus2Response(struct soap *soap, struct impltns__getFileStatus2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getFileStatus2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getFileStatus2Response(struct soap *soap, const struct impltns__getFileStatus2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, &a->_getFileStatus2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getFileStatus2Response(struct soap *soap, const char *tag, int id, const struct impltns__getFileStatus2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getFileStatus2Response), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, "getFileStatus2Return", -1, &a->_getFileStatus2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getFileStatus2Response * SOAP_FMAC4 soap_in_impltns__getFileStatus2Response(struct soap *soap, const char *tag, struct impltns__getFileStatus2Response *a, const char *type)
{
	size_t soap_flag__getFileStatus2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getFileStatus2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getFileStatus2Response, sizeof(struct impltns__getFileStatus2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getFileStatus2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getFileStatus2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, NULL, &a->_getFileStatus2Return, "impltns:ArrayOf_tns3_FileTransferStatus2"))
				{	soap_flag__getFileStatus2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getFileStatus2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getFileStatus2Response, 0, sizeof(struct impltns__getFileStatus2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getFileStatus2Response(struct soap *soap, const struct impltns__getFileStatus2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getFileStatus2Response);
	if (soap_out_impltns__getFileStatus2Response(soap, tag?tag:"impltns:getFileStatus2Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getFileStatus2Response * SOAP_FMAC4 soap_get_impltns__getFileStatus2Response(struct soap *soap, struct impltns__getFileStatus2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getFileStatus2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getFileStatus2Response * SOAP_FMAC2 soap_instantiate_impltns__getFileStatus2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getFileStatus2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getFileStatus2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus2Response);
		if (size)
			*size = sizeof(struct impltns__getFileStatus2Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus2Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getFileStatus2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getFileStatus2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getFileStatus2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getFileStatus2Response %p -> %p\n", q, p));
	*(struct impltns__getFileStatus2Response*)p = *(struct impltns__getFileStatus2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getFileStatus(struct soap *soap, struct impltns__getFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_requestID);
	soap_default_int(soap, &a->_offset);
	soap_default_int(soap, &a->_limit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getFileStatus(struct soap *soap, const struct impltns__getFileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requestID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_requestID);
	soap_embedded(soap, &a->_offset, SOAP_TYPE_fts3_int);
	soap_embedded(soap, &a->_limit, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getFileStatus(struct soap *soap, const char *tag, int id, const struct impltns__getFileStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getFileStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestID", -1, &a->_requestID, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->_offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->_limit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getFileStatus * SOAP_FMAC4 soap_in_impltns__getFileStatus(struct soap *soap, const char *tag, struct impltns__getFileStatus *a, const char *type)
{
	size_t soap_flag__requestID = 1;
	size_t soap_flag__offset = 1;
	size_t soap_flag__limit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getFileStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getFileStatus, sizeof(struct impltns__getFileStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__getFileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__requestID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requestID, "xsd:string"))
				{	soap_flag__requestID--;
					continue;
				}
			if (soap_flag__offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_offset, "xsd:int"))
				{	soap_flag__offset--;
					continue;
				}
			if (soap_flag__limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_limit, "xsd:int"))
				{	soap_flag__limit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getFileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getFileStatus, 0, sizeof(struct impltns__getFileStatus), 0, soap_copy_impltns__getFileStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requestID > 0 || soap_flag__offset > 0 || soap_flag__limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getFileStatus(struct soap *soap, const struct impltns__getFileStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getFileStatus);
	if (soap_out_impltns__getFileStatus(soap, tag?tag:"impltns:getFileStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getFileStatus * SOAP_FMAC4 soap_get_impltns__getFileStatus(struct soap *soap, struct impltns__getFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getFileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getFileStatus * SOAP_FMAC2 soap_instantiate_impltns__getFileStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getFileStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getFileStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus);
		if (size)
			*size = sizeof(struct impltns__getFileStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getFileStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getFileStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getFileStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getFileStatus %p -> %p\n", q, p));
	*(struct impltns__getFileStatus*)p = *(struct impltns__getFileStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__getFileStatusResponse(struct soap *soap, struct impltns__getFileStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getFileStatusReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__getFileStatusResponse(struct soap *soap, const struct impltns__getFileStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, &a->_getFileStatusReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__getFileStatusResponse(struct soap *soap, const char *tag, int id, const struct impltns__getFileStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__getFileStatusResponse), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, "getFileStatusReturn", -1, &a->_getFileStatusReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__getFileStatusResponse * SOAP_FMAC4 soap_in_impltns__getFileStatusResponse(struct soap *soap, const char *tag, struct impltns__getFileStatusResponse *a, const char *type)
{
	size_t soap_flag__getFileStatusReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__getFileStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__getFileStatusResponse, sizeof(struct impltns__getFileStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__getFileStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getFileStatusReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, NULL, &a->_getFileStatusReturn, "impltns:ArrayOf_tns3_FileTransferStatus"))
				{	soap_flag__getFileStatusReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__getFileStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__getFileStatusResponse, 0, sizeof(struct impltns__getFileStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__getFileStatusResponse(struct soap *soap, const struct impltns__getFileStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__getFileStatusResponse);
	if (soap_out_impltns__getFileStatusResponse(soap, tag?tag:"impltns:getFileStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__getFileStatusResponse * SOAP_FMAC4 soap_get_impltns__getFileStatusResponse(struct soap *soap, struct impltns__getFileStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__getFileStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__getFileStatusResponse * SOAP_FMAC2 soap_instantiate_impltns__getFileStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__getFileStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__getFileStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatusResponse);
		if (size)
			*size = sizeof(struct impltns__getFileStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__getFileStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__getFileStatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__getFileStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__getFileStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__getFileStatusResponse %p -> %p\n", q, p));
	*(struct impltns__getFileStatusResponse*)p = *(struct impltns__getFileStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listRequests2(struct soap *soap, struct impltns__listRequests2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_inGivenStates = NULL;
	soap_default_std__string(soap, &a->_forDN);
	soap_default_std__string(soap, &a->_forVO);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listRequests2(struct soap *soap, const struct impltns__listRequests2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_inGivenStates);
	soap_embedded(soap, &a->_forDN, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_forDN);
	soap_embedded(soap, &a->_forVO, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_forVO);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listRequests2(struct soap *soap, const char *tag, int id, const struct impltns__listRequests2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listRequests2), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, "inGivenStates", -1, &a->_inGivenStates, ""))
		return soap->error;
	if (soap_out_std__string(soap, "forDN", -1, &a->_forDN, ""))
		return soap->error;
	if (soap_out_std__string(soap, "forVO", -1, &a->_forVO, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listRequests2 * SOAP_FMAC4 soap_in_impltns__listRequests2(struct soap *soap, const char *tag, struct impltns__listRequests2 *a, const char *type)
{
	size_t soap_flag__inGivenStates = 1;
	size_t soap_flag__forDN = 1;
	size_t soap_flag__forVO = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listRequests2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listRequests2, sizeof(struct impltns__listRequests2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__listRequests2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inGivenStates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_inGivenStates, "impltns:ArrayOf_soapenc_string"))
				{	soap_flag__inGivenStates--;
					continue;
				}
			if (soap_flag__forDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_forDN, "xsd:string"))
				{	soap_flag__forDN--;
					continue;
				}
			if (soap_flag__forVO && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_forVO, "xsd:string"))
				{	soap_flag__forVO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listRequests2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listRequests2, 0, sizeof(struct impltns__listRequests2), 0, soap_copy_impltns__listRequests2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__forDN > 0 || soap_flag__forVO > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listRequests2(struct soap *soap, const struct impltns__listRequests2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listRequests2);
	if (soap_out_impltns__listRequests2(soap, tag?tag:"impltns:listRequests2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listRequests2 * SOAP_FMAC4 soap_get_impltns__listRequests2(struct soap *soap, struct impltns__listRequests2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listRequests2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listRequests2 * SOAP_FMAC2 soap_instantiate_impltns__listRequests2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listRequests2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listRequests2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests2);
		if (size)
			*size = sizeof(struct impltns__listRequests2);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listRequests2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listRequests2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listRequests2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listRequests2 %p -> %p\n", q, p));
	*(struct impltns__listRequests2*)p = *(struct impltns__listRequests2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listRequests2Response(struct soap *soap, struct impltns__listRequests2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listRequests2Return = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listRequests2Response(struct soap *soap, const struct impltns__listRequests2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, &a->_listRequests2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listRequests2Response(struct soap *soap, const char *tag, int id, const struct impltns__listRequests2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listRequests2Response), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, "listRequests2Return", -1, &a->_listRequests2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listRequests2Response * SOAP_FMAC4 soap_in_impltns__listRequests2Response(struct soap *soap, const char *tag, struct impltns__listRequests2Response *a, const char *type)
{
	size_t soap_flag__listRequests2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listRequests2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listRequests2Response, sizeof(struct impltns__listRequests2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__listRequests2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listRequests2Return && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, &a->_listRequests2Return, "impltns:ArrayOf_tns3_JobStatus"))
				{	soap_flag__listRequests2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listRequests2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listRequests2Response, 0, sizeof(struct impltns__listRequests2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listRequests2Response(struct soap *soap, const struct impltns__listRequests2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listRequests2Response);
	if (soap_out_impltns__listRequests2Response(soap, tag?tag:"impltns:listRequests2Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listRequests2Response * SOAP_FMAC4 soap_get_impltns__listRequests2Response(struct soap *soap, struct impltns__listRequests2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listRequests2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listRequests2Response * SOAP_FMAC2 soap_instantiate_impltns__listRequests2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listRequests2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listRequests2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests2Response);
		if (size)
			*size = sizeof(struct impltns__listRequests2Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests2Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listRequests2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listRequests2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listRequests2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listRequests2Response %p -> %p\n", q, p));
	*(struct impltns__listRequests2Response*)p = *(struct impltns__listRequests2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listRequests(struct soap *soap, struct impltns__listRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_inGivenStates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listRequests(struct soap *soap, const struct impltns__listRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, &a->_inGivenStates);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listRequests(struct soap *soap, const char *tag, int id, const struct impltns__listRequests *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listRequests), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, "inGivenStates", -1, &a->_inGivenStates, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listRequests * SOAP_FMAC4 soap_in_impltns__listRequests(struct soap *soap, const char *tag, struct impltns__listRequests *a, const char *type)
{
	size_t soap_flag__inGivenStates = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listRequests *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listRequests, sizeof(struct impltns__listRequests), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__listRequests(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inGivenStates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, NULL, &a->_inGivenStates, "impltns:ArrayOf_soapenc_string"))
				{	soap_flag__inGivenStates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listRequests *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listRequests, 0, sizeof(struct impltns__listRequests), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listRequests(struct soap *soap, const struct impltns__listRequests *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listRequests);
	if (soap_out_impltns__listRequests(soap, tag?tag:"impltns:listRequests", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listRequests * SOAP_FMAC4 soap_get_impltns__listRequests(struct soap *soap, struct impltns__listRequests *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listRequests(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listRequests * SOAP_FMAC2 soap_instantiate_impltns__listRequests(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listRequests(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listRequests, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests);
		if (size)
			*size = sizeof(struct impltns__listRequests);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequests[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listRequests);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listRequests*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listRequests(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listRequests %p -> %p\n", q, p));
	*(struct impltns__listRequests*)p = *(struct impltns__listRequests*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__listRequestsResponse(struct soap *soap, struct impltns__listRequestsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_listRequestsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__listRequestsResponse(struct soap *soap, const struct impltns__listRequestsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, &a->_listRequestsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__listRequestsResponse(struct soap *soap, const char *tag, int id, const struct impltns__listRequestsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__listRequestsResponse), type))
		return soap->error;
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, "listRequestsReturn", -1, &a->_listRequestsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__listRequestsResponse * SOAP_FMAC4 soap_in_impltns__listRequestsResponse(struct soap *soap, const char *tag, struct impltns__listRequestsResponse *a, const char *type)
{
	size_t soap_flag__listRequestsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__listRequestsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__listRequestsResponse, sizeof(struct impltns__listRequestsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__listRequestsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__listRequestsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, NULL, &a->_listRequestsReturn, "impltns:ArrayOf_tns3_JobStatus"))
				{	soap_flag__listRequestsReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__listRequestsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__listRequestsResponse, 0, sizeof(struct impltns__listRequestsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__listRequestsResponse(struct soap *soap, const struct impltns__listRequestsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__listRequestsResponse);
	if (soap_out_impltns__listRequestsResponse(soap, tag?tag:"impltns:listRequestsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__listRequestsResponse * SOAP_FMAC4 soap_get_impltns__listRequestsResponse(struct soap *soap, struct impltns__listRequestsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__listRequestsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__listRequestsResponse * SOAP_FMAC2 soap_instantiate_impltns__listRequestsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__listRequestsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__listRequestsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequestsResponse);
		if (size)
			*size = sizeof(struct impltns__listRequestsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__listRequestsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__listRequestsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__listRequestsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__listRequestsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__listRequestsResponse %p -> %p\n", q, p));
	*(struct impltns__listRequestsResponse*)p = *(struct impltns__listRequestsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__blacklist(struct soap *soap, struct impltns__blacklist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_type);
	soap_default_std__string(soap, &a->_subject);
	soap_default_bool(soap, &a->_blk);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__blacklist(struct soap *soap, const struct impltns__blacklist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_type, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_type);
	soap_embedded(soap, &a->_subject, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_subject);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__blacklist(struct soap *soap, const char *tag, int id, const struct impltns__blacklist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__blacklist), type))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &a->_type, ""))
		return soap->error;
	if (soap_out_std__string(soap, "subject", -1, &a->_subject, ""))
		return soap->error;
	if (soap_out_bool(soap, "blk", -1, &a->_blk, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__blacklist * SOAP_FMAC4 soap_in_impltns__blacklist(struct soap *soap, const char *tag, struct impltns__blacklist *a, const char *type)
{
	size_t soap_flag__type = 1;
	size_t soap_flag__subject = 1;
	size_t soap_flag__blk = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__blacklist *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__blacklist, sizeof(struct impltns__blacklist), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__blacklist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_type, "xsd:string"))
				{	soap_flag__type--;
					continue;
				}
			if (soap_flag__subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_subject, "xsd:string"))
				{	soap_flag__subject--;
					continue;
				}
			if (soap_flag__blk && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_blk, "xsd:boolean"))
				{	soap_flag__blk--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__blacklist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__blacklist, 0, sizeof(struct impltns__blacklist), 0, soap_copy_impltns__blacklist);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__type > 0 || soap_flag__subject > 0 || soap_flag__blk > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__blacklist(struct soap *soap, const struct impltns__blacklist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__blacklist);
	if (soap_out_impltns__blacklist(soap, tag?tag:"impltns:blacklist", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__blacklist * SOAP_FMAC4 soap_get_impltns__blacklist(struct soap *soap, struct impltns__blacklist *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__blacklist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__blacklist * SOAP_FMAC2 soap_instantiate_impltns__blacklist(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__blacklist(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__blacklist, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__blacklist);
		if (size)
			*size = sizeof(struct impltns__blacklist);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__blacklist[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__blacklist);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__blacklist*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__blacklist(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__blacklist %p -> %p\n", q, p));
	*(struct impltns__blacklist*)p = *(struct impltns__blacklist*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__blacklistResponse(struct soap *soap, struct impltns__blacklistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__blacklistResponse(struct soap *soap, const struct impltns__blacklistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__blacklistResponse(struct soap *soap, const char *tag, int id, const struct impltns__blacklistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__blacklistResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__blacklistResponse * SOAP_FMAC4 soap_in_impltns__blacklistResponse(struct soap *soap, const char *tag, struct impltns__blacklistResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__blacklistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__blacklistResponse, sizeof(struct impltns__blacklistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__blacklistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__blacklistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__blacklistResponse, 0, sizeof(struct impltns__blacklistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__blacklistResponse(struct soap *soap, const struct impltns__blacklistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__blacklistResponse);
	if (soap_out_impltns__blacklistResponse(soap, tag?tag:"impltns:blacklistResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__blacklistResponse * SOAP_FMAC4 soap_get_impltns__blacklistResponse(struct soap *soap, struct impltns__blacklistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__blacklistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__blacklistResponse * SOAP_FMAC2 soap_instantiate_impltns__blacklistResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__blacklistResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__blacklistResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__blacklistResponse);
		if (size)
			*size = sizeof(struct impltns__blacklistResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__blacklistResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__blacklistResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__blacklistResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__blacklistResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__blacklistResponse %p -> %p\n", q, p));
	*(struct impltns__blacklistResponse*)p = *(struct impltns__blacklistResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__debugSet(struct soap *soap, struct impltns__debugSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_source);
	soap_default_std__string(soap, &a->_destination);
	soap_default_bool(soap, &a->_debug);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__debugSet(struct soap *soap, const struct impltns__debugSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_source, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_source);
	soap_embedded(soap, &a->_destination, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_destination);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__debugSet(struct soap *soap, const char *tag, int id, const struct impltns__debugSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__debugSet), type))
		return soap->error;
	if (soap_out_std__string(soap, "source", -1, &a->_source, ""))
		return soap->error;
	if (soap_out_std__string(soap, "destination", -1, &a->_destination, ""))
		return soap->error;
	if (soap_out_bool(soap, "debug", -1, &a->_debug, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__debugSet * SOAP_FMAC4 soap_in_impltns__debugSet(struct soap *soap, const char *tag, struct impltns__debugSet *a, const char *type)
{
	size_t soap_flag__source = 1;
	size_t soap_flag__destination = 1;
	size_t soap_flag__debug = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__debugSet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__debugSet, sizeof(struct impltns__debugSet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__debugSet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__source && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_source, "xsd:string"))
				{	soap_flag__source--;
					continue;
				}
			if (soap_flag__destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_destination, "xsd:string"))
				{	soap_flag__destination--;
					continue;
				}
			if (soap_flag__debug && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_debug, "xsd:boolean"))
				{	soap_flag__debug--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__debugSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__debugSet, 0, sizeof(struct impltns__debugSet), 0, soap_copy_impltns__debugSet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__source > 0 || soap_flag__destination > 0 || soap_flag__debug > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__debugSet(struct soap *soap, const struct impltns__debugSet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__debugSet);
	if (soap_out_impltns__debugSet(soap, tag?tag:"impltns:debugSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__debugSet * SOAP_FMAC4 soap_get_impltns__debugSet(struct soap *soap, struct impltns__debugSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__debugSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__debugSet * SOAP_FMAC2 soap_instantiate_impltns__debugSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__debugSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__debugSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__debugSet);
		if (size)
			*size = sizeof(struct impltns__debugSet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__debugSet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__debugSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__debugSet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__debugSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__debugSet %p -> %p\n", q, p));
	*(struct impltns__debugSet*)p = *(struct impltns__debugSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__debugSetResponse(struct soap *soap, struct impltns__debugSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__debugSetResponse(struct soap *soap, const struct impltns__debugSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__debugSetResponse(struct soap *soap, const char *tag, int id, const struct impltns__debugSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__debugSetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__debugSetResponse * SOAP_FMAC4 soap_in_impltns__debugSetResponse(struct soap *soap, const char *tag, struct impltns__debugSetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__debugSetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__debugSetResponse, sizeof(struct impltns__debugSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__debugSetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__debugSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__debugSetResponse, 0, sizeof(struct impltns__debugSetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__debugSetResponse(struct soap *soap, const struct impltns__debugSetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__debugSetResponse);
	if (soap_out_impltns__debugSetResponse(soap, tag?tag:"impltns:debugSetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__debugSetResponse * SOAP_FMAC4 soap_get_impltns__debugSetResponse(struct soap *soap, struct impltns__debugSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__debugSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__debugSetResponse * SOAP_FMAC2 soap_instantiate_impltns__debugSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__debugSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__debugSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__debugSetResponse);
		if (size)
			*size = sizeof(struct impltns__debugSetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__debugSetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__debugSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__debugSetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__debugSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__debugSetResponse %p -> %p\n", q, p));
	*(struct impltns__debugSetResponse*)p = *(struct impltns__debugSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__prioritySet(struct soap *soap, struct impltns__prioritySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_int(soap, &a->_priority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__prioritySet(struct soap *soap, const struct impltns__prioritySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_priority, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__prioritySet(struct soap *soap, const char *tag, int id, const struct impltns__prioritySet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__prioritySet), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &a->_priority, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__prioritySet * SOAP_FMAC4 soap_in_impltns__prioritySet(struct soap *soap, const char *tag, struct impltns__prioritySet *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__priority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__prioritySet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__prioritySet, sizeof(struct impltns__prioritySet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__prioritySet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_priority, "xsd:int"))
				{	soap_flag__priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__prioritySet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__prioritySet, 0, sizeof(struct impltns__prioritySet), 0, soap_copy_impltns__prioritySet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__priority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__prioritySet(struct soap *soap, const struct impltns__prioritySet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__prioritySet);
	if (soap_out_impltns__prioritySet(soap, tag?tag:"impltns:prioritySet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__prioritySet * SOAP_FMAC4 soap_get_impltns__prioritySet(struct soap *soap, struct impltns__prioritySet *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__prioritySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__prioritySet * SOAP_FMAC2 soap_instantiate_impltns__prioritySet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__prioritySet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__prioritySet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__prioritySet);
		if (size)
			*size = sizeof(struct impltns__prioritySet);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__prioritySet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__prioritySet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__prioritySet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__prioritySet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__prioritySet %p -> %p\n", q, p));
	*(struct impltns__prioritySet*)p = *(struct impltns__prioritySet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__prioritySetResponse(struct soap *soap, struct impltns__prioritySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__prioritySetResponse(struct soap *soap, const struct impltns__prioritySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__prioritySetResponse(struct soap *soap, const char *tag, int id, const struct impltns__prioritySetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__prioritySetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__prioritySetResponse * SOAP_FMAC4 soap_in_impltns__prioritySetResponse(struct soap *soap, const char *tag, struct impltns__prioritySetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__prioritySetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__prioritySetResponse, sizeof(struct impltns__prioritySetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__prioritySetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__prioritySetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__prioritySetResponse, 0, sizeof(struct impltns__prioritySetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__prioritySetResponse(struct soap *soap, const struct impltns__prioritySetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__prioritySetResponse);
	if (soap_out_impltns__prioritySetResponse(soap, tag?tag:"impltns:prioritySetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__prioritySetResponse * SOAP_FMAC4 soap_get_impltns__prioritySetResponse(struct soap *soap, struct impltns__prioritySetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__prioritySetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__prioritySetResponse * SOAP_FMAC2 soap_instantiate_impltns__prioritySetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__prioritySetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__prioritySetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__prioritySetResponse);
		if (size)
			*size = sizeof(struct impltns__prioritySetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__prioritySetResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__prioritySetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__prioritySetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__prioritySetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__prioritySetResponse %p -> %p\n", q, p));
	*(struct impltns__prioritySetResponse*)p = *(struct impltns__prioritySetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit4(struct soap *soap, struct impltns__transferSubmit4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit4(struct soap *soap, const struct impltns__transferSubmit4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJob3(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit4(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit4 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit4), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJob3(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit4 * SOAP_FMAC4 soap_in_impltns__transferSubmit4(struct soap *soap, const char *tag, struct impltns__transferSubmit4 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit4, sizeof(struct impltns__transferSubmit4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit4(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJob3(soap, NULL, &a->_job, "tns3:TransferJob3"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit4, 0, sizeof(struct impltns__transferSubmit4), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit4(struct soap *soap, const struct impltns__transferSubmit4 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit4);
	if (soap_out_impltns__transferSubmit4(soap, tag?tag:"impltns:transferSubmit4", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit4 * SOAP_FMAC4 soap_get_impltns__transferSubmit4(struct soap *soap, struct impltns__transferSubmit4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit4 * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit4(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit4, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit4);
		if (size)
			*size = sizeof(struct impltns__transferSubmit4);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit4[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit4);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit4*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit4(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit4 %p -> %p\n", q, p));
	*(struct impltns__transferSubmit4*)p = *(struct impltns__transferSubmit4*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit4Response(struct soap *soap, struct impltns__transferSubmit4Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmit4Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit4Response(struct soap *soap, const struct impltns__transferSubmit4Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmit4Return, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmit4Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit4Response(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit4Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit4Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmit4Return", -1, &a->_transferSubmit4Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit4Response * SOAP_FMAC4 soap_in_impltns__transferSubmit4Response(struct soap *soap, const char *tag, struct impltns__transferSubmit4Response *a, const char *type)
{
	size_t soap_flag__transferSubmit4Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit4Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit4Response, sizeof(struct impltns__transferSubmit4Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit4Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmit4Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmit4Return, "xsd:string"))
				{	soap_flag__transferSubmit4Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit4Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit4Response, 0, sizeof(struct impltns__transferSubmit4Response), 0, soap_copy_impltns__transferSubmit4Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmit4Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit4Response(struct soap *soap, const struct impltns__transferSubmit4Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit4Response);
	if (soap_out_impltns__transferSubmit4Response(soap, tag?tag:"impltns:transferSubmit4Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit4Response * SOAP_FMAC4 soap_get_impltns__transferSubmit4Response(struct soap *soap, struct impltns__transferSubmit4Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit4Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit4Response * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit4Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit4Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit4Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit4Response);
		if (size)
			*size = sizeof(struct impltns__transferSubmit4Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit4Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit4Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit4Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit4Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit4Response %p -> %p\n", q, p));
	*(struct impltns__transferSubmit4Response*)p = *(struct impltns__transferSubmit4Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit3(struct soap *soap, struct impltns__transferSubmit3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit3(struct soap *soap, const struct impltns__transferSubmit3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJob2(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit3(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit3 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit3), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJob2(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit3 * SOAP_FMAC4 soap_in_impltns__transferSubmit3(struct soap *soap, const char *tag, struct impltns__transferSubmit3 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit3, sizeof(struct impltns__transferSubmit3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit3(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJob2(soap, NULL, &a->_job, "tns3:TransferJob2"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit3, 0, sizeof(struct impltns__transferSubmit3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit3(struct soap *soap, const struct impltns__transferSubmit3 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit3);
	if (soap_out_impltns__transferSubmit3(soap, tag?tag:"impltns:transferSubmit3", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit3 * SOAP_FMAC4 soap_get_impltns__transferSubmit3(struct soap *soap, struct impltns__transferSubmit3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit3 * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit3);
		if (size)
			*size = sizeof(struct impltns__transferSubmit3);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit3[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit3);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit3*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit3 %p -> %p\n", q, p));
	*(struct impltns__transferSubmit3*)p = *(struct impltns__transferSubmit3*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit3Response(struct soap *soap, struct impltns__transferSubmit3Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmit3Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit3Response(struct soap *soap, const struct impltns__transferSubmit3Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmit3Return, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmit3Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit3Response(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit3Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit3Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmit3Return", -1, &a->_transferSubmit3Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit3Response * SOAP_FMAC4 soap_in_impltns__transferSubmit3Response(struct soap *soap, const char *tag, struct impltns__transferSubmit3Response *a, const char *type)
{
	size_t soap_flag__transferSubmit3Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit3Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit3Response, sizeof(struct impltns__transferSubmit3Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit3Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmit3Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmit3Return, "xsd:string"))
				{	soap_flag__transferSubmit3Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit3Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit3Response, 0, sizeof(struct impltns__transferSubmit3Response), 0, soap_copy_impltns__transferSubmit3Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmit3Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit3Response(struct soap *soap, const struct impltns__transferSubmit3Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit3Response);
	if (soap_out_impltns__transferSubmit3Response(soap, tag?tag:"impltns:transferSubmit3Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit3Response * SOAP_FMAC4 soap_get_impltns__transferSubmit3Response(struct soap *soap, struct impltns__transferSubmit3Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit3Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit3Response * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit3Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit3Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit3Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit3Response);
		if (size)
			*size = sizeof(struct impltns__transferSubmit3Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit3Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit3Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit3Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit3Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit3Response %p -> %p\n", q, p));
	*(struct impltns__transferSubmit3Response*)p = *(struct impltns__transferSubmit3Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit2(struct soap *soap, struct impltns__transferSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit2(struct soap *soap, const struct impltns__transferSubmit2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit2(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit2), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit2 * SOAP_FMAC4 soap_in_impltns__transferSubmit2(struct soap *soap, const char *tag, struct impltns__transferSubmit2 *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit2, sizeof(struct impltns__transferSubmit2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJob(soap, NULL, &a->_job, "tns3:TransferJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit2, 0, sizeof(struct impltns__transferSubmit2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit2(struct soap *soap, const struct impltns__transferSubmit2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit2);
	if (soap_out_impltns__transferSubmit2(soap, tag?tag:"impltns:transferSubmit2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit2 * SOAP_FMAC4 soap_get_impltns__transferSubmit2(struct soap *soap, struct impltns__transferSubmit2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit2 * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit2);
		if (size)
			*size = sizeof(struct impltns__transferSubmit2);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit2[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit2);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit2 %p -> %p\n", q, p));
	*(struct impltns__transferSubmit2*)p = *(struct impltns__transferSubmit2*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit2Response(struct soap *soap, struct impltns__transferSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmit2Return);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit2Response(struct soap *soap, const struct impltns__transferSubmit2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmit2Return, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmit2Return);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit2Response(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit2Response), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmit2Return", -1, &a->_transferSubmit2Return, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit2Response * SOAP_FMAC4 soap_in_impltns__transferSubmit2Response(struct soap *soap, const char *tag, struct impltns__transferSubmit2Response *a, const char *type)
{
	size_t soap_flag__transferSubmit2Return = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit2Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit2Response, sizeof(struct impltns__transferSubmit2Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmit2Return && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmit2Return, "xsd:string"))
				{	soap_flag__transferSubmit2Return--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit2Response, 0, sizeof(struct impltns__transferSubmit2Response), 0, soap_copy_impltns__transferSubmit2Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmit2Return > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit2Response(struct soap *soap, const struct impltns__transferSubmit2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit2Response);
	if (soap_out_impltns__transferSubmit2Response(soap, tag?tag:"impltns:transferSubmit2Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit2Response * SOAP_FMAC4 soap_get_impltns__transferSubmit2Response(struct soap *soap, struct impltns__transferSubmit2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit2Response * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit2Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit2Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit2Response);
		if (size)
			*size = sizeof(struct impltns__transferSubmit2Response);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit2Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit2Response);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit2Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit2Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit2Response %p -> %p\n", q, p));
	*(struct impltns__transferSubmit2Response*)p = *(struct impltns__transferSubmit2Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmit(struct soap *soap, struct impltns__transferSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_job = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmit(struct soap *soap, const struct impltns__transferSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns3__TransferJob(soap, &a->_job);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmit(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmit), type))
		return soap->error;
	if (soap_out_PointerTotns3__TransferJob(soap, "job", -1, &a->_job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmit * SOAP_FMAC4 soap_in_impltns__transferSubmit(struct soap *soap, const char *tag, struct impltns__transferSubmit *a, const char *type)
{
	size_t soap_flag__job = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmit, sizeof(struct impltns__transferSubmit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__TransferJob(soap, NULL, &a->_job, "tns3:TransferJob"))
				{	soap_flag__job--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmit, 0, sizeof(struct impltns__transferSubmit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmit(struct soap *soap, const struct impltns__transferSubmit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmit);
	if (soap_out_impltns__transferSubmit(soap, tag?tag:"impltns:transferSubmit", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmit * SOAP_FMAC4 soap_get_impltns__transferSubmit(struct soap *soap, struct impltns__transferSubmit *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmit * SOAP_FMAC2 soap_instantiate_impltns__transferSubmit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit);
		if (size)
			*size = sizeof(struct impltns__transferSubmit);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmit[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmit %p -> %p\n", q, p));
	*(struct impltns__transferSubmit*)p = *(struct impltns__transferSubmit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_impltns__transferSubmitResponse(struct soap *soap, struct impltns__transferSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_transferSubmitReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_impltns__transferSubmitResponse(struct soap *soap, const struct impltns__transferSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_transferSubmitReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_transferSubmitReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_impltns__transferSubmitResponse(struct soap *soap, const char *tag, int id, const struct impltns__transferSubmitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_impltns__transferSubmitResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "transferSubmitReturn", -1, &a->_transferSubmitReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct impltns__transferSubmitResponse * SOAP_FMAC4 soap_in_impltns__transferSubmitResponse(struct soap *soap, const char *tag, struct impltns__transferSubmitResponse *a, const char *type)
{
	size_t soap_flag__transferSubmitReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct impltns__transferSubmitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_impltns__transferSubmitResponse, sizeof(struct impltns__transferSubmitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_impltns__transferSubmitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__transferSubmitReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_transferSubmitReturn, "xsd:string"))
				{	soap_flag__transferSubmitReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct impltns__transferSubmitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_impltns__transferSubmitResponse, 0, sizeof(struct impltns__transferSubmitResponse), 0, soap_copy_impltns__transferSubmitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__transferSubmitReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_impltns__transferSubmitResponse(struct soap *soap, const struct impltns__transferSubmitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_impltns__transferSubmitResponse);
	if (soap_out_impltns__transferSubmitResponse(soap, tag?tag:"impltns:transferSubmitResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct impltns__transferSubmitResponse * SOAP_FMAC4 soap_get_impltns__transferSubmitResponse(struct soap *soap, struct impltns__transferSubmitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_impltns__transferSubmitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct impltns__transferSubmitResponse * SOAP_FMAC2 soap_instantiate_impltns__transferSubmitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_impltns__transferSubmitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_impltns__transferSubmitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmitResponse);
		if (size)
			*size = sizeof(struct impltns__transferSubmitResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct impltns__transferSubmitResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct impltns__transferSubmitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct impltns__transferSubmitResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_impltns__transferSubmitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct impltns__transferSubmitResponse %p -> %p\n", q, p));
	*(struct impltns__transferSubmitResponse*)p = *(struct impltns__transferSubmitResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setQueueTimeout(struct soap *soap, struct implcfg__setQueueTimeout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->timeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setQueueTimeout(struct soap *soap, const struct implcfg__setQueueTimeout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setQueueTimeout(struct soap *soap, const char *tag, int id, const struct implcfg__setQueueTimeout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setQueueTimeout), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "timeout", -1, &a->timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setQueueTimeout * SOAP_FMAC4 soap_in_implcfg__setQueueTimeout(struct soap *soap, const char *tag, struct implcfg__setQueueTimeout *a, const char *type)
{
	size_t soap_flag_timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setQueueTimeout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setQueueTimeout, sizeof(struct implcfg__setQueueTimeout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setQueueTimeout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "timeout", &a->timeout, "xsd:unsignedInt"))
				{	soap_flag_timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setQueueTimeout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setQueueTimeout, 0, sizeof(struct implcfg__setQueueTimeout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setQueueTimeout(struct soap *soap, const struct implcfg__setQueueTimeout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setQueueTimeout);
	if (soap_out_implcfg__setQueueTimeout(soap, tag?tag:"implcfg:setQueueTimeout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setQueueTimeout * SOAP_FMAC4 soap_get_implcfg__setQueueTimeout(struct soap *soap, struct implcfg__setQueueTimeout *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setQueueTimeout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setQueueTimeout * SOAP_FMAC2 soap_instantiate_implcfg__setQueueTimeout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setQueueTimeout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setQueueTimeout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setQueueTimeout);
		if (size)
			*size = sizeof(struct implcfg__setQueueTimeout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setQueueTimeout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setQueueTimeout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setQueueTimeout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setQueueTimeout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setQueueTimeout %p -> %p\n", q, p));
	*(struct implcfg__setQueueTimeout*)p = *(struct implcfg__setQueueTimeout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setQueueTimeoutResponse(struct soap *soap, struct implcfg__setQueueTimeoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setQueueTimeoutResponse(struct soap *soap, const struct implcfg__setQueueTimeoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setQueueTimeoutResponse(struct soap *soap, const char *tag, int id, const struct implcfg__setQueueTimeoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setQueueTimeoutResponse * SOAP_FMAC4 soap_in_implcfg__setQueueTimeoutResponse(struct soap *soap, const char *tag, struct implcfg__setQueueTimeoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setQueueTimeoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse, sizeof(struct implcfg__setQueueTimeoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setQueueTimeoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setQueueTimeoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse, 0, sizeof(struct implcfg__setQueueTimeoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setQueueTimeoutResponse(struct soap *soap, const struct implcfg__setQueueTimeoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse);
	if (soap_out_implcfg__setQueueTimeoutResponse(soap, tag?tag:"implcfg:setQueueTimeoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setQueueTimeoutResponse * SOAP_FMAC4 soap_get_implcfg__setQueueTimeoutResponse(struct soap *soap, struct implcfg__setQueueTimeoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setQueueTimeoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setQueueTimeoutResponse * SOAP_FMAC2 soap_instantiate_implcfg__setQueueTimeoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setQueueTimeoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setQueueTimeoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setQueueTimeoutResponse);
		if (size)
			*size = sizeof(struct implcfg__setQueueTimeoutResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setQueueTimeoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setQueueTimeoutResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setQueueTimeoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setQueueTimeoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setQueueTimeoutResponse %p -> %p\n", q, p));
	*(struct implcfg__setQueueTimeoutResponse*)p = *(struct implcfg__setQueueTimeoutResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setRetry(struct soap *soap, struct implcfg__setRetry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->retry);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setRetry(struct soap *soap, const struct implcfg__setRetry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->retry, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setRetry(struct soap *soap, const char *tag, int id, const struct implcfg__setRetry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setRetry), type))
		return soap->error;
	if (soap_out_int(soap, "retry", -1, &a->retry, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setRetry * SOAP_FMAC4 soap_in_implcfg__setRetry(struct soap *soap, const char *tag, struct implcfg__setRetry *a, const char *type)
{
	size_t soap_flag_retry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setRetry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setRetry, sizeof(struct implcfg__setRetry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setRetry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_retry && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "retry", &a->retry, "xsd:int"))
				{	soap_flag_retry--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setRetry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setRetry, 0, sizeof(struct implcfg__setRetry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_retry > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setRetry(struct soap *soap, const struct implcfg__setRetry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setRetry);
	if (soap_out_implcfg__setRetry(soap, tag?tag:"implcfg:setRetry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setRetry * SOAP_FMAC4 soap_get_implcfg__setRetry(struct soap *soap, struct implcfg__setRetry *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setRetry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setRetry * SOAP_FMAC2 soap_instantiate_implcfg__setRetry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setRetry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setRetry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setRetry);
		if (size)
			*size = sizeof(struct implcfg__setRetry);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setRetry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setRetry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setRetry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setRetry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setRetry %p -> %p\n", q, p));
	*(struct implcfg__setRetry*)p = *(struct implcfg__setRetry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setRetryResponse(struct soap *soap, struct implcfg__setRetryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setRetryResponse(struct soap *soap, const struct implcfg__setRetryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setRetryResponse(struct soap *soap, const char *tag, int id, const struct implcfg__setRetryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setRetryResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setRetryResponse * SOAP_FMAC4 soap_in_implcfg__setRetryResponse(struct soap *soap, const char *tag, struct implcfg__setRetryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setRetryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setRetryResponse, sizeof(struct implcfg__setRetryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setRetryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setRetryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setRetryResponse, 0, sizeof(struct implcfg__setRetryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setRetryResponse(struct soap *soap, const struct implcfg__setRetryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setRetryResponse);
	if (soap_out_implcfg__setRetryResponse(soap, tag?tag:"implcfg:setRetryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setRetryResponse * SOAP_FMAC4 soap_get_implcfg__setRetryResponse(struct soap *soap, struct implcfg__setRetryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setRetryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setRetryResponse * SOAP_FMAC2 soap_instantiate_implcfg__setRetryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setRetryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setRetryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setRetryResponse);
		if (size)
			*size = sizeof(struct implcfg__setRetryResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setRetryResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setRetryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setRetryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setRetryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setRetryResponse %p -> %p\n", q, p));
	*(struct implcfg__setRetryResponse*)p = *(struct implcfg__setRetryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__doDrain(struct soap *soap, struct implcfg__doDrain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->drain);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__doDrain(struct soap *soap, const struct implcfg__doDrain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__doDrain(struct soap *soap, const char *tag, int id, const struct implcfg__doDrain *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__doDrain), type))
		return soap->error;
	if (soap_out_bool(soap, "drain", -1, &a->drain, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__doDrain * SOAP_FMAC4 soap_in_implcfg__doDrain(struct soap *soap, const char *tag, struct implcfg__doDrain *a, const char *type)
{
	size_t soap_flag_drain = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__doDrain *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__doDrain, sizeof(struct implcfg__doDrain), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__doDrain(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_drain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "drain", &a->drain, "xsd:boolean"))
				{	soap_flag_drain--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__doDrain *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__doDrain, 0, sizeof(struct implcfg__doDrain), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_drain > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__doDrain(struct soap *soap, const struct implcfg__doDrain *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__doDrain);
	if (soap_out_implcfg__doDrain(soap, tag?tag:"implcfg:doDrain", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__doDrain * SOAP_FMAC4 soap_get_implcfg__doDrain(struct soap *soap, struct implcfg__doDrain *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__doDrain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__doDrain * SOAP_FMAC2 soap_instantiate_implcfg__doDrain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__doDrain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__doDrain, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__doDrain);
		if (size)
			*size = sizeof(struct implcfg__doDrain);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__doDrain[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__doDrain);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__doDrain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__doDrain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__doDrain %p -> %p\n", q, p));
	*(struct implcfg__doDrain*)p = *(struct implcfg__doDrain*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__doDrainResponse(struct soap *soap, struct implcfg__doDrainResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__doDrainResponse(struct soap *soap, const struct implcfg__doDrainResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__doDrainResponse(struct soap *soap, const char *tag, int id, const struct implcfg__doDrainResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__doDrainResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__doDrainResponse * SOAP_FMAC4 soap_in_implcfg__doDrainResponse(struct soap *soap, const char *tag, struct implcfg__doDrainResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__doDrainResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__doDrainResponse, sizeof(struct implcfg__doDrainResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__doDrainResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__doDrainResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__doDrainResponse, 0, sizeof(struct implcfg__doDrainResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__doDrainResponse(struct soap *soap, const struct implcfg__doDrainResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__doDrainResponse);
	if (soap_out_implcfg__doDrainResponse(soap, tag?tag:"implcfg:doDrainResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__doDrainResponse * SOAP_FMAC4 soap_get_implcfg__doDrainResponse(struct soap *soap, struct implcfg__doDrainResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__doDrainResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__doDrainResponse * SOAP_FMAC2 soap_instantiate_implcfg__doDrainResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__doDrainResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__doDrainResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__doDrainResponse);
		if (size)
			*size = sizeof(struct implcfg__doDrainResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__doDrainResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__doDrainResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__doDrainResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__doDrainResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__doDrainResponse %p -> %p\n", q, p));
	*(struct implcfg__doDrainResponse*)p = *(struct implcfg__doDrainResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__getConfiguration(struct soap *soap, struct implcfg__getConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->vo);
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->source);
	soap_default_std__string(soap, &a->destination);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__getConfiguration(struct soap *soap, const struct implcfg__getConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->vo, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->vo);
	soap_embedded(soap, &a->name, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->name);
	soap_embedded(soap, &a->source, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->source);
	soap_embedded(soap, &a->destination, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->destination);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__getConfiguration(struct soap *soap, const char *tag, int id, const struct implcfg__getConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__getConfiguration), type))
		return soap->error;
	if (soap_out_std__string(soap, "vo", -1, &a->vo, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "source", -1, &a->source, ""))
		return soap->error;
	if (soap_out_std__string(soap, "destination", -1, &a->destination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__getConfiguration * SOAP_FMAC4 soap_in_implcfg__getConfiguration(struct soap *soap, const char *tag, struct implcfg__getConfiguration *a, const char *type)
{
	size_t soap_flag_vo = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_source = 1;
	size_t soap_flag_destination = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__getConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__getConfiguration, sizeof(struct implcfg__getConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_implcfg__getConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_vo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "vo", &a->vo, "xsd:string"))
				{	soap_flag_vo--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_source && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "source", &a->source, "xsd:string"))
				{	soap_flag_source--;
					continue;
				}
			if (soap_flag_destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "destination", &a->destination, "xsd:string"))
				{	soap_flag_destination--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__getConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__getConfiguration, 0, sizeof(struct implcfg__getConfiguration), 0, soap_copy_implcfg__getConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_vo > 0 || soap_flag_name > 0 || soap_flag_source > 0 || soap_flag_destination > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__getConfiguration(struct soap *soap, const struct implcfg__getConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__getConfiguration);
	if (soap_out_implcfg__getConfiguration(soap, tag?tag:"implcfg:getConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__getConfiguration * SOAP_FMAC4 soap_get_implcfg__getConfiguration(struct soap *soap, struct implcfg__getConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__getConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__getConfiguration * SOAP_FMAC2 soap_instantiate_implcfg__getConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__getConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__getConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__getConfiguration);
		if (size)
			*size = sizeof(struct implcfg__getConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__getConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__getConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__getConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__getConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__getConfiguration %p -> %p\n", q, p));
	*(struct implcfg__getConfiguration*)p = *(struct implcfg__getConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__getConfigurationResponse(struct soap *soap, struct implcfg__getConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__getConfigurationResponse(struct soap *soap, const struct implcfg__getConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToconfig__Configuration(soap, &a->configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__getConfigurationResponse(struct soap *soap, const char *tag, int id, const struct implcfg__getConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__getConfigurationResponse), type))
		return soap->error;
	if (soap_out_PointerToconfig__Configuration(soap, "configuration", -1, &a->configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__getConfigurationResponse * SOAP_FMAC4 soap_in_implcfg__getConfigurationResponse(struct soap *soap, const char *tag, struct implcfg__getConfigurationResponse *a, const char *type)
{
	size_t soap_flag_configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__getConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__getConfigurationResponse, sizeof(struct implcfg__getConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__getConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__Configuration(soap, "configuration", &a->configuration, "config:Configuration"))
				{	soap_flag_configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__getConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__getConfigurationResponse, 0, sizeof(struct implcfg__getConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__getConfigurationResponse(struct soap *soap, const struct implcfg__getConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__getConfigurationResponse);
	if (soap_out_implcfg__getConfigurationResponse(soap, tag?tag:"implcfg:getConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__getConfigurationResponse * SOAP_FMAC4 soap_get_implcfg__getConfigurationResponse(struct soap *soap, struct implcfg__getConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__getConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__getConfigurationResponse * SOAP_FMAC2 soap_instantiate_implcfg__getConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__getConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__getConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__getConfigurationResponse);
		if (size)
			*size = sizeof(struct implcfg__getConfigurationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__getConfigurationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__getConfigurationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__getConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__getConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__getConfigurationResponse %p -> %p\n", q, p));
	*(struct implcfg__getConfigurationResponse*)p = *(struct implcfg__getConfigurationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__delConfiguration(struct soap *soap, struct implcfg__delConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__delConfiguration(struct soap *soap, const struct implcfg__delConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToconfig__Configuration(soap, &a->_configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__delConfiguration(struct soap *soap, const char *tag, int id, const struct implcfg__delConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__delConfiguration), type))
		return soap->error;
	if (soap_out_PointerToconfig__Configuration(soap, "configuration", -1, &a->_configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__delConfiguration * SOAP_FMAC4 soap_in_implcfg__delConfiguration(struct soap *soap, const char *tag, struct implcfg__delConfiguration *a, const char *type)
{
	size_t soap_flag__configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__delConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__delConfiguration, sizeof(struct implcfg__delConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__delConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__Configuration(soap, NULL, &a->_configuration, "config:Configuration"))
				{	soap_flag__configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__delConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__delConfiguration, 0, sizeof(struct implcfg__delConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__delConfiguration(struct soap *soap, const struct implcfg__delConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__delConfiguration);
	if (soap_out_implcfg__delConfiguration(soap, tag?tag:"implcfg:delConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__delConfiguration * SOAP_FMAC4 soap_get_implcfg__delConfiguration(struct soap *soap, struct implcfg__delConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__delConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__delConfiguration * SOAP_FMAC2 soap_instantiate_implcfg__delConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__delConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__delConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__delConfiguration);
		if (size)
			*size = sizeof(struct implcfg__delConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__delConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__delConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__delConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__delConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__delConfiguration %p -> %p\n", q, p));
	*(struct implcfg__delConfiguration*)p = *(struct implcfg__delConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__delConfigurationResponse(struct soap *soap, struct implcfg__delConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__delConfigurationResponse(struct soap *soap, const struct implcfg__delConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__delConfigurationResponse(struct soap *soap, const char *tag, int id, const struct implcfg__delConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__delConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__delConfigurationResponse * SOAP_FMAC4 soap_in_implcfg__delConfigurationResponse(struct soap *soap, const char *tag, struct implcfg__delConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__delConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__delConfigurationResponse, sizeof(struct implcfg__delConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__delConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__delConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__delConfigurationResponse, 0, sizeof(struct implcfg__delConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__delConfigurationResponse(struct soap *soap, const struct implcfg__delConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__delConfigurationResponse);
	if (soap_out_implcfg__delConfigurationResponse(soap, tag?tag:"implcfg:delConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__delConfigurationResponse * SOAP_FMAC4 soap_get_implcfg__delConfigurationResponse(struct soap *soap, struct implcfg__delConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__delConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__delConfigurationResponse * SOAP_FMAC2 soap_instantiate_implcfg__delConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__delConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__delConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__delConfigurationResponse);
		if (size)
			*size = sizeof(struct implcfg__delConfigurationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__delConfigurationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__delConfigurationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__delConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__delConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__delConfigurationResponse %p -> %p\n", q, p));
	*(struct implcfg__delConfigurationResponse*)p = *(struct implcfg__delConfigurationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setConfiguration(struct soap *soap, struct implcfg__setConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setConfiguration(struct soap *soap, const struct implcfg__setConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToconfig__Configuration(soap, &a->_configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setConfiguration(struct soap *soap, const char *tag, int id, const struct implcfg__setConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setConfiguration), type))
		return soap->error;
	if (soap_out_PointerToconfig__Configuration(soap, "configuration", -1, &a->_configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setConfiguration * SOAP_FMAC4 soap_in_implcfg__setConfiguration(struct soap *soap, const char *tag, struct implcfg__setConfiguration *a, const char *type)
{
	size_t soap_flag__configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setConfiguration, sizeof(struct implcfg__setConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__Configuration(soap, NULL, &a->_configuration, "config:Configuration"))
				{	soap_flag__configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setConfiguration, 0, sizeof(struct implcfg__setConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setConfiguration(struct soap *soap, const struct implcfg__setConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setConfiguration);
	if (soap_out_implcfg__setConfiguration(soap, tag?tag:"implcfg:setConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setConfiguration * SOAP_FMAC4 soap_get_implcfg__setConfiguration(struct soap *soap, struct implcfg__setConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setConfiguration * SOAP_FMAC2 soap_instantiate_implcfg__setConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setConfiguration);
		if (size)
			*size = sizeof(struct implcfg__setConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setConfiguration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setConfiguration %p -> %p\n", q, p));
	*(struct implcfg__setConfiguration*)p = *(struct implcfg__setConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_implcfg__setConfigurationResponse(struct soap *soap, struct implcfg__setConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_implcfg__setConfigurationResponse(struct soap *soap, const struct implcfg__setConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_implcfg__setConfigurationResponse(struct soap *soap, const char *tag, int id, const struct implcfg__setConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_implcfg__setConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct implcfg__setConfigurationResponse * SOAP_FMAC4 soap_in_implcfg__setConfigurationResponse(struct soap *soap, const char *tag, struct implcfg__setConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct implcfg__setConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_implcfg__setConfigurationResponse, sizeof(struct implcfg__setConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_implcfg__setConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct implcfg__setConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_implcfg__setConfigurationResponse, 0, sizeof(struct implcfg__setConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_implcfg__setConfigurationResponse(struct soap *soap, const struct implcfg__setConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_implcfg__setConfigurationResponse);
	if (soap_out_implcfg__setConfigurationResponse(soap, tag?tag:"implcfg:setConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct implcfg__setConfigurationResponse * SOAP_FMAC4 soap_get_implcfg__setConfigurationResponse(struct soap *soap, struct implcfg__setConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_implcfg__setConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct implcfg__setConfigurationResponse * SOAP_FMAC2 soap_instantiate_implcfg__setConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_implcfg__setConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_implcfg__setConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setConfigurationResponse);
		if (size)
			*size = sizeof(struct implcfg__setConfigurationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct implcfg__setConfigurationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct implcfg__setConfigurationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct implcfg__setConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_implcfg__setConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct implcfg__setConfigurationResponse %p -> %p\n", q, p));
	*(struct implcfg__setConfigurationResponse*)p = *(struct implcfg__setConfigurationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__destroy(struct soap *soap, struct delegation__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__destroy(struct soap *soap, const struct delegation__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__destroy(struct soap *soap, const char *tag, int id, const struct delegation__destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__destroy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__destroy * SOAP_FMAC4 soap_in_delegation__destroy(struct soap *soap, const char *tag, struct delegation__destroy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__destroy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__destroy, sizeof(struct delegation__destroy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__destroy, 0, sizeof(struct delegation__destroy), 0, soap_copy_delegation__destroy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__destroy(struct soap *soap, const struct delegation__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__destroy);
	if (soap_out_delegation__destroy(soap, tag?tag:"delegation:destroy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__destroy * SOAP_FMAC4 soap_get_delegation__destroy(struct soap *soap, struct delegation__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__destroy * SOAP_FMAC2 soap_instantiate_delegation__destroy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__destroy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__destroy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroy);
		if (size)
			*size = sizeof(struct delegation__destroy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__destroy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__destroy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__destroy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__destroy %p -> %p\n", q, p));
	*(struct delegation__destroy*)p = *(struct delegation__destroy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__destroyResponse(struct soap *soap, struct delegation__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__destroyResponse(struct soap *soap, const struct delegation__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__destroyResponse(struct soap *soap, const char *tag, int id, const struct delegation__destroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__destroyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__destroyResponse * SOAP_FMAC4 soap_in_delegation__destroyResponse(struct soap *soap, const char *tag, struct delegation__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__destroyResponse, sizeof(struct delegation__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__destroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__destroyResponse, 0, sizeof(struct delegation__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__destroyResponse(struct soap *soap, const struct delegation__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__destroyResponse);
	if (soap_out_delegation__destroyResponse(soap, tag?tag:"delegation:destroyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__destroyResponse * SOAP_FMAC4 soap_get_delegation__destroyResponse(struct soap *soap, struct delegation__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__destroyResponse * SOAP_FMAC2 soap_instantiate_delegation__destroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__destroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__destroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroyResponse);
		if (size)
			*size = sizeof(struct delegation__destroyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__destroyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__destroyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__destroyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__destroyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__destroyResponse %p -> %p\n", q, p));
	*(struct delegation__destroyResponse*)p = *(struct delegation__destroyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getTerminationTime(struct soap *soap, struct delegation__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getTerminationTime(struct soap *soap, const struct delegation__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getTerminationTime(struct soap *soap, const char *tag, int id, const struct delegation__getTerminationTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getTerminationTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getTerminationTime * SOAP_FMAC4 soap_in_delegation__getTerminationTime(struct soap *soap, const char *tag, struct delegation__getTerminationTime *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getTerminationTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getTerminationTime, sizeof(struct delegation__getTerminationTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getTerminationTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getTerminationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getTerminationTime, 0, sizeof(struct delegation__getTerminationTime), 0, soap_copy_delegation__getTerminationTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getTerminationTime(struct soap *soap, const struct delegation__getTerminationTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getTerminationTime);
	if (soap_out_delegation__getTerminationTime(soap, tag?tag:"delegation:getTerminationTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getTerminationTime * SOAP_FMAC4 soap_get_delegation__getTerminationTime(struct soap *soap, struct delegation__getTerminationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getTerminationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getTerminationTime * SOAP_FMAC2 soap_instantiate_delegation__getTerminationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getTerminationTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getTerminationTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTime);
		if (size)
			*size = sizeof(struct delegation__getTerminationTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getTerminationTime);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getTerminationTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getTerminationTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getTerminationTime %p -> %p\n", q, p));
	*(struct delegation__getTerminationTime*)p = *(struct delegation__getTerminationTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getTerminationTimeResponse(struct soap *soap, struct delegation__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->_getTerminationTimeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getTerminationTimeResponse(struct soap *soap, const struct delegation__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getTerminationTimeResponse(struct soap *soap, const char *tag, int id, const struct delegation__getTerminationTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getTerminationTimeResponse), type))
		return soap->error;
	if (soap_out_time(soap, "getTerminationTimeReturn", -1, &a->_getTerminationTimeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getTerminationTimeResponse * SOAP_FMAC4 soap_in_delegation__getTerminationTimeResponse(struct soap *soap, const char *tag, struct delegation__getTerminationTimeResponse *a, const char *type)
{
	size_t soap_flag__getTerminationTimeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getTerminationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getTerminationTimeResponse, sizeof(struct delegation__getTerminationTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getTerminationTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTerminationTimeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_getTerminationTimeReturn, "xsd:dateTime"))
				{	soap_flag__getTerminationTimeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getTerminationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getTerminationTimeResponse, 0, sizeof(struct delegation__getTerminationTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getTerminationTimeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getTerminationTimeResponse(struct soap *soap, const struct delegation__getTerminationTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getTerminationTimeResponse);
	if (soap_out_delegation__getTerminationTimeResponse(soap, tag?tag:"delegation:getTerminationTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getTerminationTimeResponse * SOAP_FMAC4 soap_get_delegation__getTerminationTimeResponse(struct soap *soap, struct delegation__getTerminationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getTerminationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getTerminationTimeResponse * SOAP_FMAC2 soap_instantiate_delegation__getTerminationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getTerminationTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getTerminationTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTimeResponse);
		if (size)
			*size = sizeof(struct delegation__getTerminationTimeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getTerminationTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getTerminationTimeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getTerminationTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getTerminationTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getTerminationTimeResponse %p -> %p\n", q, p));
	*(struct delegation__getTerminationTimeResponse*)p = *(struct delegation__getTerminationTimeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__putProxy(struct soap *soap, struct delegation__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
	soap_default_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__putProxy(struct soap *soap, const struct delegation__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
	soap_embedded(soap, &a->_proxy, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__putProxy(struct soap *soap, const char *tag, int id, const struct delegation__putProxy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__putProxy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "proxy", -1, &a->_proxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__putProxy * SOAP_FMAC4 soap_in_delegation__putProxy(struct soap *soap, const char *tag, struct delegation__putProxy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	size_t soap_flag__proxy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__putProxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__putProxy, sizeof(struct delegation__putProxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__putProxy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap_flag__proxy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_proxy, "xsd:string"))
				{	soap_flag__proxy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__putProxy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__putProxy, 0, sizeof(struct delegation__putProxy), 0, soap_copy_delegation__putProxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0 || soap_flag__proxy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__putProxy(struct soap *soap, const struct delegation__putProxy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__putProxy);
	if (soap_out_delegation__putProxy(soap, tag?tag:"delegation:putProxy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__putProxy * SOAP_FMAC4 soap_get_delegation__putProxy(struct soap *soap, struct delegation__putProxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__putProxy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__putProxy * SOAP_FMAC2 soap_instantiate_delegation__putProxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__putProxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__putProxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxy);
		if (size)
			*size = sizeof(struct delegation__putProxy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__putProxy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__putProxy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__putProxy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__putProxy %p -> %p\n", q, p));
	*(struct delegation__putProxy*)p = *(struct delegation__putProxy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__putProxyResponse(struct soap *soap, struct delegation__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__putProxyResponse(struct soap *soap, const struct delegation__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__putProxyResponse(struct soap *soap, const char *tag, int id, const struct delegation__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__putProxyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__putProxyResponse * SOAP_FMAC4 soap_in_delegation__putProxyResponse(struct soap *soap, const char *tag, struct delegation__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__putProxyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__putProxyResponse, sizeof(struct delegation__putProxyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__putProxyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__putProxyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__putProxyResponse, 0, sizeof(struct delegation__putProxyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__putProxyResponse(struct soap *soap, const struct delegation__putProxyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__putProxyResponse);
	if (soap_out_delegation__putProxyResponse(soap, tag?tag:"delegation:putProxyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__putProxyResponse * SOAP_FMAC4 soap_get_delegation__putProxyResponse(struct soap *soap, struct delegation__putProxyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__putProxyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__putProxyResponse * SOAP_FMAC2 soap_instantiate_delegation__putProxyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__putProxyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__putProxyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxyResponse);
		if (size)
			*size = sizeof(struct delegation__putProxyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__putProxyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__putProxyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__putProxyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__putProxyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__putProxyResponse %p -> %p\n", q, p));
	*(struct delegation__putProxyResponse*)p = *(struct delegation__putProxyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__renewProxyReq(struct soap *soap, struct delegation__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__renewProxyReq(struct soap *soap, const struct delegation__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__renewProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__renewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__renewProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__renewProxyReq * SOAP_FMAC4 soap_in_delegation__renewProxyReq(struct soap *soap, const char *tag, struct delegation__renewProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__renewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__renewProxyReq, sizeof(struct delegation__renewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__renewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__renewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__renewProxyReq, 0, sizeof(struct delegation__renewProxyReq), 0, soap_copy_delegation__renewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__renewProxyReq(struct soap *soap, const struct delegation__renewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__renewProxyReq);
	if (soap_out_delegation__renewProxyReq(soap, tag?tag:"delegation:renewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__renewProxyReq * SOAP_FMAC4 soap_get_delegation__renewProxyReq(struct soap *soap, struct delegation__renewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__renewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__renewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__renewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__renewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__renewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReq);
		if (size)
			*size = sizeof(struct delegation__renewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__renewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__renewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__renewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__renewProxyReq %p -> %p\n", q, p));
	*(struct delegation__renewProxyReq*)p = *(struct delegation__renewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__renewProxyReqResponse(struct soap *soap, struct delegation__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__renewProxyReqResponse(struct soap *soap, const struct delegation__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_renewProxyReqReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__renewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__renewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__renewProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "renewProxyReqReturn", -1, &a->_renewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__renewProxyReqResponse * SOAP_FMAC4 soap_in_delegation__renewProxyReqResponse(struct soap *soap, const char *tag, struct delegation__renewProxyReqResponse *a, const char *type)
{
	size_t soap_flag__renewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__renewProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__renewProxyReqResponse, sizeof(struct delegation__renewProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__renewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__renewProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_renewProxyReqReturn, "xsd:string"))
				{	soap_flag__renewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__renewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__renewProxyReqResponse, 0, sizeof(struct delegation__renewProxyReqResponse), 0, soap_copy_delegation__renewProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__renewProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__renewProxyReqResponse(struct soap *soap, const struct delegation__renewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__renewProxyReqResponse);
	if (soap_out_delegation__renewProxyReqResponse(soap, tag?tag:"delegation:renewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__renewProxyReqResponse * SOAP_FMAC4 soap_get_delegation__renewProxyReqResponse(struct soap *soap, struct delegation__renewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__renewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__renewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__renewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__renewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__renewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__renewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__renewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__renewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__renewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__renewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__renewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__renewProxyReqResponse*)p = *(struct delegation__renewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getNewProxyReq(struct soap *soap, struct delegation__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getNewProxyReq(struct soap *soap, const struct delegation__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getNewProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getNewProxyReq), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getNewProxyReq * SOAP_FMAC4 soap_in_delegation__getNewProxyReq(struct soap *soap, const char *tag, struct delegation__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getNewProxyReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getNewProxyReq, sizeof(struct delegation__getNewProxyReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getNewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getNewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getNewProxyReq, 0, sizeof(struct delegation__getNewProxyReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getNewProxyReq(struct soap *soap, const struct delegation__getNewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getNewProxyReq);
	if (soap_out_delegation__getNewProxyReq(soap, tag?tag:"delegation:getNewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getNewProxyReq * SOAP_FMAC4 soap_get_delegation__getNewProxyReq(struct soap *soap, struct delegation__getNewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getNewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getNewProxyReq * SOAP_FMAC2 soap_instantiate_delegation__getNewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getNewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getNewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReq);
		if (size)
			*size = sizeof(struct delegation__getNewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getNewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getNewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getNewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getNewProxyReq %p -> %p\n", q, p));
	*(struct delegation__getNewProxyReq*)p = *(struct delegation__getNewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getNewProxyReqResponse(struct soap *soap, struct delegation__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getNewProxyReqReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getNewProxyReqResponse(struct soap *soap, const struct delegation__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodelegation__NewProxyReq(soap, &a->getNewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getNewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__getNewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getNewProxyReqResponse), type))
		return soap->error;
	if (soap_out_PointerTodelegation__NewProxyReq(soap, "getNewProxyReqReturn", -1, &a->getNewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getNewProxyReqResponse * SOAP_FMAC4 soap_in_delegation__getNewProxyReqResponse(struct soap *soap, const char *tag, struct delegation__getNewProxyReqResponse *a, const char *type)
{
	size_t soap_flag_getNewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getNewProxyReqResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getNewProxyReqResponse, sizeof(struct delegation__getNewProxyReqResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getNewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getNewProxyReqReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodelegation__NewProxyReq(soap, "getNewProxyReqReturn", &a->getNewProxyReqReturn, "delegation:NewProxyReq"))
				{	soap_flag_getNewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getNewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getNewProxyReqResponse, 0, sizeof(struct delegation__getNewProxyReqResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getNewProxyReqResponse(struct soap *soap, const struct delegation__getNewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getNewProxyReqResponse);
	if (soap_out_delegation__getNewProxyReqResponse(soap, tag?tag:"delegation:getNewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getNewProxyReqResponse * SOAP_FMAC4 soap_get_delegation__getNewProxyReqResponse(struct soap *soap, struct delegation__getNewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getNewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getNewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__getNewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getNewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getNewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__getNewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getNewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getNewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getNewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getNewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getNewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__getNewProxyReqResponse*)p = *(struct delegation__getNewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getProxyReq(struct soap *soap, struct delegation__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getProxyReq(struct soap *soap, const struct delegation__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getProxyReq(struct soap *soap, const char *tag, int id, const struct delegation__getProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getProxyReq * SOAP_FMAC4 soap_in_delegation__getProxyReq(struct soap *soap, const char *tag, struct delegation__getProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getProxyReq, sizeof(struct delegation__getProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getProxyReq, 0, sizeof(struct delegation__getProxyReq), 0, soap_copy_delegation__getProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getProxyReq(struct soap *soap, const struct delegation__getProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getProxyReq);
	if (soap_out_delegation__getProxyReq(soap, tag?tag:"delegation:getProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getProxyReq * SOAP_FMAC4 soap_get_delegation__getProxyReq(struct soap *soap, struct delegation__getProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getProxyReq * SOAP_FMAC2 soap_instantiate_delegation__getProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReq);
		if (size)
			*size = sizeof(struct delegation__getProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getProxyReq %p -> %p\n", q, p));
	*(struct delegation__getProxyReq*)p = *(struct delegation__getProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getProxyReqResponse(struct soap *soap, struct delegation__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getProxyReqResponse(struct soap *soap, const struct delegation__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getProxyReqReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation__getProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getProxyReqReturn", -1, &a->_getProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getProxyReqResponse * SOAP_FMAC4 soap_in_delegation__getProxyReqResponse(struct soap *soap, const char *tag, struct delegation__getProxyReqResponse *a, const char *type)
{
	size_t soap_flag__getProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getProxyReqResponse, sizeof(struct delegation__getProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getProxyReqReturn, "xsd:string"))
				{	soap_flag__getProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getProxyReqResponse, 0, sizeof(struct delegation__getProxyReqResponse), 0, soap_copy_delegation__getProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getProxyReqResponse(struct soap *soap, const struct delegation__getProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getProxyReqResponse);
	if (soap_out_delegation__getProxyReqResponse(soap, tag?tag:"delegation:getProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getProxyReqResponse * SOAP_FMAC4 soap_get_delegation__getProxyReqResponse(struct soap *soap, struct delegation__getProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation__getProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation__getProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation__getProxyReqResponse*)p = *(struct delegation__getProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getServiceMetadata(struct soap *soap, struct delegation__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getServiceMetadata(struct soap *soap, const struct delegation__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_key, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getServiceMetadata(struct soap *soap, const char *tag, int id, const struct delegation__getServiceMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getServiceMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getServiceMetadata * SOAP_FMAC4 soap_in_delegation__getServiceMetadata(struct soap *soap, const char *tag, struct delegation__getServiceMetadata *a, const char *type)
{
	size_t soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getServiceMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getServiceMetadata, sizeof(struct delegation__getServiceMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getServiceMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getServiceMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getServiceMetadata, 0, sizeof(struct delegation__getServiceMetadata), 0, soap_copy_delegation__getServiceMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getServiceMetadata(struct soap *soap, const struct delegation__getServiceMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getServiceMetadata);
	if (soap_out_delegation__getServiceMetadata(soap, tag?tag:"delegation:getServiceMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getServiceMetadata * SOAP_FMAC4 soap_get_delegation__getServiceMetadata(struct soap *soap, struct delegation__getServiceMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getServiceMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getServiceMetadata * SOAP_FMAC2 soap_instantiate_delegation__getServiceMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getServiceMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getServiceMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadata);
		if (size)
			*size = sizeof(struct delegation__getServiceMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getServiceMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getServiceMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getServiceMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getServiceMetadata %p -> %p\n", q, p));
	*(struct delegation__getServiceMetadata*)p = *(struct delegation__getServiceMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getServiceMetadataResponse(struct soap *soap, struct delegation__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getServiceMetadataResponse(struct soap *soap, const struct delegation__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getServiceMetadataReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getServiceMetadataResponse(struct soap *soap, const char *tag, int id, const struct delegation__getServiceMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getServiceMetadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getServiceMetadataReturn", -1, &a->_getServiceMetadataReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getServiceMetadataResponse * SOAP_FMAC4 soap_in_delegation__getServiceMetadataResponse(struct soap *soap, const char *tag, struct delegation__getServiceMetadataResponse *a, const char *type)
{
	size_t soap_flag__getServiceMetadataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getServiceMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getServiceMetadataResponse, sizeof(struct delegation__getServiceMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getServiceMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getServiceMetadataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getServiceMetadataReturn, "xsd:string"))
				{	soap_flag__getServiceMetadataReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getServiceMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getServiceMetadataResponse, 0, sizeof(struct delegation__getServiceMetadataResponse), 0, soap_copy_delegation__getServiceMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getServiceMetadataReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getServiceMetadataResponse(struct soap *soap, const struct delegation__getServiceMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getServiceMetadataResponse);
	if (soap_out_delegation__getServiceMetadataResponse(soap, tag?tag:"delegation:getServiceMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getServiceMetadataResponse * SOAP_FMAC4 soap_get_delegation__getServiceMetadataResponse(struct soap *soap, struct delegation__getServiceMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getServiceMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getServiceMetadataResponse * SOAP_FMAC2 soap_instantiate_delegation__getServiceMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getServiceMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getServiceMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadataResponse);
		if (size)
			*size = sizeof(struct delegation__getServiceMetadataResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getServiceMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getServiceMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getServiceMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getServiceMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getServiceMetadataResponse %p -> %p\n", q, p));
	*(struct delegation__getServiceMetadataResponse*)p = *(struct delegation__getServiceMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getInterfaceVersion(struct soap *soap, struct delegation__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getInterfaceVersion(struct soap *soap, const struct delegation__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getInterfaceVersion(struct soap *soap, const char *tag, int id, const struct delegation__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getInterfaceVersion * SOAP_FMAC4 soap_in_delegation__getInterfaceVersion(struct soap *soap, const char *tag, struct delegation__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getInterfaceVersion, sizeof(struct delegation__getInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getInterfaceVersion, 0, sizeof(struct delegation__getInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getInterfaceVersion(struct soap *soap, const struct delegation__getInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getInterfaceVersion);
	if (soap_out_delegation__getInterfaceVersion(soap, tag?tag:"delegation:getInterfaceVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getInterfaceVersion * SOAP_FMAC4 soap_get_delegation__getInterfaceVersion(struct soap *soap, struct delegation__getInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getInterfaceVersion * SOAP_FMAC2 soap_instantiate_delegation__getInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersion);
		if (size)
			*size = sizeof(struct delegation__getInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getInterfaceVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getInterfaceVersion %p -> %p\n", q, p));
	*(struct delegation__getInterfaceVersion*)p = *(struct delegation__getInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getInterfaceVersionResponse(struct soap *soap, struct delegation__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getInterfaceVersionResponse(struct soap *soap, const struct delegation__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getInterfaceVersionReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct delegation__getInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getInterfaceVersionReturn", -1, &a->getInterfaceVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getInterfaceVersionResponse * SOAP_FMAC4 soap_in_delegation__getInterfaceVersionResponse(struct soap *soap, const char *tag, struct delegation__getInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_getInterfaceVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getInterfaceVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse, sizeof(struct delegation__getInterfaceVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInterfaceVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getInterfaceVersionReturn", &a->getInterfaceVersionReturn, "xsd:string"))
				{	soap_flag_getInterfaceVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse, 0, sizeof(struct delegation__getInterfaceVersionResponse), 0, soap_copy_delegation__getInterfaceVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getInterfaceVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getInterfaceVersionResponse(struct soap *soap, const struct delegation__getInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse);
	if (soap_out_delegation__getInterfaceVersionResponse(soap, tag?tag:"delegation:getInterfaceVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getInterfaceVersionResponse * SOAP_FMAC4 soap_get_delegation__getInterfaceVersionResponse(struct soap *soap, struct delegation__getInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getInterfaceVersionResponse * SOAP_FMAC2 soap_instantiate_delegation__getInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersionResponse);
		if (size)
			*size = sizeof(struct delegation__getInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getInterfaceVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getInterfaceVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct delegation__getInterfaceVersionResponse*)p = *(struct delegation__getInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getVersion(struct soap *soap, struct delegation__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getVersion(struct soap *soap, const struct delegation__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getVersion(struct soap *soap, const char *tag, int id, const struct delegation__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getVersion * SOAP_FMAC4 soap_in_delegation__getVersion(struct soap *soap, const char *tag, struct delegation__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getVersion, sizeof(struct delegation__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getVersion, 0, sizeof(struct delegation__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getVersion(struct soap *soap, const struct delegation__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getVersion);
	if (soap_out_delegation__getVersion(soap, tag?tag:"delegation:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getVersion * SOAP_FMAC4 soap_get_delegation__getVersion(struct soap *soap, struct delegation__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getVersion * SOAP_FMAC2 soap_instantiate_delegation__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersion);
		if (size)
			*size = sizeof(struct delegation__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getVersion %p -> %p\n", q, p));
	*(struct delegation__getVersion*)p = *(struct delegation__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation__getVersionResponse(struct soap *soap, struct delegation__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation__getVersionResponse(struct soap *soap, const struct delegation__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getVersionReturn, SOAP_TYPE_fts3_std__string);
	soap_serialize_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation__getVersionResponse(struct soap *soap, const char *tag, int id, const struct delegation__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_delegation__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getVersionReturn", -1, &a->getVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation__getVersionResponse * SOAP_FMAC4 soap_in_delegation__getVersionResponse(struct soap *soap, const char *tag, struct delegation__getVersionResponse *a, const char *type)
{
	size_t soap_flag_getVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_delegation__getVersionResponse, sizeof(struct delegation__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getVersionReturn", &a->getVersionReturn, "xsd:string"))
				{	soap_flag_getVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_delegation__getVersionResponse, 0, sizeof(struct delegation__getVersionResponse), 0, soap_copy_delegation__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation__getVersionResponse(struct soap *soap, const struct delegation__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_delegation__getVersionResponse);
	if (soap_out_delegation__getVersionResponse(soap, tag?tag:"delegation:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation__getVersionResponse * SOAP_FMAC4 soap_get_delegation__getVersionResponse(struct soap *soap, struct delegation__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation__getVersionResponse * SOAP_FMAC2 soap_instantiate_delegation__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_delegation__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersionResponse);
		if (size)
			*size = sizeof(struct delegation__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation__getVersionResponse %p -> %p\n", q, p));
	*(struct delegation__getVersionResponse*)p = *(struct delegation__getVersionResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->delegation__DelegationException = NULL;
	a->config__AuthorizationExceptionElement = NULL;
	a->config__InternalExceptionElement = NULL;
	a->config__InvalidConfigurationExceptionElement = NULL;
	a->config__ServiceBusyExceptionElement = NULL;
	a->tns3__AuthorizationExceptionElement = NULL;
	a->tns3__CannotCancelExceptionElement = NULL;
	a->tns3__ExistsExceptionElement = NULL;
	a->tns3__InternalExceptionElement = NULL;
	a->tns3__InvalidArgumentExceptionElement = NULL;
	a->tns3__NotExistsExceptionElement = NULL;
	a->tns3__ServiceBusyExceptionElement = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_delegation__DelegationException(soap, &a->delegation__DelegationException);
	soap_serialize_PointerToconfig__AuthorizationException(soap, &a->config__AuthorizationExceptionElement);
	soap_serialize_PointerToconfig__InternalException(soap, &a->config__InternalExceptionElement);
	soap_serialize_PointerToconfig__InvalidConfigurationException(soap, &a->config__InvalidConfigurationExceptionElement);
	soap_serialize_PointerToconfig__ServiceBusyException(soap, &a->config__ServiceBusyExceptionElement);
	soap_serialize_PointerTotns3__AuthorizationException(soap, &a->tns3__AuthorizationExceptionElement);
	soap_serialize_PointerTotns3__CannotCancelException(soap, &a->tns3__CannotCancelExceptionElement);
	soap_serialize_PointerTotns3__ExistsException(soap, &a->tns3__ExistsExceptionElement);
	soap_serialize_PointerTotns3__InternalException(soap, &a->tns3__InternalExceptionElement);
	soap_serialize_PointerTotns3__InvalidArgumentException(soap, &a->tns3__InvalidArgumentExceptionElement);
	soap_serialize_PointerTotns3__NotExistsException(soap, &a->tns3__NotExistsExceptionElement);
	soap_serialize_PointerTotns3__ServiceBusyException(soap, &a->tns3__ServiceBusyExceptionElement);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fts3_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_delegation__DelegationException(soap, "delegation:DelegationException", -1, &a->delegation__DelegationException, ""))
		return soap->error;
	if (soap_out_PointerToconfig__AuthorizationException(soap, "config:AuthorizationExceptionElement", -1, &a->config__AuthorizationExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerToconfig__InternalException(soap, "config:InternalExceptionElement", -1, &a->config__InternalExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerToconfig__InvalidConfigurationException(soap, "config:InvalidConfigurationExceptionElement", -1, &a->config__InvalidConfigurationExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerToconfig__ServiceBusyException(soap, "config:ServiceBusyExceptionElement", -1, &a->config__ServiceBusyExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__AuthorizationException(soap, "tns3:AuthorizationExceptionElement", -1, &a->tns3__AuthorizationExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__CannotCancelException(soap, "tns3:CannotCancelExceptionElement", -1, &a->tns3__CannotCancelExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__ExistsException(soap, "tns3:ExistsExceptionElement", -1, &a->tns3__ExistsExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__InternalException(soap, "tns3:InternalExceptionElement", -1, &a->tns3__InternalExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__InvalidArgumentException(soap, "tns3:InvalidArgumentExceptionElement", -1, &a->tns3__InvalidArgumentExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__NotExistsException(soap, "tns3:NotExistsExceptionElement", -1, &a->tns3__NotExistsExceptionElement, ""))
		return soap->error;
	if (soap_out_PointerTotns3__ServiceBusyException(soap, "tns3:ServiceBusyExceptionElement", -1, &a->tns3__ServiceBusyExceptionElement, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_delegation__DelegationException = 1;
	size_t soap_flag_config__AuthorizationExceptionElement = 1;
	size_t soap_flag_config__InternalExceptionElement = 1;
	size_t soap_flag_config__InvalidConfigurationExceptionElement = 1;
	size_t soap_flag_config__ServiceBusyExceptionElement = 1;
	size_t soap_flag_tns3__AuthorizationExceptionElement = 1;
	size_t soap_flag_tns3__CannotCancelExceptionElement = 1;
	size_t soap_flag_tns3__ExistsExceptionElement = 1;
	size_t soap_flag_tns3__InternalExceptionElement = 1;
	size_t soap_flag_tns3__InvalidArgumentExceptionElement = 1;
	size_t soap_flag_tns3__NotExistsExceptionElement = 1;
	size_t soap_flag_tns3__ServiceBusyExceptionElement = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delegation__DelegationException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_delegation__DelegationException(soap, "delegation:DelegationException", &a->delegation__DelegationException, ""))
				{	soap_flag_delegation__DelegationException--;
					continue;
				}
			if (soap_flag_config__AuthorizationExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__AuthorizationException(soap, "config:AuthorizationExceptionElement", &a->config__AuthorizationExceptionElement, "config:AuthorizationException"))
				{	soap_flag_config__AuthorizationExceptionElement--;
					continue;
				}
			if (soap_flag_config__InternalExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__InternalException(soap, "config:InternalExceptionElement", &a->config__InternalExceptionElement, "config:InternalException"))
				{	soap_flag_config__InternalExceptionElement--;
					continue;
				}
			if (soap_flag_config__InvalidConfigurationExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__InvalidConfigurationException(soap, "config:InvalidConfigurationExceptionElement", &a->config__InvalidConfigurationExceptionElement, "config:InvalidConfigurationException"))
				{	soap_flag_config__InvalidConfigurationExceptionElement--;
					continue;
				}
			if (soap_flag_config__ServiceBusyExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToconfig__ServiceBusyException(soap, "config:ServiceBusyExceptionElement", &a->config__ServiceBusyExceptionElement, "config:ServiceBusyException"))
				{	soap_flag_config__ServiceBusyExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__AuthorizationExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__AuthorizationException(soap, "tns3:AuthorizationExceptionElement", &a->tns3__AuthorizationExceptionElement, "tns3:AuthorizationException"))
				{	soap_flag_tns3__AuthorizationExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__CannotCancelExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__CannotCancelException(soap, "tns3:CannotCancelExceptionElement", &a->tns3__CannotCancelExceptionElement, "tns3:CannotCancelException"))
				{	soap_flag_tns3__CannotCancelExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__ExistsExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__ExistsException(soap, "tns3:ExistsExceptionElement", &a->tns3__ExistsExceptionElement, "tns3:ExistsException"))
				{	soap_flag_tns3__ExistsExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__InternalExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__InternalException(soap, "tns3:InternalExceptionElement", &a->tns3__InternalExceptionElement, "tns3:InternalException"))
				{	soap_flag_tns3__InternalExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__InvalidArgumentExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__InvalidArgumentException(soap, "tns3:InvalidArgumentExceptionElement", &a->tns3__InvalidArgumentExceptionElement, "tns3:InvalidArgumentException"))
				{	soap_flag_tns3__InvalidArgumentExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__NotExistsExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__NotExistsException(soap, "tns3:NotExistsExceptionElement", &a->tns3__NotExistsExceptionElement, "tns3:NotExistsException"))
				{	soap_flag_tns3__NotExistsExceptionElement--;
					continue;
				}
			if (soap_flag_tns3__ServiceBusyExceptionElement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns3__ServiceBusyException(soap, "tns3:ServiceBusyExceptionElement", &a->tns3__ServiceBusyExceptionElement, "tns3:ServiceBusyException"))
				{	soap_flag_tns3__ServiceBusyExceptionElement--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_fts3__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_fts3__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_fts3__xop__Include);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fts3__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fts3__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_fts3__xop__Include);
	if (soap_out__xop__Include(soap, tag?tag:"xop:Include", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3__xop__Include, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _xop__Include);
		if (size)
			*size = sizeof(struct _xop__Include);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _xop__Include[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _xop__Include);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _xop__Include*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xop__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xop__Include %p -> %p\n", q, p));
	*(struct _xop__Include*)p = *(struct _xop__Include*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolog__LogInternal(struct soap *soap, log__LogInternal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_log__LogInternal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolog__LogInternal(struct soap *soap, const char *tag, int id, log__LogInternal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_log__LogInternal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 log__LogInternal ** SOAP_FMAC4 soap_in_PointerTolog__LogInternal(struct soap *soap, const char *tag, log__LogInternal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (log__LogInternal **)soap_malloc(soap, sizeof(log__LogInternal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (log__LogInternal *)soap_instantiate_log__LogInternal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	log__LogInternal ** p = (log__LogInternal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_log__LogInternal, sizeof(log__LogInternal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolog__LogInternal(struct soap *soap, log__LogInternal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTolog__LogInternal);
	if (soap_out_PointerTolog__LogInternal(soap, tag?tag:"log:LogInternal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 log__LogInternal ** SOAP_FMAC4 soap_get_PointerTolog__LogInternal(struct soap *soap, log__LogInternal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolog__LogInternal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__Roles(struct soap *soap, tns3__Roles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__Roles))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__Roles(struct soap *soap, const char *tag, int id, tns3__Roles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__Roles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__Roles ** SOAP_FMAC4 soap_in_PointerTotns3__Roles(struct soap *soap, const char *tag, tns3__Roles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__Roles **)soap_malloc(soap, sizeof(tns3__Roles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__Roles *)soap_instantiate_tns3__Roles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__Roles ** p = (tns3__Roles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__Roles, sizeof(tns3__Roles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__Roles(struct soap *soap, tns3__Roles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__Roles);
	if (soap_out_PointerTotns3__Roles(soap, tag?tag:"tns3:Roles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__Roles ** SOAP_FMAC4 soap_get_PointerTotns3__Roles(struct soap *soap, tns3__Roles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__Roles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJobSummary2(struct soap *soap, tns3__TransferJobSummary2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJobSummary2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJobSummary2(struct soap *soap, const char *tag, int id, tns3__TransferJobSummary2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJobSummary2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJobSummary2 ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJobSummary2(struct soap *soap, const char *tag, tns3__TransferJobSummary2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJobSummary2 **)soap_malloc(soap, sizeof(tns3__TransferJobSummary2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJobSummary2 *)soap_instantiate_tns3__TransferJobSummary2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJobSummary2 ** p = (tns3__TransferJobSummary2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobSummary2, sizeof(tns3__TransferJobSummary2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJobSummary2(struct soap *soap, tns3__TransferJobSummary2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary2);
	if (soap_out_PointerTotns3__TransferJobSummary2(soap, tag?tag:"tns3:TransferJobSummary2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJobSummary2 ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJobSummary2(struct soap *soap, tns3__TransferJobSummary2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJobSummary2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJobSummary(struct soap *soap, tns3__TransferJobSummary *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJobSummary))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJobSummary(struct soap *soap, const char *tag, int id, tns3__TransferJobSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJobSummary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJobSummary ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJobSummary(struct soap *soap, const char *tag, tns3__TransferJobSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJobSummary **)soap_malloc(soap, sizeof(tns3__TransferJobSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJobSummary *)soap_instantiate_tns3__TransferJobSummary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJobSummary ** p = (tns3__TransferJobSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobSummary, sizeof(tns3__TransferJobSummary), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (tns3__TransferJobSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobSummary2, sizeof(tns3__TransferJobSummary2), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJobSummary(struct soap *soap, tns3__TransferJobSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJobSummary);
	if (soap_out_PointerTotns3__TransferJobSummary(soap, tag?tag:"tns3:TransferJobSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJobSummary ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJobSummary(struct soap *soap, tns3__TransferJobSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJobSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, int id, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** SOAP_FMAC4 soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **)soap_malloc(soap, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** p = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2);
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag?tag:"impltns:ArrayOf_tns3_FileTransferStatus2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 ** SOAP_FMAC4 soap_get_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, int id, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** SOAP_FMAC4 soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus **)soap_malloc(soap, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** p = (impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus, sizeof(impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus);
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag?tag:"impltns:ArrayOf_tns3_FileTransferStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus ** SOAP_FMAC4 soap_get_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREFileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, impltns__ArrayOf_USCOREsoapenc_USCOREstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, int id, impltns__ArrayOf_USCOREsoapenc_USCOREstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREsoapenc_USCOREstring ** SOAP_FMAC4 soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREsoapenc_USCOREstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (impltns__ArrayOf_USCOREsoapenc_USCOREstring **)soap_malloc(soap, sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (impltns__ArrayOf_USCOREsoapenc_USCOREstring *)soap_instantiate_impltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	impltns__ArrayOf_USCOREsoapenc_USCOREstring ** p = (impltns__ArrayOf_USCOREsoapenc_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREsoapenc_USCOREstring, sizeof(impltns__ArrayOf_USCOREsoapenc_USCOREstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, impltns__ArrayOf_USCOREsoapenc_USCOREstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring);
	if (soap_out_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag?tag:"impltns:ArrayOf_soapenc_string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREsoapenc_USCOREstring ** SOAP_FMAC4 soap_get_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(struct soap *soap, impltns__ArrayOf_USCOREsoapenc_USCOREstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToimpltns__ArrayOf_USCOREsoapenc_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREJobStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, int id, impltns__ArrayOf_USCOREtns3_USCOREJobStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREJobStatus ** SOAP_FMAC4 soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, const char *tag, impltns__ArrayOf_USCOREtns3_USCOREJobStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (impltns__ArrayOf_USCOREtns3_USCOREJobStatus **)soap_malloc(soap, sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (impltns__ArrayOf_USCOREtns3_USCOREJobStatus *)soap_instantiate_impltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	impltns__ArrayOf_USCOREtns3_USCOREJobStatus ** p = (impltns__ArrayOf_USCOREtns3_USCOREJobStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_impltns__ArrayOf_USCOREtns3_USCOREJobStatus, sizeof(impltns__ArrayOf_USCOREtns3_USCOREJobStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREJobStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus);
	if (soap_out_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag?tag:"impltns:ArrayOf_tns3_JobStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 impltns__ArrayOf_USCOREtns3_USCOREJobStatus ** SOAP_FMAC4 soap_get_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(struct soap *soap, impltns__ArrayOf_USCOREtns3_USCOREJobStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToimpltns__ArrayOf_USCOREtns3_USCOREJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJob3(struct soap *soap, tns3__TransferJob3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJob3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJob3(struct soap *soap, const char *tag, int id, tns3__TransferJob3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJob3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJob3 ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJob3(struct soap *soap, const char *tag, tns3__TransferJob3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJob3 **)soap_malloc(soap, sizeof(tns3__TransferJob3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJob3 *)soap_instantiate_tns3__TransferJob3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJob3 ** p = (tns3__TransferJob3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJob3, sizeof(tns3__TransferJob3), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJob3(struct soap *soap, tns3__TransferJob3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJob3);
	if (soap_out_PointerTotns3__TransferJob3(soap, tag?tag:"tns3:TransferJob3", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJob3 ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJob3(struct soap *soap, tns3__TransferJob3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJob3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJob2(struct soap *soap, tns3__TransferJob2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJob2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJob2(struct soap *soap, const char *tag, int id, tns3__TransferJob2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJob2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJob2 ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJob2(struct soap *soap, const char *tag, tns3__TransferJob2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJob2 **)soap_malloc(soap, sizeof(tns3__TransferJob2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJob2 *)soap_instantiate_tns3__TransferJob2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJob2 ** p = (tns3__TransferJob2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJob2, sizeof(tns3__TransferJob2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJob2(struct soap *soap, tns3__TransferJob2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJob2);
	if (soap_out_PointerTotns3__TransferJob2(soap, tag?tag:"tns3:TransferJob2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJob2 ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJob2(struct soap *soap, tns3__TransferJob2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJob2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJob(struct soap *soap, tns3__TransferJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJob(struct soap *soap, const char *tag, int id, tns3__TransferJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJob ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJob(struct soap *soap, const char *tag, tns3__TransferJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJob **)soap_malloc(soap, sizeof(tns3__TransferJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJob *)soap_instantiate_tns3__TransferJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJob ** p = (tns3__TransferJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJob, sizeof(tns3__TransferJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJob(struct soap *soap, tns3__TransferJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJob);
	if (soap_out_PointerTotns3__TransferJob(soap, tag?tag:"tns3:TransferJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJob ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJob(struct soap *soap, tns3__TransferJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToconfig__Configuration(struct soap *soap, config__Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_config__Configuration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToconfig__Configuration(struct soap *soap, const char *tag, int id, config__Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_config__Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 config__Configuration ** SOAP_FMAC4 soap_in_PointerToconfig__Configuration(struct soap *soap, const char *tag, config__Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (config__Configuration **)soap_malloc(soap, sizeof(config__Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (config__Configuration *)soap_instantiate_config__Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	config__Configuration ** p = (config__Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_config__Configuration, sizeof(config__Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToconfig__Configuration(struct soap *soap, config__Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToconfig__Configuration);
	if (soap_out_PointerToconfig__Configuration(soap, tag?tag:"config:Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 config__Configuration ** SOAP_FMAC4 soap_get_PointerToconfig__Configuration(struct soap *soap, config__Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToconfig__Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_delegation__NewProxyReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodelegation__NewProxyReq(struct soap *soap, const char *tag, int id, delegation__NewProxyReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_delegation__NewProxyReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 delegation__NewProxyReq ** SOAP_FMAC4 soap_in_PointerTodelegation__NewProxyReq(struct soap *soap, const char *tag, delegation__NewProxyReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (delegation__NewProxyReq **)soap_malloc(soap, sizeof(delegation__NewProxyReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (delegation__NewProxyReq *)soap_instantiate_delegation__NewProxyReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	delegation__NewProxyReq ** p = (delegation__NewProxyReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_delegation__NewProxyReq, sizeof(delegation__NewProxyReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTodelegation__NewProxyReq);
	if (soap_out_PointerTodelegation__NewProxyReq(soap, tag?tag:"delegation:NewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 delegation__NewProxyReq ** SOAP_FMAC4 soap_get_PointerTodelegation__NewProxyReq(struct soap *soap, delegation__NewProxyReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodelegation__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__ServiceBusyException(struct soap *soap, tns3__ServiceBusyException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__ServiceBusyException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__ServiceBusyException(struct soap *soap, const char *tag, int id, tns3__ServiceBusyException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__ServiceBusyException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__ServiceBusyException ** SOAP_FMAC4 soap_in_PointerTotns3__ServiceBusyException(struct soap *soap, const char *tag, tns3__ServiceBusyException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__ServiceBusyException **)soap_malloc(soap, sizeof(tns3__ServiceBusyException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__ServiceBusyException *)soap_instantiate_tns3__ServiceBusyException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__ServiceBusyException ** p = (tns3__ServiceBusyException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__ServiceBusyException, sizeof(tns3__ServiceBusyException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__ServiceBusyException(struct soap *soap, tns3__ServiceBusyException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__ServiceBusyException);
	if (soap_out_PointerTotns3__ServiceBusyException(soap, tag?tag:"tns3:ServiceBusyException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__ServiceBusyException ** SOAP_FMAC4 soap_get_PointerTotns3__ServiceBusyException(struct soap *soap, tns3__ServiceBusyException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__ServiceBusyException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__NotExistsException(struct soap *soap, tns3__NotExistsException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__NotExistsException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__NotExistsException(struct soap *soap, const char *tag, int id, tns3__NotExistsException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__NotExistsException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__NotExistsException ** SOAP_FMAC4 soap_in_PointerTotns3__NotExistsException(struct soap *soap, const char *tag, tns3__NotExistsException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__NotExistsException **)soap_malloc(soap, sizeof(tns3__NotExistsException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__NotExistsException *)soap_instantiate_tns3__NotExistsException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__NotExistsException ** p = (tns3__NotExistsException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__NotExistsException, sizeof(tns3__NotExistsException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__NotExistsException(struct soap *soap, tns3__NotExistsException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__NotExistsException);
	if (soap_out_PointerTotns3__NotExistsException(soap, tag?tag:"tns3:NotExistsException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__NotExistsException ** SOAP_FMAC4 soap_get_PointerTotns3__NotExistsException(struct soap *soap, tns3__NotExistsException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__NotExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__InvalidArgumentException(struct soap *soap, tns3__InvalidArgumentException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__InvalidArgumentException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__InvalidArgumentException(struct soap *soap, const char *tag, int id, tns3__InvalidArgumentException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__InvalidArgumentException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__InvalidArgumentException ** SOAP_FMAC4 soap_in_PointerTotns3__InvalidArgumentException(struct soap *soap, const char *tag, tns3__InvalidArgumentException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__InvalidArgumentException **)soap_malloc(soap, sizeof(tns3__InvalidArgumentException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__InvalidArgumentException *)soap_instantiate_tns3__InvalidArgumentException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__InvalidArgumentException ** p = (tns3__InvalidArgumentException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__InvalidArgumentException, sizeof(tns3__InvalidArgumentException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__InvalidArgumentException(struct soap *soap, tns3__InvalidArgumentException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__InvalidArgumentException);
	if (soap_out_PointerTotns3__InvalidArgumentException(soap, tag?tag:"tns3:InvalidArgumentException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__InvalidArgumentException ** SOAP_FMAC4 soap_get_PointerTotns3__InvalidArgumentException(struct soap *soap, tns3__InvalidArgumentException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__InvalidArgumentException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__InternalException(struct soap *soap, tns3__InternalException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__InternalException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__InternalException(struct soap *soap, const char *tag, int id, tns3__InternalException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__InternalException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__InternalException ** SOAP_FMAC4 soap_in_PointerTotns3__InternalException(struct soap *soap, const char *tag, tns3__InternalException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__InternalException **)soap_malloc(soap, sizeof(tns3__InternalException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__InternalException *)soap_instantiate_tns3__InternalException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__InternalException ** p = (tns3__InternalException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__InternalException, sizeof(tns3__InternalException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__InternalException(struct soap *soap, tns3__InternalException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__InternalException);
	if (soap_out_PointerTotns3__InternalException(soap, tag?tag:"tns3:InternalException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__InternalException ** SOAP_FMAC4 soap_get_PointerTotns3__InternalException(struct soap *soap, tns3__InternalException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__InternalException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__ExistsException(struct soap *soap, tns3__ExistsException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__ExistsException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__ExistsException(struct soap *soap, const char *tag, int id, tns3__ExistsException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__ExistsException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__ExistsException ** SOAP_FMAC4 soap_in_PointerTotns3__ExistsException(struct soap *soap, const char *tag, tns3__ExistsException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__ExistsException **)soap_malloc(soap, sizeof(tns3__ExistsException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__ExistsException *)soap_instantiate_tns3__ExistsException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__ExistsException ** p = (tns3__ExistsException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__ExistsException, sizeof(tns3__ExistsException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__ExistsException(struct soap *soap, tns3__ExistsException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__ExistsException);
	if (soap_out_PointerTotns3__ExistsException(soap, tag?tag:"tns3:ExistsException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__ExistsException ** SOAP_FMAC4 soap_get_PointerTotns3__ExistsException(struct soap *soap, tns3__ExistsException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__ExistsException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__CannotCancelException(struct soap *soap, tns3__CannotCancelException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__CannotCancelException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__CannotCancelException(struct soap *soap, const char *tag, int id, tns3__CannotCancelException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__CannotCancelException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__CannotCancelException ** SOAP_FMAC4 soap_in_PointerTotns3__CannotCancelException(struct soap *soap, const char *tag, tns3__CannotCancelException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__CannotCancelException **)soap_malloc(soap, sizeof(tns3__CannotCancelException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__CannotCancelException *)soap_instantiate_tns3__CannotCancelException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__CannotCancelException ** p = (tns3__CannotCancelException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__CannotCancelException, sizeof(tns3__CannotCancelException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__CannotCancelException(struct soap *soap, tns3__CannotCancelException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__CannotCancelException);
	if (soap_out_PointerTotns3__CannotCancelException(soap, tag?tag:"tns3:CannotCancelException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__CannotCancelException ** SOAP_FMAC4 soap_get_PointerTotns3__CannotCancelException(struct soap *soap, tns3__CannotCancelException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__CannotCancelException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__AuthorizationException(struct soap *soap, tns3__AuthorizationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__AuthorizationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__AuthorizationException(struct soap *soap, const char *tag, int id, tns3__AuthorizationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__AuthorizationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__AuthorizationException ** SOAP_FMAC4 soap_in_PointerTotns3__AuthorizationException(struct soap *soap, const char *tag, tns3__AuthorizationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__AuthorizationException **)soap_malloc(soap, sizeof(tns3__AuthorizationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__AuthorizationException *)soap_instantiate_tns3__AuthorizationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__AuthorizationException ** p = (tns3__AuthorizationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__AuthorizationException, sizeof(tns3__AuthorizationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__AuthorizationException(struct soap *soap, tns3__AuthorizationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__AuthorizationException);
	if (soap_out_PointerTotns3__AuthorizationException(soap, tag?tag:"tns3:AuthorizationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__AuthorizationException ** SOAP_FMAC4 soap_get_PointerTotns3__AuthorizationException(struct soap *soap, tns3__AuthorizationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__AuthorizationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToconfig__ServiceBusyException(struct soap *soap, config__ServiceBusyException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_config__ServiceBusyException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToconfig__ServiceBusyException(struct soap *soap, const char *tag, int id, config__ServiceBusyException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_config__ServiceBusyException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 config__ServiceBusyException ** SOAP_FMAC4 soap_in_PointerToconfig__ServiceBusyException(struct soap *soap, const char *tag, config__ServiceBusyException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (config__ServiceBusyException **)soap_malloc(soap, sizeof(config__ServiceBusyException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (config__ServiceBusyException *)soap_instantiate_config__ServiceBusyException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	config__ServiceBusyException ** p = (config__ServiceBusyException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_config__ServiceBusyException, sizeof(config__ServiceBusyException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToconfig__ServiceBusyException(struct soap *soap, config__ServiceBusyException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToconfig__ServiceBusyException);
	if (soap_out_PointerToconfig__ServiceBusyException(soap, tag?tag:"config:ServiceBusyException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 config__ServiceBusyException ** SOAP_FMAC4 soap_get_PointerToconfig__ServiceBusyException(struct soap *soap, config__ServiceBusyException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToconfig__ServiceBusyException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToconfig__InvalidConfigurationException(struct soap *soap, config__InvalidConfigurationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_config__InvalidConfigurationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToconfig__InvalidConfigurationException(struct soap *soap, const char *tag, int id, config__InvalidConfigurationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_config__InvalidConfigurationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 config__InvalidConfigurationException ** SOAP_FMAC4 soap_in_PointerToconfig__InvalidConfigurationException(struct soap *soap, const char *tag, config__InvalidConfigurationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (config__InvalidConfigurationException **)soap_malloc(soap, sizeof(config__InvalidConfigurationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (config__InvalidConfigurationException *)soap_instantiate_config__InvalidConfigurationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	config__InvalidConfigurationException ** p = (config__InvalidConfigurationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_config__InvalidConfigurationException, sizeof(config__InvalidConfigurationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToconfig__InvalidConfigurationException(struct soap *soap, config__InvalidConfigurationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToconfig__InvalidConfigurationException);
	if (soap_out_PointerToconfig__InvalidConfigurationException(soap, tag?tag:"config:InvalidConfigurationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 config__InvalidConfigurationException ** SOAP_FMAC4 soap_get_PointerToconfig__InvalidConfigurationException(struct soap *soap, config__InvalidConfigurationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToconfig__InvalidConfigurationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToconfig__InternalException(struct soap *soap, config__InternalException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_config__InternalException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToconfig__InternalException(struct soap *soap, const char *tag, int id, config__InternalException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_config__InternalException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 config__InternalException ** SOAP_FMAC4 soap_in_PointerToconfig__InternalException(struct soap *soap, const char *tag, config__InternalException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (config__InternalException **)soap_malloc(soap, sizeof(config__InternalException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (config__InternalException *)soap_instantiate_config__InternalException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	config__InternalException ** p = (config__InternalException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_config__InternalException, sizeof(config__InternalException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToconfig__InternalException(struct soap *soap, config__InternalException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToconfig__InternalException);
	if (soap_out_PointerToconfig__InternalException(soap, tag?tag:"config:InternalException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 config__InternalException ** SOAP_FMAC4 soap_get_PointerToconfig__InternalException(struct soap *soap, config__InternalException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToconfig__InternalException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToconfig__AuthorizationException(struct soap *soap, config__AuthorizationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_config__AuthorizationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToconfig__AuthorizationException(struct soap *soap, const char *tag, int id, config__AuthorizationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_config__AuthorizationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 config__AuthorizationException ** SOAP_FMAC4 soap_in_PointerToconfig__AuthorizationException(struct soap *soap, const char *tag, config__AuthorizationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (config__AuthorizationException **)soap_malloc(soap, sizeof(config__AuthorizationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (config__AuthorizationException *)soap_instantiate_config__AuthorizationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	config__AuthorizationException ** p = (config__AuthorizationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_config__AuthorizationException, sizeof(config__AuthorizationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToconfig__AuthorizationException(struct soap *soap, config__AuthorizationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToconfig__AuthorizationException);
	if (soap_out_PointerToconfig__AuthorizationException(soap, tag?tag:"config:AuthorizationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 config__AuthorizationException ** SOAP_FMAC4 soap_get_PointerToconfig__AuthorizationException(struct soap *soap, config__AuthorizationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToconfig__AuthorizationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3__delegation__DelegationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_delegation__DelegationException(struct soap *soap, const char *tag, int id, _delegation__DelegationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3__delegation__DelegationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _delegation__DelegationException ** SOAP_FMAC4 soap_in_PointerTo_delegation__DelegationException(struct soap *soap, const char *tag, _delegation__DelegationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_delegation__DelegationException **)soap_malloc(soap, sizeof(_delegation__DelegationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_delegation__DelegationException *)soap_instantiate__delegation__DelegationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_delegation__DelegationException ** p = (_delegation__DelegationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3__delegation__DelegationException, sizeof(_delegation__DelegationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTo_delegation__DelegationException);
	if (soap_out_PointerTo_delegation__DelegationException(soap, tag?tag:"delegation:DelegationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _delegation__DelegationException ** SOAP_FMAC4 soap_get_PointerTo_delegation__DelegationException(struct soap *soap, _delegation__DelegationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_delegation__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolog__Log(struct soap *soap, log__Log *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_log__Log))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolog__Log(struct soap *soap, const char *tag, int id, log__Log *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_log__Log);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 log__Log ** SOAP_FMAC4 soap_in_PointerTolog__Log(struct soap *soap, const char *tag, log__Log **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (log__Log **)soap_malloc(soap, sizeof(log__Log *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (log__Log *)soap_instantiate_log__Log(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	log__Log ** p = (log__Log **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_log__Log, sizeof(log__Log), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolog__Log(struct soap *soap, log__Log *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTolog__Log);
	if (soap_out_PointerTolog__Log(soap, tag?tag:"log:Log", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 log__Log ** SOAP_FMAC4 soap_get_PointerTolog__Log(struct soap *soap, log__Log **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolog__Log(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__FileTransferStatus2(struct soap *soap, tns3__FileTransferStatus2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__FileTransferStatus2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__FileTransferStatus2(struct soap *soap, const char *tag, int id, tns3__FileTransferStatus2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__FileTransferStatus2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__FileTransferStatus2 ** SOAP_FMAC4 soap_in_PointerTotns3__FileTransferStatus2(struct soap *soap, const char *tag, tns3__FileTransferStatus2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__FileTransferStatus2 **)soap_malloc(soap, sizeof(tns3__FileTransferStatus2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__FileTransferStatus2 *)soap_instantiate_tns3__FileTransferStatus2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__FileTransferStatus2 ** p = (tns3__FileTransferStatus2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__FileTransferStatus2, sizeof(tns3__FileTransferStatus2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__FileTransferStatus2(struct soap *soap, tns3__FileTransferStatus2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus2);
	if (soap_out_PointerTotns3__FileTransferStatus2(soap, tag?tag:"tns3:FileTransferStatus2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__FileTransferStatus2 ** SOAP_FMAC4 soap_get_PointerTotns3__FileTransferStatus2(struct soap *soap, tns3__FileTransferStatus2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__FileTransferStatus2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__FileTransferStatus(struct soap *soap, tns3__FileTransferStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__FileTransferStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__FileTransferStatus(struct soap *soap, const char *tag, int id, tns3__FileTransferStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__FileTransferStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__FileTransferStatus ** SOAP_FMAC4 soap_in_PointerTotns3__FileTransferStatus(struct soap *soap, const char *tag, tns3__FileTransferStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__FileTransferStatus **)soap_malloc(soap, sizeof(tns3__FileTransferStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__FileTransferStatus *)soap_instantiate_tns3__FileTransferStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__FileTransferStatus ** p = (tns3__FileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__FileTransferStatus, sizeof(tns3__FileTransferStatus), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (tns3__FileTransferStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__FileTransferStatus2, sizeof(tns3__FileTransferStatus2), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__FileTransferStatus(struct soap *soap, tns3__FileTransferStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__FileTransferStatus);
	if (soap_out_PointerTotns3__FileTransferStatus(soap, tag?tag:"tns3:FileTransferStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__FileTransferStatus ** SOAP_FMAC4 soap_get_PointerTotns3__FileTransferStatus(struct soap *soap, tns3__FileTransferStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__FileTransferStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__StringPair(struct soap *soap, tns3__StringPair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__StringPair))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__StringPair(struct soap *soap, const char *tag, int id, tns3__StringPair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__StringPair);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__StringPair ** SOAP_FMAC4 soap_in_PointerTotns3__StringPair(struct soap *soap, const char *tag, tns3__StringPair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__StringPair **)soap_malloc(soap, sizeof(tns3__StringPair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__StringPair *)soap_instantiate_tns3__StringPair(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__StringPair ** p = (tns3__StringPair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__StringPair, sizeof(tns3__StringPair), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__StringPair(struct soap *soap, tns3__StringPair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__StringPair);
	if (soap_out_PointerTotns3__StringPair(soap, tag?tag:"tns3:StringPair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__StringPair ** SOAP_FMAC4 soap_get_PointerTotns3__StringPair(struct soap *soap, tns3__StringPair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__StringPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__JobStatus(struct soap *soap, tns3__JobStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__JobStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__JobStatus(struct soap *soap, const char *tag, int id, tns3__JobStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__JobStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__JobStatus ** SOAP_FMAC4 soap_in_PointerTotns3__JobStatus(struct soap *soap, const char *tag, tns3__JobStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__JobStatus **)soap_malloc(soap, sizeof(tns3__JobStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__JobStatus *)soap_instantiate_tns3__JobStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__JobStatus ** p = (tns3__JobStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__JobStatus, sizeof(tns3__JobStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__JobStatus(struct soap *soap, tns3__JobStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__JobStatus);
	if (soap_out_PointerTotns3__JobStatus(soap, tag?tag:"tns3:JobStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__JobStatus ** SOAP_FMAC4 soap_get_PointerTotns3__JobStatus(struct soap *soap, tns3__JobStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__JobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJobElement3(struct soap *soap, tns3__TransferJobElement3 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJobElement3))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJobElement3(struct soap *soap, const char *tag, int id, tns3__TransferJobElement3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJobElement3);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJobElement3 ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJobElement3(struct soap *soap, const char *tag, tns3__TransferJobElement3 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJobElement3 **)soap_malloc(soap, sizeof(tns3__TransferJobElement3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJobElement3 *)soap_instantiate_tns3__TransferJobElement3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJobElement3 ** p = (tns3__TransferJobElement3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobElement3, sizeof(tns3__TransferJobElement3), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJobElement3(struct soap *soap, tns3__TransferJobElement3 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJobElement3);
	if (soap_out_PointerTotns3__TransferJobElement3(soap, tag?tag:"tns3:TransferJobElement3", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJobElement3 ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJobElement3(struct soap *soap, tns3__TransferJobElement3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJobElement3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_fts3_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJobElement2(struct soap *soap, tns3__TransferJobElement2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJobElement2))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJobElement2(struct soap *soap, const char *tag, int id, tns3__TransferJobElement2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJobElement2);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJobElement2 ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJobElement2(struct soap *soap, const char *tag, tns3__TransferJobElement2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJobElement2 **)soap_malloc(soap, sizeof(tns3__TransferJobElement2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJobElement2 *)soap_instantiate_tns3__TransferJobElement2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJobElement2 ** p = (tns3__TransferJobElement2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobElement2, sizeof(tns3__TransferJobElement2), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJobElement2(struct soap *soap, tns3__TransferJobElement2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJobElement2);
	if (soap_out_PointerTotns3__TransferJobElement2(soap, tag?tag:"tns3:TransferJobElement2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJobElement2 ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJobElement2(struct soap *soap, tns3__TransferJobElement2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJobElement2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferJobElement(struct soap *soap, tns3__TransferJobElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferJobElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferJobElement(struct soap *soap, const char *tag, int id, tns3__TransferJobElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferJobElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferJobElement ** SOAP_FMAC4 soap_in_PointerTotns3__TransferJobElement(struct soap *soap, const char *tag, tns3__TransferJobElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferJobElement **)soap_malloc(soap, sizeof(tns3__TransferJobElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferJobElement *)soap_instantiate_tns3__TransferJobElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferJobElement ** p = (tns3__TransferJobElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferJobElement, sizeof(tns3__TransferJobElement), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferJobElement(struct soap *soap, tns3__TransferJobElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferJobElement);
	if (soap_out_PointerTotns3__TransferJobElement(soap, tag?tag:"tns3:TransferJobElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferJobElement ** SOAP_FMAC4 soap_get_PointerTotns3__TransferJobElement(struct soap *soap, tns3__TransferJobElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferJobElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns3__TransferParams(struct soap *soap, tns3__TransferParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_tns3__TransferParams))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns3__TransferParams(struct soap *soap, const char *tag, int id, tns3__TransferParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_tns3__TransferParams);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns3__TransferParams ** SOAP_FMAC4 soap_in_PointerTotns3__TransferParams(struct soap *soap, const char *tag, tns3__TransferParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns3__TransferParams **)soap_malloc(soap, sizeof(tns3__TransferParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns3__TransferParams *)soap_instantiate_tns3__TransferParams(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns3__TransferParams ** p = (tns3__TransferParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_tns3__TransferParams, sizeof(tns3__TransferParams), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns3__TransferParams(struct soap *soap, tns3__TransferParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTotns3__TransferParams);
	if (soap_out_PointerTotns3__TransferParams(soap, tag?tag:"tns3:TransferParams", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns3__TransferParams ** SOAP_FMAC4 soap_get_PointerTotns3__TransferParams(struct soap *soap, tns3__TransferParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns3__TransferParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fts3_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_fts3_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fts3_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fts3_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_fts3__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_fts3__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_fts3_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_fts3_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_fts3_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fts3_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, std::vector<log__Log * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, const std::vector<log__Log * >*a)
{
	for (std::vector<log__Log * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTolog__Log(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, const char *tag, int id, const std::vector<log__Log * >*a, const char *type)
{
	for (std::vector<log__Log * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTolog__Log(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<log__Log * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, const char *tag, std::vector<log__Log * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTolog__Log(soap, -1)))
		return NULL;
	log__Log *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_log__Log, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTolog__Log, sizeof(log__Log), 1))
				break;
			if (!soap_in_PointerTolog__Log(soap, tag, NULL, "log:Log"))
				break;
		}
		else
		{
			if (!soap_in_PointerTolog__Log(soap, tag, &n, "log:Log"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<log__Log * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTolog__Log(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTolog__Log, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<log__Log * >);
		if (size)
			*size = sizeof(std::vector<log__Log * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<log__Log * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<log__Log * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<log__Log * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTolog__Log(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<log__Log * > %p -> %p\n", q, p));
	*(std::vector<log__Log * >*)p = *(std::vector<log__Log * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, std::vector<tns3__FileTransferStatus2 * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, const std::vector<tns3__FileTransferStatus2 * >*a)
{
	for (std::vector<tns3__FileTransferStatus2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__FileTransferStatus2(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, const char *tag, int id, const std::vector<tns3__FileTransferStatus2 * >*a, const char *type)
{
	for (std::vector<tns3__FileTransferStatus2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__FileTransferStatus2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__FileTransferStatus2 * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, const char *tag, std::vector<tns3__FileTransferStatus2 * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(soap, -1)))
		return NULL;
	tns3__FileTransferStatus2 *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__FileTransferStatus2, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus2, sizeof(tns3__FileTransferStatus2), 1))
				break;
			if (!soap_in_PointerTotns3__FileTransferStatus2(soap, tag, NULL, "tns3:FileTransferStatus2"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__FileTransferStatus2(soap, tag, &n, "tns3:FileTransferStatus2"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__FileTransferStatus2 * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__FileTransferStatus2 * >);
		if (size)
			*size = sizeof(std::vector<tns3__FileTransferStatus2 * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__FileTransferStatus2 * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__FileTransferStatus2 * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__FileTransferStatus2 * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__FileTransferStatus2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__FileTransferStatus2 * > %p -> %p\n", q, p));
	*(std::vector<tns3__FileTransferStatus2 * >*)p = *(std::vector<tns3__FileTransferStatus2 * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, std::vector<tns3__FileTransferStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, const std::vector<tns3__FileTransferStatus * >*a)
{
	for (std::vector<tns3__FileTransferStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__FileTransferStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, const char *tag, int id, const std::vector<tns3__FileTransferStatus * >*a, const char *type)
{
	for (std::vector<tns3__FileTransferStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__FileTransferStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__FileTransferStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, const char *tag, std::vector<tns3__FileTransferStatus * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__FileTransferStatus(soap, -1)))
		return NULL;
	tns3__FileTransferStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__FileTransferStatus, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus, sizeof(tns3__FileTransferStatus), 1))
				break;
			if (!soap_in_PointerTotns3__FileTransferStatus(soap, tag, NULL, "tns3:FileTransferStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__FileTransferStatus(soap, tag, &n, "tns3:FileTransferStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__FileTransferStatus * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__FileTransferStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__FileTransferStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__FileTransferStatus * >);
		if (size)
			*size = sizeof(std::vector<tns3__FileTransferStatus * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__FileTransferStatus * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__FileTransferStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__FileTransferStatus * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__FileTransferStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__FileTransferStatus * > %p -> %p\n", q, p));
	*(std::vector<tns3__FileTransferStatus * >*)p = *(std::vector<tns3__FileTransferStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, std::vector<tns3__JobStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, const std::vector<tns3__JobStatus * >*a)
{
	for (std::vector<tns3__JobStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__JobStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, const char *tag, int id, const std::vector<tns3__JobStatus * >*a, const char *type)
{
	for (std::vector<tns3__JobStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__JobStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__JobStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, const char *tag, std::vector<tns3__JobStatus * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__JobStatus(soap, -1)))
		return NULL;
	tns3__JobStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__JobStatus, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__JobStatus, sizeof(tns3__JobStatus), 1))
				break;
			if (!soap_in_PointerTotns3__JobStatus(soap, tag, NULL, "tns3:JobStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__JobStatus(soap, tag, &n, "tns3:JobStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__JobStatus * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__JobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__JobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__JobStatus * >);
		if (size)
			*size = sizeof(std::vector<tns3__JobStatus * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__JobStatus * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__JobStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__JobStatus * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__JobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__JobStatus * > %p -> %p\n", q, p));
	*(std::vector<tns3__JobStatus * >*)p = *(std::vector<tns3__JobStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, std::vector<tns3__StringPair * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, const std::vector<tns3__StringPair * >*a)
{
	for (std::vector<tns3__StringPair * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__StringPair(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, const char *tag, int id, const std::vector<tns3__StringPair * >*a, const char *type)
{
	for (std::vector<tns3__StringPair * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__StringPair(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__StringPair * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, const char *tag, std::vector<tns3__StringPair * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__StringPair(soap, -1)))
		return NULL;
	tns3__StringPair *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__StringPair, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__StringPair, sizeof(tns3__StringPair), 1))
				break;
			if (!soap_in_PointerTotns3__StringPair(soap, tag, NULL, "tns3:StringPair"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__StringPair(soap, tag, &n, "tns3:StringPair"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__StringPair * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__StringPair(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__StringPair, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__StringPair * >);
		if (size)
			*size = sizeof(std::vector<tns3__StringPair * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__StringPair * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__StringPair * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__StringPair * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__StringPair(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__StringPair * > %p -> %p\n", q, p));
	*(std::vector<tns3__StringPair * >*)p = *(std::vector<tns3__StringPair * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, std::vector<tns3__TransferJobElement3 * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, const std::vector<tns3__TransferJobElement3 * >*a)
{
	for (std::vector<tns3__TransferJobElement3 * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__TransferJobElement3(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, const char *tag, int id, const std::vector<tns3__TransferJobElement3 * >*a, const char *type)
{
	for (std::vector<tns3__TransferJobElement3 * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__TransferJobElement3(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__TransferJobElement3 * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, const char *tag, std::vector<tns3__TransferJobElement3 * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__TransferJobElement3(soap, -1)))
		return NULL;
	tns3__TransferJobElement3 *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__TransferJobElement3, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement3, sizeof(tns3__TransferJobElement3), 1))
				break;
			if (!soap_in_PointerTotns3__TransferJobElement3(soap, tag, NULL, "tns3:TransferJobElement3"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__TransferJobElement3(soap, tag, &n, "tns3:TransferJobElement3"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__TransferJobElement3 * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement3(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement3, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement3 * >);
		if (size)
			*size = sizeof(std::vector<tns3__TransferJobElement3 * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement3 * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__TransferJobElement3 * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__TransferJobElement3 * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__TransferJobElement3(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__TransferJobElement3 * > %p -> %p\n", q, p));
	*(std::vector<tns3__TransferJobElement3 * >*)p = *(std::vector<tns3__TransferJobElement3 * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, std::vector<tns3__TransferJobElement2 * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, const std::vector<tns3__TransferJobElement2 * >*a)
{
	for (std::vector<tns3__TransferJobElement2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__TransferJobElement2(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, const char *tag, int id, const std::vector<tns3__TransferJobElement2 * >*a, const char *type)
{
	for (std::vector<tns3__TransferJobElement2 * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__TransferJobElement2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__TransferJobElement2 * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, const char *tag, std::vector<tns3__TransferJobElement2 * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__TransferJobElement2(soap, -1)))
		return NULL;
	tns3__TransferJobElement2 *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__TransferJobElement2, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement2, sizeof(tns3__TransferJobElement2), 1))
				break;
			if (!soap_in_PointerTotns3__TransferJobElement2(soap, tag, NULL, "tns3:TransferJobElement2"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__TransferJobElement2(soap, tag, &n, "tns3:TransferJobElement2"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__TransferJobElement2 * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement2 * >);
		if (size)
			*size = sizeof(std::vector<tns3__TransferJobElement2 * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement2 * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__TransferJobElement2 * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__TransferJobElement2 * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__TransferJobElement2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__TransferJobElement2 * > %p -> %p\n", q, p));
	*(std::vector<tns3__TransferJobElement2 * >*)p = *(std::vector<tns3__TransferJobElement2 * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, std::vector<tns3__TransferJobElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, const std::vector<tns3__TransferJobElement * >*a)
{
	for (std::vector<tns3__TransferJobElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns3__TransferJobElement(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, const char *tag, int id, const std::vector<tns3__TransferJobElement * >*a, const char *type)
{
	for (std::vector<tns3__TransferJobElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns3__TransferJobElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns3__TransferJobElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, const char *tag, std::vector<tns3__TransferJobElement * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns3__TransferJobElement(soap, -1)))
		return NULL;
	tns3__TransferJobElement *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_tns3__TransferJobElement, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement, sizeof(tns3__TransferJobElement), 1))
				break;
			if (!soap_in_PointerTotns3__TransferJobElement(soap, tag, NULL, "tns3:TransferJobElement"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns3__TransferJobElement(soap, tag, &n, "tns3:TransferJobElement"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns3__TransferJobElement * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns3__TransferJobElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfPointerTotns3__TransferJobElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement * >);
		if (size)
			*size = sizeof(std::vector<tns3__TransferJobElement * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns3__TransferJobElement * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns3__TransferJobElement * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns3__TransferJobElement * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns3__TransferJobElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns3__TransferJobElement * > %p -> %p\n", q, p));
	*(std::vector<tns3__TransferJobElement * >*)p = *(std::vector<tns3__TransferJobElement * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fts3_std__string, SOAP_TYPE_fts3_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fts3_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

} // namespace fts3


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of fts3C.cpp */
